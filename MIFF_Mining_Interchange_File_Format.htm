<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href="style_reset.css">
  <link rel="stylesheet" type="text/css" href="style.css">
  <title>M.I.F.F.: Mining Interchange File Format</title>

  <!-- Script for generation a table of contents -->
  <script>
const indexLEVEL     = 0;
const indexTAG       = 1;
const indexTITLE     = 2;
const indexHAS_TYPE  = 3;
const indexHAS_CONST = 4;
const indexHAS_FUNC  = 5;
const indexCOUNT     = 6;

var tocIndex = 0;
var toc      = [];

// Display a header line and add to the table of contents (TOC)
function HeaderAdd(level, tag, title)
{
   var record = [];
   
   record[indexLEVEL]     = level;
   record[indexTAG]       = tag;
   record[indexTITLE]     = title;
   record[indexHAS_TYPE]  = false;
   record[indexHAS_CONST] = false;
   record[indexHAS_FUNC]  = false;

   toc.push(record);

   // Chrome complains about this document write.  I have looked for an alternative but everything
   // I have found is utter rubbish.  HeaderAdd is only called on doc load.  This call is not a
   // problem.
   document.write("<h" + level + "><a name=\"" + tag + "\">" + title + "</a></h" + level + ">\n\n");
}

function HeaderAddType()
{
   var record = toc[toc.length - 1];

   record[indexHAS_TYPE] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Type\">Type</a></h2>\n\n");
}

function HeaderAddConst()
{
   var record = toc[toc.length - 1];

   record[indexHAS_CONST] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Const\">Constant</a></h2>\n\n");
}

function HeaderAddFunc()
{
   var record = toc[toc.length - 1];

   record[indexHAS_FUNC] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Func\">Function</a></h2>\n\n");
}

// Update the TOC with all the header lines.
function UpdateToc()
{
   var value;
   var record;
   var index;

   value = "<table>\n";

   for (; tocIndex < toc.length; tocIndex++)
   {
      record     = toc[tocIndex];
    
      value += "<tr>\n<td>";
    
      // Indenting
      for (index = 1; index < record[0]; index++)
      {
         value += "&nbsp;&nbsp;&nbsp;&nbsp;";
      }

      value += "<a href=\"#" + record[1] + "\">" + record[2] + "</a></td>\n";
      
      value += "<td>";
      if (record[indexHAS_TYPE] == 1)
      {
         value += "<a href=\"#" + record[1] + "Type\">Type</a>\n";
      }
      value += "</td>\n";
      
      value += "<td>";
      if (record[indexHAS_CONST] == 1)
      {
         value += "<a href=\"#" + record[1] + "Const\">Constant</a>\n";
      }
      value += "</td>\n";

      value += "<td>";
      if (record[indexHAS_FUNC] == 1)
      {
         value += "<a href=\"#" + record[1] + "Func\">Function</a>\n";
      }
      value += "</td>\n";

      value += "</td>\n";
   }

   value += "</table>\n";

   document.getElementById("toc").innerHTML = value;
}
  </script>
 </head>
 <body>
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <h1 class="page">M.I.F.F.: Mining Interchange File Format</h1>

  <table>
   <tr>
    <td><p>Author:</p></td>
    <td>Robbert de Groot</td>
   </tr>
   <tr>
    <td><p>Date:</p></td>
    <td>2019-05-15</td>
   </tr>
   <tr>
    <td><p>Copyright:</p></td>
    <td>2019, Robbert de Groot</td>
   </tr>
   <tr>
    <td><p>License:</p></td>
    <td>The library will be MIT License.</td>
   </tr>
   <tr>
    <td></td>
    <td>
     This document is licensed under Creative Commons Attribution-NoDerivs. <a href="https://creativecommons.org/licenses/by-nd/4.0/">
 (CC BY-ND)</a>
    </td>
   </tr>
  </table>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <h2>Table Of Contents:</h2>

  <p id="toc"></p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "miff", "M.I.F.F.");</script>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "about", "Discussion");</script>
  <p>
   What is the purpose of M.I.F.F.? (MIFF from now on.)  MIFF is intended to be a file format for 
   exporting and importing data from one Mining software package to another Mining software package.
  </p>
  <p>
   Users of software packages are becoming increasingly annoyed at the lack of interoperability 
   between software packages.  Currently each software package attempts to do its best at 
   supporting competitor file formats but there are often a lot of loss of data or, as data formats
   in each package evolves, suffer from compatibility issues.  Often data needs to be dumped to 
   very basic, raw ASCII files, like csv files, which are often lacking compared to the original
   data.  Often users will need to massage this raw data in order to import it into their target 
   software package.  
  </p>
  <p>
   A lot of the client's time is lost with all this work.  The idea with an interchange format is 
   to remove some of the pain of this data transfer task and put more of the pain on the software
   vendors of doing the hard part of reading in the data to their expectations.  The software users
   will not need to know some of the intricacies of the data or task.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "goals", "Goals");</script>

  <p>
   The main goal of this format is to be specifically an interchange format.  It is not intended
   to be a native format for any software package.  The focus is to make it easy for the developers
   from any software package to export their data to this interchange format and, without too much
   difficulty, to import other vendor's data.  
  </p>
  <p>
   For the users of the software packages, the process of moving data from package to package will
   be much easier, less time consuming, and less problematic as they will only have to export and
   import to just one type of file instead of various file formats and more intimate knowledge of
   the data transfer process.
  </p>

  <ul>
   <li>
    Simple.  The format should be simple for the developers to export their data.  Import may still
    be challenging because of the differences between software packages but the format to import 
    the data should not impose too much pain for the developers either.  The simplicity should go a
    long way in getting the format adopted and implemented.
   </li>
   <li>
    Inclusive.  All data from all venders should be representable with the least amount of 
    compromizes in the data being exported.  
   </li>
   <li>
    Brief.  The format should not produce unnecessary waste.  The data in some cases will be quite
    large so it should not bloat the data too much.  Meaning, file sizes should not become overly
    large.  However, because of point 1 there will always be some bloat.
   </li>
   <li>
    Flexibility.  The format needs to be able to accomodate change or vendor specific data.  A few
    software vendors started life in the 70's with time shared machines.  Over the years the amount
    of data and the types of data the clients want to maintain has changed and grown.  A format 
    needs to try its best to keep up without importers and exporters to be completely remade.
   </li>
  </ul>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "disclosure", "Disclosure");</script>

  <p>
   As of this writing I, Robbert de Groot, am a Principal Software Developer with Hexagon 
   (previously known as (pka) Hexagon Mining, pka MineSight, pka Mintec Inc.), the current owners 
   of MinePlan 3D software (pka MineSight 3D; pka MEDSystem.); Leica Geosystems, the makers of 
   survey equipment and related material; as well as other mine related hardware and software 
   products.  
  </p>
  <p>
   This format is currently not sanctioned by any software vendor or even by Hexagon.  This was 
   something spurned by recent efforts being made by Global Mining Guidelines (GMG), with Open 
   Mining Format (OMF), which seems to have the backing of some big players in the industry.  My 
   issue with OMF for now is that they only have a Python library that implements the format 
   available publically.  They may have a specification document somewhere but currently it is not
   available, or at least I cannot find it anywhere in the 'open'.  Plus this format seems to be
   strictly binary, which is not entirely a bad idea considering the data that needs to be passed 
   around, but binary formats can be very fussy.  And inspecting their sample OMF file, it does not
   look like something that is easily reverse engineered.
  </p>
  <p>
   Having said that, I thought I would try my hand at defining a format what I think would be good
   as an interchange format.  I am trying to write MIFF independent of any software package.  
   However there may be some unintended bias as I am most familiar with MinePlan 3D I have worked 
   on.  I do intend to include other software package requirements as best as I understand them.
  </p>
  <p>
   If anyone is interested in educating me on some features they would like to see with respect
   to their software package of choice I would love to hear from you.  You can reach me at these 
   two email addresses.
  </p>
  <p>
   robbert.degroot@hexagon.com<br />
   zekaric@gmail.com
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "format", "MIFF Format");</script>

  <p>
   There are two versions of the format.  A Text file and a Binary file version.  They will both 
   contain exactly the same data and be exactly the same in feature set.  The Binary file may just 
   have the advantage of being slightly more accurate, possibly slightly more compact and possibly 
   slightly faster.
  </p>
  <p>
   At the low level, a MIFF format is just a collection of key value pairs.  Values can be a 
   collection of further key value pairs.  Meaning nesting can be possible.  Very similar to XML.
  </p>

  <script>HeaderAdd(2, "text", "MIFF Text Format");</script>

  <p>
   The text format is a UTF8 text file.  UTF8 is the 1 byte UNICODE format for text.  The format 
   only uses the ASCII characters only (first 128 UNICODE character codes) for the format.
  </p>
  <p>
   I did not take XML as a format because of XML is too verbose.  JSON is very flexible but I also
   find it can be easily abused and still unnecessarily verbose.  Better than XML but still 
   unacceptable in my opinion.  Considering the data, I do not want a format that would cause too 
   much data bloat.  There will always be some bloat happening but it should be mitigated in my 
   opinion.
  </p>
  <p>
   All lines are terminated with a UNIX '\n'.  NOT an MSDOS \r\n or a MAC \n\r ending.  
  </p>

  <script>HeaderAdd(3, "textKeyValue", "Key Value Pair");</script>

  <pre>
[key] [value header] [value]\n

[key] [value header]\n
[value]
...
\n
</pre>

  <p>
   Keys are always a single word.  There can be leading spaces before the key but these are 
   ignored.  There has to be at least one white space between key and value header, and at least
   one white space between value header and the value.  There can be more than one white space 
   character but all this extra white space is ignored.  
  </p>
  <p>
   The first key value pair fits on a single line.  The second key value pair is for when values 
   will span multiple lines.  A multi line key value will terminate with a blank line.  You will
   need multiple blank lines to terminate nested multiline key values.
  </p>
  <p>
   Values depend on the what the key is suppose to define.  
  </p>

  <script>HeaderAdd(3, "textValue", "Value");</script>

  <p>
   There are quite a few different value types and organizations.  Each value is prepended with 
   a header explaining the data you will be reading.
  </p>

  <p>
   Value header is as follows.
  </p>

  <pre>
[type flag][array flag][encoding flag] [array count] [compressed size]

[type flag] is one of:
=  - key value dictionary, no other flags.
"" - string (UTF8) data.
i1 - integer of 1 byte
i2 -            2
i4 -            4
i8 -            8
n1 - natural of 1 byte
n2 -            2
n4 -            4
n8 -            8
r4 - real    of 4 bytes
r8 -            8
p4 - 2d point using r4.
p8 -                r8.
P4 - 3d point using r4.
P8 -                r8.
m4 - 3x3 matrix using r4.  Value will always be multiline.
m8 -                  r8.
M4 - 4x4 matrix using r4.
M8 -                  r8.
c3 - rgb  color using n1.
c4 - rgba color using n1.
C3 - rgb  color using r4.
C4 - rgba color using r4.
g3 - graphic (image) using c3.  Value will always be multiline.
g4 -                       c4.
G3 - graphic         using C3.
G4 -                       C4.
az - azimuth (strike) using r4, azimuth in degrees
ad - dip direction    using r4, dip direction in degrees
Ad - azimuth and dip  using r4, azimuth in degrees, dip in degrees
A% -                                                       percent
A/ -                                                       ratio 1:XXX
dd - dip only         using r4, dip in degrees
d% -                                   percent
d/ -                                   ratio 1:XXX
cs - coordinate system information

[array flag] is one of:
[empty] - default, single data point.
a       - array of data points.  [array count] will follow.  Value will always be multiline.

[encoding flag] needs to be paired with [array flag] a or with g and G options,
is one of:
[empty] - default, UTF8 representation.
x       - hexidecimal encoded, multibyte data in network order.
u       - base64 encoded, multibyte data in network order.
z       - zlib compressed, base64 encoded, multibyte data in network order.  
          [compressed size] will follow.

Examples: (adding \n to indicate the necessity of this line.)
image g3z 
[base64 zip compressed byte stream]
\n

itemList =
[more key values]
...
\n

count n1 128

pointList P8a 5
10.5 20 0
20.5 20 0
20.5 50 0
10.5 50 0
10.5 20 0
\n
</pre>
  
  <script>HeaderAdd(2, "bin", "Binary");</script>

  <p>
   The Binary file will to match the Text file 1-1.  Everything within '[]' is a byte sequence of 
   a known size.  Each byte seqence is separated here with a comma but is immediately following 
   after previous byte sequence.
  </p>
  <p>
   A byte sequence is [[size]:[name]], where size is a number indicating the number of bytes this
   sequence takes up.
  </p>

  <script>HeaderAdd(3, "binKeyValue", "Key Value Pair");</script>

  <pre>
[1:key string length],[key string length:key],[4:value header],[4;array count],
   [4:compress buffer size],[*:value]
</pre>

  <p>
   The first byte defines how long the key string is (no null terminator).  Then 
  </p>















  <script>UpdateToc();</script>

 </body>
</html>
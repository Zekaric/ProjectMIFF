<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href="style_reset.css">
  <link rel="stylesheet" type="text/css" href="style.css">
  <title>M.I.F.F.: Mixed Information File Format</title>

  <!-- Script for generation a table of contents -->
  <script>
const indexLEVEL     = 0;
const indexTAG       = 1;
const indexTITLE     = 2;
const indexHAS_TYPE  = 3;
const indexHAS_CONST = 4;
const indexHAS_FUNC  = 5;
const indexCOUNT     = 6;

var tocIndex = 0;
var toc      = [];

// Display a header line and add to the table of contents (TOC)
function HeaderAdd(level, tag, title)
{
   var record = [];
   
   record[indexLEVEL]     = level;
   record[indexTAG]       = tag;
   record[indexTITLE]     = title;
   record[indexHAS_TYPE]  = false;
   record[indexHAS_CONST] = false;
   record[indexHAS_FUNC]  = false;

   toc.push(record);

   // Chrome complains about this document write.  I have looked for an alternative but everything
   // I have found is utter rubbish.  HeaderAdd is only called on doc load.  This call is not a
   // problem.
   document.write("<h" + level + "><a name=\"" + tag + "\">" + title + "</a></h" + level + ">\n\n");
}

function HeaderAddType()
{
   var record = toc[toc.length - 1];

   record[indexHAS_TYPE] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Type\">Type</a></h2>\n\n");
}

function HeaderAddConst()
{
   var record = toc[toc.length - 1];

   record[indexHAS_CONST] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Const\">Constant</a></h2>\n\n");
}

function HeaderAddFunc()
{
   var record = toc[toc.length - 1];

   record[indexHAS_FUNC] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Func\">Function</a></h2>\n\n");
}

// Update the TOC with all the header lines.
function UpdateToc()
{
   var value;
   var record;
   var index;

   value = "<table>\n";

   for (; tocIndex < toc.length; tocIndex++)
   {
      record     = toc[tocIndex];
    
      value += "<tr>\n<td>";
    
      // Indenting
      for (index = 1; index < record[0]; index++)
      {
         value += "&nbsp;&nbsp;&nbsp;&nbsp;";
      }

      value += "<a href=\"#" + record[1] + "\">" + record[2] + "</a></td>\n";
      
      value += "<td>";
      if (record[indexHAS_TYPE] == 1)
      {
         value += "<a href=\"#" + record[1] + "Type\">Type</a>\n";
      }
      value += "</td>\n";
      
      value += "<td>";
      if (record[indexHAS_CONST] == 1)
      {
         value += "<a href=\"#" + record[1] + "Const\">Constant</a>\n";
      }
      value += "</td>\n";

      value += "<td>";
      if (record[indexHAS_FUNC] == 1)
      {
         value += "<a href=\"#" + record[1] + "Func\">Function</a>\n";
      }
      value += "</td>\n";

      value += "</td>\n";
   }

   value += "</table>\n";

   document.getElementById("toc").innerHTML = value;
}
  </script>
 </head>
 <body>
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <h1 class="page">M.I.F.F.: Mixed Information File Format</h1>

  <table>
   <tr>
    <td><p>Author:</p></td>
    <td>Robbert de Groot</td>
   </tr>
   <tr>
    <td><p>Date:</p></td>
    <td>2019-05-15</td>
   </tr>
   <tr>
    <td><p>Copyright:</p></td>
    <td>2019, Robbert de Groot</td>
   </tr>
   <tr>
    <td><p>License:</p></td>
    <td>The library will be MIT License.</td>
   </tr>
   <tr>
    <td></td>
    <td>This document is licensed under Creative Commons Attribution-NoDerivs. 
	<a href="https://creativecommons.org/licenses/by-nd/4.0/">(CC BY-ND)</a></td>
   </tr>
  </table>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <h1>Table Of Contents:</h1>

  <p id="toc"></p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "miff", "M.I.F.F.");</script>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "about", "Discussion");</script>

  <p>What is the purpose of M.I.F.F. (MIFF)?  MIFF is intended to be a file format for exporting and
  importing data from one software package to another software package.</p>

  <p>Users of software packages are becoming increasingly annoyed at the lack of interoperability
  between software packages.  Currently each software package attempts to do its best at supporting
  competitor file formats but there is often a lot of loss of data or, as data formats in each
  package evolves, suffer from compatibility issues.  Often data needs to be dumped to formats that
  come 'close' but are not exact or down to very basic, raw ASCII files, like csv files, which are
  often lacking compared to the original data.  Users will need to massage this raw data in order
  to import it into their target software package.</p>

  <p>A lot of the client's time is lost with all this work.  The idea with an interchange format is
  to remove some of the pain of this data transfer task and put more of the pain on the software
  vendors of doing the hard part of reading in the data to their expectations.  The software users
  will not need to know some of the intricacies of the data or task.</p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "goals", "Goals");</script>

  <p>The main goal of this format is to be specifically an interchange format.  It is not intended
  to be a native format for any software package.  The focus is to make it easy for the developers
  from any software package to export their data to this interchange format and, without too much
  difficulty, to import other vendor's data.</p>

  <p>For the users of the software packages, the process of moving data from package to package will
  be much easier, less time consuming, and less problematic as they will only have to export and 
  import to just one type of file instead of various file formats and requiring more intimate 
  knowledge of the data transfer process specific to their software packages.</p>

  <ul>
   <li><strong>Simple</strong>.  The format should be simple for the developers to export their 
   data.  Import may still be challenging because of the differences between software packages but
   the format to import the data should not impose too much pain for the developers either.  The
   simplicity should go a long way in getting the format adopted and implemented.</li>

   <li><strong>Inclusive</strong>.  All data from all venders should be representable with the least
   amount of compromizes in the data being exported.</li>

   <li><strong>Brief</strong>.  The format should not produce unnecessary waste.  The data in some
   cases will be quite large so it should not bloat the data too much.  Meaning, file sizes should
   not become overly large.  However, because of point 1 there will always be some bloat.</li>

   <li><strong>Flexible</strong>.  The format needs to be able to accomodate change or vendor
   specific data.  A few software vendors started life in the 70's with time shared machines.  Over
   the years the amount of data and the types of data the clients want to maintain has changed and
   grown.  A format needs to try its best to keep up without importers and exporters to be
   completely remade.</li>
  </ul>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "disclosure", "Disclosure");</script>

  <p>As of this writing I, Robbert de Groot, am a Principal Software Developer with Hexagon
  (previously known as (pka) Hexagon Mining, pka MineSight, pka Mintec Inc.), the current owners of
  MinePlan 3D software (pka MineSight 3D; pka MEDSystem.); Leica Geosystems, the makers of survey
  equipment and related material; as well as other mine related hardware and software products.</p>

  <p>This format is currently not sanctioned by any software vendor, including Hexagon.  This was
  something I am doing as an experiment to satisfy my curiosity.  It was brought about by recent
  efforts being made by Global Mining Guidelines (GMG), with their Open Mining Format (OMF), which
  seems to have the backing of some big players in the industry.  My issue with OMF, for now, is
  that they only have a Python library that implements the format available publically.  They may
  have a specification document somewhere but currently it is not available, or at least I cannot
  find it anywhere in the 'open'.  Plus this format seems to be strictly binary, which is not
  entirely a bad idea considering the data that needs to be passed around, but binary formats can be
  very fussy.  And inspecting their sample OMF file, it does not look like something that is easily 
  reverse engineered.</p>

  <p>So, I thought I would try my hand at defining a format what I think would be good as an
  interchange format.  I am trying to write MIFF independent of any software package.  However there
  may be some unintended bias as I am most familiar with MinePlan 3D for which I have worked on 
  since 1995.  I do intend to keep this format as inclusive as possible to address other software 
  package requirements as best as I understand them.  I know I will make mistakes there because I 
  have only cursory knowledge of most of the competing software in the industry.</p>

  <p>If anyone is interested in educating me on some features they would like to see with respect to
  their software package of choice I would love to hear from you.  You can reach me at either of the
  following two email addresses.</p>

  <p>robbert.degroot@hexagon.com<br />zekaric@gmail.com</p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "formatBase", "MIFF Format: Base");</script>

  <p>There are two representations of the format.  A Text file and a Binary file representation.
  They will both contain exactly the same data and be exactly the same in feature set.  The Binary
  file may just have the advantage of being slightly more accurate, possibly slightly more compact
  and possibly slightly faster in reading and writing.</p>

  <p>At the low level, a MIFF format is just a collection of key value pairs.  Values can be a
  collection of further key value pairs.  Meaning nesting can be possible.</p>

  <p>The intent on reading these files is to make just one pass over them; twice at most, but for
  the most part, one pass over the contents should be enough to read in the data.  There is no
  focus on making the file random accessable or modifiable.  This format is not intended as a
  substitute for native formats for any software package.</p>

  <p>Common to both styles, any mutlibyte data that is encode or stored as a binary byte sequence
  will be in network (big endian) order.</p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formatBaseHeader", "File Header");</script>

  <p>There will always be a file header so that you can be sure the file you recieved is actually a
  MIFF file and not some other file.</p>

  <pre>"MIFF   1TXT\n"</pre>

  <p>or</p>

  <pre>"MIFF   1BIN\n"</pre>

  <p>"MIFF" indicates the base file format type.</p>

  <p>"&nbsp;&nbsp;&nbsp;1" indicates the base file format version.  Currently at version 1.  This
  will only use whole numbers instead of the usual XX.XX.XX.XX versioning of software.</p>

  <p>"TXT\n" and "BIN\n" indicate the content organization.  TXT for text, and BIN for binary.
  "\n" is a line feed character.  This is part of the string.</p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formateBaseContent", "Content");</script>

  <p>Before going into the specifics of the text format and the binary format we will cover what a
  key value pair will look like at a high level.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseContentKeyValue", "Key Value Format");</script>

  <pre>[key] [value header] [value]\n</pre>

  <p><strong>[key]</strong> will be a string that will somewhat uniquely identify the value.</p>
  
  <p><strong>[value header]</strong> will be an code of characters that will dictate what the value
  will look like.</p>

  <p><strong>[value]</strong> will depend on the [value header] on what is contained here.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseContentKey", "Key");</script>

  <p>Keys are always a single string of characters and are limited to printable character in the
  first 127 UNICODE code points.  Meaning no whitespace of any kind inside a key.</p>

  <pre>
12345
;':][.,<>]'
a_b_c
$cost
</pre>

  <p>The key can be nonsense or just a number.  As long it does not include any whitespace.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseContentValueHeader", "Value Header");</script>

  <p>There are quite a few different value types and encodings.  Each value is prepended with a
  header explaining the data you will be reading.</p>

  <p>Value header is as follows.</p>

  <pre>
[type flag][array and encoding flag] [array count] [compressed size]
</pre>

  <p><strong>[type flag]</strong> is one of:</p>

  <table>
   <tr> <th>2 Letter Type Code</th> <th>Description</th></tr>
   <tr> <td>kv</td>                 <td>Key-Value block.</td></tr>
   <tr> <td>""</td>                 <td>String (UTF8) data.</td></tr>
   <tr> <td>bo</td>                 <td>Boolean value.</td></tr>
   <tr> <td>i1</td>                 <td>Integer of 1 byte.</td></tr>
   <tr> <td>i2</td>                 <td>Integer of 2 bytes.</td></tr>
   <tr> <td>i4</td>                 <td>Integer of 4 bytes.</td></tr>
   <tr> <td>i8</td>                 <td>Integer of 8 bytes.</td></tr>
   <tr> <td>n1</td>                 <td>Natural of 1 byte.</td></tr>
   <tr> <td>n2</td>                 <td>Natural of 2 bytes.</td></tr>
   <tr> <td>n4</td>                 <td>Natural of 4 bytes.</td></tr>
   <tr> <td>n8</td>                 <td>Natural of 8 bytes.</td></tr>
   <tr> <td>r4</td>                 <td>Real of 4 bytes.</td></tr>
   <tr> <td>r8</td>                 <td>Real of 8 bytes.</td></tr>
   <tr> <td>pr</td>                 <td>2d value using r4.</td></tr>
   <tr> <td>pR</td>                 <td>2d value using r8.</td></tr>
   <tr> <td>pi</td>                 <td>2d value using i4.</td></tr>
   <tr> <td>pI</td>                 <td>2d value using i8.</td></tr>
   <tr> <td>pn</td>                 <td>2d value using n4.</td></tr>
   <tr> <td>pN</td>                 <td>2d value using n8.</td></tr>
   <tr> <td>Pr</td>                 <td>3d value using r4.</td></tr>
   <tr> <td>PR</td>                 <td>3d value using r8.</td></tr>
   <tr> <td>Pi</td>                 <td>3d value using i4.</td></tr>
   <tr> <td>PI</td>                 <td>3d value using i8.</td></tr>
   <tr> <td>Pn</td>                 <td>3d value using n4.</td></tr>
   <tr> <td>PN</td>                 <td>3d value using n8.</td></tr>
   <tr> <td>mr</td>                 <td>3x3 matrix using r4.</td></tr>
   <tr> <td>mR</td>                 <td>3x3 matrix using r8.</td></tr>
   <tr> <td>Mr</td>                 <td>4x4 matrix using r4.</td></tr>
   <tr> <td>MR</td>                 <td>4x4 matrix using r8.</td></tr>
   <tr> <td>c3</td>                 <td>RGB  color using n1.</td></tr>
   <tr> <td>C3</td>                 <td>RGB  color using r4.</td></tr>
   <tr> <td>c4</td>                 <td>RGBA color using n1.</td></tr>
   <tr> <td>C4</td>                 <td>RGBA color using r4.</td></tr>
   <tr> <td>g3</td>                 <td>Graphic using c3.</td></tr>
   <tr> <td>g4</td>                 <td>Graphic using c4.</td></tr>
   <tr> <td>G3</td>                 <td>Graphic using C3.</td></tr>
   <tr> <td>G4</td>                 <td>Graphic using C4.</td></tr>
   <tr> <td>gp</td>                 <td>Graphic as a PNG file.</td></tr>
   <tr> <td>gj</td>                 <td>Graphic as a JPG file.</td></tr>
   <tr> <td>gJ</td>                 <td>Graphic as a JPG2000 file.</td></tr>
   <tr> <td>gl</td>                 <td>Graphic as a link to a file.</td></tr>
   <tr> <td>az</td>                 <td>Azimuth (strike) using r4. Value in degrees</td></tr>
   <tr> <td>ad</td>                 <td>Dip direction using r4. Value in degrees</td></tr>
   <tr> <td>Ad</td>                 <td>Azimuth and Dip using r4. Azimuth in degrees. Dip in degrees</td></tr>
   <tr> <td>A%</td>                 <td>Azimuth and Dip using r4. Azimuth in degrees. Dip in percent</td></tr>
   <tr> <td>A/</td>                 <td>Azimuth and Dip using r4. Azimuth in degrees. Dip in ratio 1:XXX</td></tr>
   <tr> <td>dd</td>                 <td>Dip using r4. Value in degrees</td></tr>
   <tr> <td>d%</td>                 <td>Dip using r4. Value in percent</td></tr>
   <tr> <td>d/</td>                 <td>Dip using r4. Value in ratio 1:XXX</td></tr>
   <tr> <td>td</td>                 <td>Time, date only.</td></tr>
   <tr> <td>tt</td>                 <td>Time, time only.</td></tr>
   <tr> <td>t*</td>                 <td>Time, date and time.</td></tr>
   <tr> <td>co</td>                 <td>Count same as n4.</td></tr>
   <tr> <td>Co</td>                 <td>Count same as n8.</td></tr>
   <tr> <td>sz</td>                 <td>Size same as n4.</td></tr>
   <tr> <td>Sz</td>                 <td>Size same as n8.</td></tr>
   <tr> <td>ix</td>                 <td>Index same as n4.</td></tr>
   <tr> <td>Ix</td>                 <td>Index same as n8.</td></tr>
   <tr> <td>of</td>                 <td>Offset same as n4.</td></tr>
   <tr> <td>Of</td>                 <td>Offset same as n8.</td></tr>
   <tr> <td>id</td>                 <td>Id value, same as n4.  Potentially not unique, user controlled value.</td></tr>
   <tr> <td>Id</td>                 <td>GUID value.  Must be unique in a given MIFF file.</td></tr>
   <tr> <td>ty</td>                 <td>Type value.  One of these 2 lettter type codes</td></tr>
   <tr> <td>vs</td>                 <td>Value stream.  The contents deviates from the rest of the format.  Representations will explained in their respective sections.</td></tr>
   <tr> <td>bn</td>                 <td>Binary data.</td></tr>
  </table>

  <p><strong>[array and encoding flag]</strong> is one of:</p>

  <table>
   <tr> <th>Encoding Code</th> <th>Description</th></tr>
   <tr> <td>e</td>             <td>Text format only. Single data point.  Base64 encoded.</td>
   <tr> <td>E</td>             <td>Text format only. Array of data points.</td>
   <tr> <td>A</td>             <td>Array of data points.</td></tr>
   <tr> <td>z</td>             <td>Single data point.  Zlib compressed, base64 encoded.</td>
   <tr> <td>Z</td>             <td>Array of data points.</td>
  </table>

  <p><strong>[array count]</strong> will only present when E, A, and Z are used.  This will be an 
  unsigned integer value indicating how many items are in the array.</p>

  <p><strong>[compressed size]</strong> will only present when z and Z are used.  This will be an 
  unsigned integer value indicating the raw, in memory byte count of the compressed data buffer.</p>

  <p>e and E are only used in the Text represention of a MIFF file.  Binary representation only has
  one way to store data.</p>
  
  <p>A is used to indicate an array of values.  If used the array is either too small to really need
  compression or too random that compression will not really reduce the byte count.</p>

  <p>e, E, z, and Z will generate a base64 encoded string in the Text format.  This string lives on 
  one line, there are no '\n' embedded in the encoding.</p>

  <p>Why co, Co, sz, Sz, ix, Ix, of, and Of when n4 and n8 would suffice?  The extra semantic 
  information about what we are storing may be useful and it separates these values with a hard 
  coded representation.  Potentially in the future, the representation may change to accommodate 
  larger values.  In which case older MIFF files need not have to change.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseContentValue", "Value");</script>

  <p>The value header generally indicates what will be stored in the value of the key value pair.
  It then becomes an issue on how it is represented in the two types of files.  See their respective
  sections for the details.</p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formateBaseText", "Text Format");</script>

  <p>The text format is a UTF8 text file.  UTF8 is the 1 byte UNICODE format for text.  The base 
  format only uses the ASCII characters (first 128 UNICODE character codes).  UTF8 mainly comes into
  play with the string data being stored.</p>

  <p>The format is only somewhat human readable, and only somewhat text editor friendly, but it 
  really is not meant to be "human friendly."  What I mean is that you will be able to look at the
  format in a text editor (if the text editor is capable of handling really large files with really
  long lines) and if you know this format to a certain degree, you will be able to debug it.  To
  a certain degree you should be able to debug the binary version as well since it will not be too
  different than the text version.</p>

  <p>The format does not adhere to any line length limit.  So if you are using a text editor that
  does have line length limits you may end up corrupting the file or may not be seeing the whole
  file.</p>

  <p>All lines are terminated with a UNIX '\n'.  NOT an MSDOS \r\n or a MAC \n\r ending.  This is a
  strict rule.  If the file has \r\n or \n\r line endings then it is not a MIFF file.  No 
  exceptions.</p>

  <p>'\r' (Cursor Return) should not appear anywhere in the format unless writted explicitely as 
  '\', 'r'.  Meaning that it has been 'escaped' and that will only be in string values.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseTextWhitespace", "Whitespace Characters");</script>

  <p>A whitespace character is any character that does not make a blemish on a piece of paper if
  printed out; this includes control characters like bell, NULL, form feed, etc.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseTextSeparator", "Separator Characters");</script>

  <p>MIFF limits what white space characters can be used as separators.</p>

  <p>' ' (space), '\t' (Tab)</p>

  <p>If you see any other whitespace characters used as a separator in the MIFF file then the file
  is not MIFF.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseTextPrintable", "Printable Characters");</script>

  <p>Just to be clear what a printable character is.  If you had a blank piece of paper with just
  one character on it, if the character makes a mark, it is printable.  If it does not make a mark,
  it is not printable (like spaces, control characters, etc.)</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseTextKeyValue", "Key Value Format");</script>

  <p>The text file key value format looks like this.</p>

  <pre>[key] [value header] [value]\n</pre>

  <p>There can be leading separators before the [key] but these will be ignored.</p>

  <p>There has to be at least one separator between [key] and [value header].</p>

  <p>There has to be at least one separator between [value header] and the [value].</p>

  <p>Any extra separators in the line will be ignored.</p>

  <p>To terminate the key value pair use a single '\n' character.</p>

  <p>To be clear...</p>

  <p><strong>Valid:</strong> spaces and tabs can be used to indent and separate the parts.</p>

  <pre>\t\t[key]\t[value header]\t\t\t[value]\n</pre>

  <p><strong>Invalid:</strong>Absolutely no "\n" anywhere before or within the key value line*.  
  '\n' characters indicate a termination of a kv block so any extra '\n' characters will cause 
  problems.</p>

  <pre>
\n\n\n[key]\n[value header]\n[value]\n
 \n[key] [value header] [value]\n
</pre>

  <p>* There are cases where the [value] will be broken up by '\n' characters but this will be 
  indicated below.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseTextValueHeader", "Value Header");</script>

  <p>As defined above the value header is as follows</p>

  <pre>
[type flag][array and encoding flag] [array count] [compressed size]
</pre>

  <p>[type flag] and [array and encoding flag] is a string of 2 or 3 characters.</p>

  <p>If just the 2 letter [type flag] then the value is in readable UTF8 encoding.</p>
  <p>If combined with 'A' [array and encoding flag] then the value is an array of the given type.</p>
  <p>If combined with 'e' or 'E' then the value is treated as binary, reordered to be Big Endian and
  encoded into a string using base64.</p>
  <p>If combined with 'z' or 'Z' then the value is treated as binary, reordered to be Big Endian,
  compressed using zlib, and encoded into a string using base64.</p>

  <p>[array count] will be an unsigned integer value in readable UTF8 indicating how many values in
  the array.  Only present when A, E, and Z are used.</p>

  <p>[compressed size] will be an unsigned integer value in readable UTF8 indicating the raw, in 
  memory byte count of the compressed data.  Only present when z and Z are used.</p>

  <p>Examples: (adding \n to indicate the necessity of this line.)</p>

  <pre>
image g3z 64 64 [base64 zip compressed byte stream]\n

count n1 128\n

string ""t This is a string.\nThis is really a multiline string!\n

pointList PR 5 10.5 20 0 20.5 20 0 20.5 50 0 10.5 50 0 10.5 20 0\n
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseTextValue", "Value");</script>

  <p>Some of the types are a bit more complex so they will have a specific representation in the 
  text file.</p>
  
  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseTextValueBasic", "a*, a*, c*, C*, d*, i*, m*, M*, n*, p*, P*, r*");</script>

  <p>Types az, ad, Ad, A%, A/, c3, c4, C3, C4, dd, d%, d/, i1, i2, i4, i8, mr, mR, Mr, MR, n1, n2, 
  n4, n8, pi, pI, pn, pN, pr, pR, Pi, PI, Pn, PN, Pr, PR, r4, r8 are all very simple in 
  representation.  With no encoding flag...</p>

  <table>
   <tr> <th>Type Code</th>                                                  <th>Representation (No encoding flag)</th></tr>
   <tr> <td>i1, i2, i4, i8, n1, n2, n4, n8, r4, r8, az, ad, dd, d%, d/</td> <td>1 UTF8 readable number</td> </tr>
   <tr> <td>pr, pR, pi, pI, pn, pN, Ad, A%, A/                        </td> <td>2 UTF8 readable numbers separated by at least one separator.</td> </tr>
   <tr> <td>Pr, PR, Pi, PI, Pn, PN, c3, C3                            </td> <td>3 UTF8 readable numbers separated by at least one separator.</td> </tr>
   <tr> <td>mr, mR                                                    </td> <td>9 UTF8 readable numbers separated by at least one separator.  Columns written out left to right before moving to the next row.  Rows written out top to bottom.</td> </tr>
   <tr> <td>Mr, MR                                                    </td> <td>16 UTF8 readable numbers separated by at least one separator.  Columns written out left to right before moving to the next row.  Rows written out top to bottom.</td> </tr>
   <tr> <td>c4, C4                                                    </td> <td>4 UTF8 readable numbers separated by at least one separator.</td> </tr>
  </table>

  <p>If using 'A' array flag the above is repeated as many times as there are array elements.  Each
  array element will be separated by at least one separator.</p>

  <table>
   <tr> <th>Type Code</th>                                                  <th>Representation (e encoding flag)</th></tr>
   <tr> <td>i1, i2, i4, i8, n1, n2, n4, n8, r4, r8, az, ad, dd, d%, d/</td> <td>Values are converted to Big Endian, then encoded into a string using base64.</td> </tr>
   <tr> <td>pr, pR, pi, pI, pn, pN, Ad, A%, A/                        </td> <td>Values are converted to Big Endian, then encoded into a string using base64.  No separation of the 2 numbers.</td> </tr>
   <tr> <td>Pr, PR, Pi, PI, Pn, PN, c3, C3                            </td> <td>Values are converted to Big Endian, then encoded into a string using base64.  No separation of the 3 numbers.</td> </tr>
   <tr> <td>mr, mR                                                    </td> <td>Values are converted to Big Endian, then encoded into a string using base64.  No separation of the 9 numbers.  Columns written out left to right before moving to the next row.  Rows written out top to bottom.</td> </tr>
   <tr> <td>Mr, MR                                                    </td> <td>Values are converted to Big Endian, then encoded into a string using base64.  No separation of the 16 numbers.  Columns written out left to right before moving to the next row.  Rows written out top to bottom.</td> </tr>
   <tr> <td>c4, C4                                                    </td> <td>Values are converted to Big Endian, then encoded into a string using base64.  No separation of the 4 numbers.</td> </tr>
  </table>
  
  <p>If using 'E' array flag the values are encoded into base64 all together and not separated by 
  any spaces.</p>
  
  <p>If using 'z' or 'Z' encoding flag, take the 'e' or 'E' data buffer, compress it using zlib and
  then write out the base64 string representation of the compressed buffer.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseTextValueBool", "bo");</script>

  <p>Boolean data is a little different than the basic types above.</p>
  
  <p>No encoding flag, the value will be 't' for true, or 'f' for false.</p>
  
  <p>'A' encoding flag, the value will be a string of 't' or 'f' letters with no separator in between
  to save some space.</p>
  
  <p>'E' encoding flag will mean the flags are encoded in to a bit map where...</p>

  <pre>
Byte 0                            Byte 1
+---+---+---+---+---+---+---+---+ +---  ...
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | | 8
+---+---+---+---+---+---+---+---+ +--- ...
 2^7 2^6 ...                 2^0   2^8 ...                   
</pre>
  <p>
   0, 1, 2, ... indicates the index into the array and how it relates to the bytes.  So each bit 
   will either be 1 (true) or 0 (false).  This byte stream then gets converted to base64.
  </p>
  
  <p>'Z' will take the above bitmap and compress it first before encoding it with base64.</p>
  
  <p>'e' and 'z' encoding flags are never used with this type.</p>
  
  <pre>
IsFaceVisible bo t\n
IsOptimized bo f\n
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseTextValueKeyValue", "Key Value Block");</script>

  <p>Key value blocks are special.  They are needed to allow nesting of key values.  The last line
  of a block needs to be a comletely empty line with nothing on it but a \n to indicate that the
  block is terminated.</p>

  <pre>
docInfo kv\n
 title  "" M.I.F.F.: Mining Interchange File Format\n
 author "" Robbert de Groot\n
\n
</pre>

  <p>To be clear on how it works.  Leading separators before the key are unnecessary and are only 
  here for clarity.  Leading separators before a \n are allowed but are wasteful.</p>

  <pre>
level1 kv\n
 level2 kv\n
  level3 kv\n
   ...
  \n
  anotherLevel3 kv\n
  \n
 \n
 anotherLevel2 kv\n
 \n
\n
anotherLevel1 kv\n
...
\n
</pre>

  <p>Key value bocks can have an 'A' array specifier and a array count.  This is useful for an array
  of a complex type.</p>

  <pre>
itemList kvA 2\n
 item kv\n
  name ""t item A\n
  value i4t 0\n
 \n
 item kv\n
  name ""t item B\n
  value i4t 10\n
 \n
\n
</pre>

  <p>e, E, z, and Z are never used with kv.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseTextValueString", "\"\"");</script>

  <p>String values are sort of the odd one out with all the other data types.  The other data types
  have a known size based on their input while strings are variable in size.  So encoding them will
  be slightly different.</p>
  
  <p>No encoding flag, all strings will have their cursor return and line feed characters replaced 
  with \r and \n respectively when written to the file.  If your string already has a \r and \n 
  inside then the slash will be escaped, \\r and \\n respectively, so that they do not get converted
  when reading them back in.  Other slash character pairs will not need escaping.</p>
  
  <p>Even though \n is strictly followed for the text format, we convert \r as well because text
  editors will attempt to honor \r or complain about inconsistent line endings and mess things up.</p>
  
  <p>Strings are placed on one line even if they define a multi-line string.  With the above 
  replacement of cursor return and line feeds this can be done.</p>
  
  <p>Unlike other data types, there can only be 1 separator between the value header and the start
  of the first string.  If there exists more than one separator then the extra separators are part
  of the string.</p>
  
  <p>'A' array flag, the individual strings will reside on their own line.  Meaning, as soon as a
  string is finished '\n' will immediately follow.  There will be as many lines as there are array
  elements.</p>

  <p>For an array of strings, the first character of the the next line will be the start of the 
  first string in the array.  The line after that will be the second string.  No lines will have any
  leading spaces.  Any space visible is part of the string.</p>

  <p>'e' encoding, the string is converted to base64 directly without any \r and \n modifications.</p>
  
  <p>'z' encoding, the string is compressed first before converting to base64.</p>
  
  <p>'E' and 'Z' encoding, unlike 'A', the string array is treated as one big buffer separated by
  NULL values and then compressed and converted to base64.</p>

  <pre>
string "" This is a single string value.\nBut multiline. Only \\r and \\n need escaping and not other \s in the string\n

stringList ""A 3\n
This is string 1, line 1.\\r\\nThis is line 2.\\r\\n\n
This is string 2.\n
This is string 3.\n

stringList ""e 7342jlafnpi23uq9==

stringList ""Z afkj8u234123234dfjaee...
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseTextValueGraphic", "g3, g4, G3, G4");</script>

  <p>These graphic options will have a header of 2 unsigned integer values before the image data.
  These values indicate width and height of the graphic.  These values are not included in the
  Base64 or Zlib compression if compression is used.  However the image data will honor Base64 or
  Zlib compression if used.</p>
  
  <p>Images are written out row by row, left to right, top to bottom.</p>
  
  <p>Array of graphics will place each graphic on a separate line similar to string encoding.</p>

  <pre>
image g3t 2 2 0 0 0 64 64 64 128 128 128 192 192 192\n

image g3T 2\n
2 2 0 0 0 64 64 64 128 128 128 192 192 192\n
2 2 64 64 64 128 128 128 192 192 192 255 255 255\n
</pre>

  <p>
   <strong>gp, gj, gJ</strong>
  </p>

  <p>
   For gp, gj, and gJ, the file that represents the image is copied verbatum into the value
   portion.  There is never any compression applied.  The data is always base64 encoded.  e, E, z,
   and Z are never used.
  </p>

  <pre>
imageFile gpt [base64 encoding of a png file data]\n

imageFileList gpT 2\n
[base64 encoding of a png file 1 data]\n
[base64 encoding of a png file 2 data]\n
</pre>

  <p>
   <strong>gl</strong>
  </p>

  <p>
   For gl, there will be a path to an image.  This path should really be relative to the MIFF file
   so that finding this file is easy.  However this is up to the software writing the MIFF file.
   e, E, z, and Z are never used for this type.
  </p>

  <pre>
imageFileLink glt \path\to\image\file\image.png\n

imageFileLinkList glT 2\n
\path\to\image\file\image1.png\n
\path\to\image\file\image2.png\n
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseTextValueBinary", "Binary Encoding");</script>

  <p>
   The binary data will have a header of 1 unsigned integer value before the binary data.  This
   value indicates the byte count of the binary data.  This byte count is not included when using
   Base64 ro Zlib compression.  However the binary data will honor Base64 and Zlib compression if
   used.
  </p>

  <pre>
image bnt 10 0 1 2 3 4 5 7 8 9\n

image bnT 2\n
10 0 1 2 3 4 5 6 7 8 9\n
10 9 8 7 6 5 4 3 2 1 0\n
</pre>

  <p>
   Binary blobs are dangerous and should be used rarely if at all.  If someone uses them then they
   should be on the hook to define what the contents of the blob mean.  If they do not, then they
   are being bad citizens and should be shamed!
  </p>
  <p>
   However this is here as a catchall just in case.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formatBaseBin", "Binary");</script>

  <p>
   The Binary file will to match the Text file 1-1.  Everything within '[]' is a byte sequence of
   a known size.  Each byte seqence is separated here with a comma but is immediately following
   after previous byte sequence.
  </p>
  <p>
   A byte sequence is [[size]:[name]], where size is a number indicating the number of bytes this
   sequence takes up.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseBinKeyValue", "Key Value Format");</script>

  <pre>
[1:key string length],[key string length:key],[3:value header],[4;array count],[4:compress buffer size],[*:value]
</pre>

  <p>
   [key string length] is the first byte sequence and defines how long the key string is in bytes.
  </p>
  <p>
   [key] is the second byte sequence and defines the key of the key value pair.  The length of
   which was defined by [key string lenght] above.  This means keys can not exceed 255 bytes.
   No null terminator for the key.
  </p>
  <p>
   [value header] is the third byte sequence and is 3 bytes following the [array and encoding flag]
   as defined in the Text section above.
  </p>
  <p>
   t, T, e, and E are all the same in binary mode.  The data is stored raw and no encoding is
   actually done.  z and Z will apply Zlib compression to the binary data.
  </p>
  <p>
   [array count] and [compress buffer size] are only present when certain value header conditions
   are present.  Meaning [array count] byte sequence is only present when the value is an array of
   values; [compress buffer size] is only present when the value is being compressed with zlib
   compression routines.  If neither of these are present in the value header then these byte
   sequences are not present.
  </p>
  <p>
   Both [array count] and [compress buffer size] are 4 byte unsigned integers stored in network
   order.
  </p>
  <p>
   [value] field will vary wildly depending on the [value header], [array count], and [compress
   buffer size] values.  But it will be a known size given that information.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseBinValue", "Value");</script>

  <pre>
[value] 
Type                                              Byte Count
---------------------------------------           ---------------------------
=                                                 See Key Value Block below.
""                                                See String Encoding below.
i1, n1                                              1 
i2, n2                                              2
c3, tt                                              3
c4, i4, n4, r4, az, ad, dd, d%, d/, td              4
t*                                                  7
i8, n8, r8, pr, pi, pn, Ad, A%, A/                  8
c4, Pr, Pi, Pn                                     12
pR, pI, pN                                         16
PR, PI, PN                                         24
C4                                                 32
mr                                                 36
Mr                                                 64
mR                                                 72
MR                                                128
g3, g4, G3, G4                                    See Graphic Encoding below.
bn                                                See Binary Encoding below.
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseBinValueKeyValue", "Key Value Block");</script>

  <p>
   This indicates the start of a block.  There technically is not value.  The next byte after the
   [value header] is the start of the first key in the block.
  </p>
  <p>
   A block is terminated when the [key string length] is equal to 0.
  </p>

  <pre>
[8],["itemList"],["=   "],
[> 0 key string length],...
[> 0 key string length],...
[> 0 key string length],...
[0]
</pre>

  <p>
   Hopefully the above explains it.  I have defined an "itemList" key which starts the key value
   block.  If the next key value has a key string length that is > 0 then it is part of the
   itemList key value block.  The last key string length is 0 which indicates that the block is
   done.  Anything that follows the block is a new key value thing.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseBinValueString", "String Encoding");</script>

  <p>
   String encoding is simpler than in the text case.
  </p>

  <pre>
[4:string length][string length:string]
</pre>

  <p>
   Each string is prefixed with a [string length], the byte count of the UTF8 string.  Then you
   just dump out the string in UTF8 format.
  </p>
  <p>
   Array of strings will have as many of these pairs as found in the array.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseBinValueGraphic", "Graphic Encoding");</script>

  <p>
   For g3, g4, G3, and G4 the format is...
  </p>

  <pre>
[4:width][4:height][width * height * size of [c3|c4|C3|C4]:graphic data]
</pre>

  <p>
   Raw graphic data size will be (unsigned integer) width * (unsigned integer) height * size of the
   color item.  It will be the compressed size in the file if compression is used but the raw size
   in memory.
  </p>

  <p>
   For gp, gj, and gJ the format is...
  </p>

  <pre>
[4:image file size][image file size:binary buffer of the image file]
</pre>

  <p>
   For gl the format is...
  </p>

  <pre>
[4:string length][string length:file path]
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseBinValueBinary", "Binary Encoding");</script>

  <p>
   Binary encoding is like string encoding.  We need a byte count before the buffer data.
  </p>

  <pre>
[4:byte count][byte count:buffer data]
</pre>

  <p>
   byte count will never be compressed when compression is used but buffer data will.
  </p>
  <p>
   Array of binaries will have as many of these pairs as found in the array.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formatBaseDesign", "Design Decisions:");</script>

  <p>
   <strong>Why not XML or JSON?</strong><br />
   I did not take XML as a format because it is too verbose.  JSON is very flexible but I also
   find it is still unnecessarily verbose.  Better than XML but still unacceptable in my opinion.
   Considering the data, I do not want a format that would cause too much data bloat.  There will
   always be some bloat happening but it should be mitigated in my opinion.
  </p>

  <p>
   <strong>Why network order for multibyte data types?</strong><br />
   In the past my company was multi-platform, SGI IRIX, SUN OS, SUN Solaris and Windows NT.  At
   that time the architecture on some of the other platforms was Big Endian and we stored the data
   in the native format of the machine.  However this lead to issues when users moved their data
   over to a Little Endian machine which Windows has always been.  The problems that we faced were
   trivial to solve but just very annoying and yet anothering thing to remember.  So standardizing
   on one option is easier than having to support two options.  I go with simplicity, only one
   option to rule them all!  It keeps things simpler.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "formatMine", "MIFF Format: Mining");</script>

  <p>
   The above section defines how the data is stored in the format.  But it does not address the
   meat of the mining data.  In actuality, the above is agnostic with regards to data to be stored.
   It could be used for game information of anything else for that matter.
  </p>
  <p>
   From now on we will concenttrate on actual Mining field related data.
  </p>

  <p>
   The various data that mining companies need to keep track of and transfer around.
  </p>

  <ul>
   <li>
    Geometry
    <ul>
     <li>
      3D
      <ul>
       <li>Points</li>
       <li>Polylines (open and closed)</li>
       <li>Surfaces:Generic (open and closed (solids))</li>
       <li>Surfaces:Grid</li>
       <li>Text</li>
       <li>Symbol</li>
      </ul>
     </li>
     <li>
      2D (Planar, Fence)
      <ul>
       <li>Points</li>
       <li>Polylines (open and closed)</li>
       <li>Text</li>
       <li>Symbol</li>
      </ul>
     </li>
    </ul>
   </li>
   <li>
    Drillhole
    <ul>
     <li>Drillhole survery information.</li>
     <li>Drillhole assay information.</li>
     <li>Drillhole composite information.</li>
     <li>Blast hole shot information.</li>
     <li>Chip assay information.</li>
     <li>Design vs surveyed information.</li>
    </ul>
   </li>
   <li>
    Model
    <ul>
     <li>
      Block model information.
      <ul>
       <li>Regular</li>
       <li>Sub-blocked</li>
       <li>Seam</li>
      </ul>
     </li>
     <li>
      Seam model information.
      <ul>
       <li>Regular</li>
       <li>Sub-blocked</li>
      </ul>
     </li>
     <li>
      Surface model information.
      <ul>
       <li>Regular</li>
       <li>Sub-blocked</li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>

  <p>
   MIFF will handle all these types of data.  However, how each is actually stored in MIFF can vary.
  </p>
  <p>
   File naming can help in MIFF file importing.  It is suggested to use the following file extensions...
  </p>
  <ul>
   <li>*.miff - Still valid but can be anything.  What is it?</li>
   <li>*.miffGeom - for Geometry data.</li>
   <li>*.miffDrill - for Drillhole data.</li>
   <li>*.miffModel - for Model data.</li>
  </ul>
  <p>
   This information is duplicated inside the file so reading in the file will confirm with the extension
   but it will help the user if the extension is properly set.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formatMineInfo", "Information Block");</script>

  <p>
   Common to all MIFF Mining Formats for any of the types above, there will be an information block
   providing general, data wide information.
  </p>
  <p>
   This information block will be the very first key value in the file right after the MIFF header.
  </p>

  <pre>
MIFF   1TXT\n
info kv\n
...
\n
</pre>

  <p>
   Inside the information block we have the following possible key values.  Not all are required.
  </p>

  <pre>
type ""t [file type]
company ""t [company name]
copyright ""t [copyright if any]
author ""t [client employee name]
dateCreated t* [date created]
dateModified t* [date modified]
comment ""t [comments]
software ""t [software preparing this file]
softwareVersion ""t [software version]
...
</pre>

  <p>
   [file type] is one of...
  </p>
  <ul>
   <li>Drillhole</li>
   <li>Geometry</li>
   <li>Model</li>
   <li>...</li>
  </ul>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "formatMineModel", "MIFF Format: Mining: Model");</script>

  <p>
   Some of the information found here is based off of the block model formats that are used at
   Hexagon, where I work, but also from information found freely on the internet.  Particularly this
   link from Deskwik which is a well written overview of some of the subblocking types by the
   various software vendors.
  </p>

  <p>
   <a href="https://www.deswik.com/wp-content/uploads/2019/01/Block-model-knowledge-for-mining-engineers-An-introduction-1.pdf">Block Model Knowledge For Mining Engineers - An Introduction</a>
  </p>

  <p>
   There are 3 basic model formats that are in use as Hexagon.
  </p>

  <ul>
   <li>Block Model</li>
   <li>Seam Model</li>
   <li>Surface Model</li>
  </ul>

  <p>
   Block Model is a regular collection of, usually, uniform blocks.  Each block will have values
   for what ever it is that is being tracked by the client.
  </p>
  <p>
   Seam Model is a bit fancier Block Model.  This model is subdivided uniformly in the east and
   north directions of the model but instead of levels, seams are described.  Each block in a seam
   will have an elevation top and bottom to indicate the seam's limits, as well as any other values
   that are found within that seam block just like a normal block model.
  </p>
  <p>
   Surface Model is much more limited than the other two as it just holds a stack of surfaces
   instead of defining any volume.  This model is subdivided uniformly in the east and north
   directions of the model but instead of seams you will have a surface.  Each 'block', or really
   the contact point, for a surface will have an elevation value as well as other values that are
   being tracked by the client at that surface point.
  </p>
  <p>
   Even though only Block Models are sub-blocked, MIFF does not limit you to only allowing
   sub-blocks for Block Models.  The logic could be applied to the other two types of models.  As
   far as I know, no software vendors sub-block for Seam or Surface Models.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formatMineModelInfo", "Information Block: Model");</script>

  <p>
   After the general information block the next block will be the Model Information block.
  </p>

  <pre>
infoModel kv
 type ""t [model type]
 isSubblocked bot [true if subblocked]
 subblockType ""t [subblock type]
 subblockOption Pn [subblock fixed resolution]
 subblockOption pn [subblock row col resolution]
 subblockOption n1 [subblock octtree level count]
 origin PRt  [origin point]
 colVec PRt  [column vector, length if vector is the length of the block] 
 rowVec PRt  [row vector, length of the vector is the length of the block]
 levVec PRt  [level vector, length of the vector id the length of the block] 
 blockCount Pnt [number of column, row, level blocks]
 isLevVariable bot [true if variable level heights]
 levList r4at [number of levels] [length] [length] ...
 itemList kv [item list count]
  item kv 
   id ""t [item id]
   nameLong ""t [item name]
   nameShort ""t [item name short]
   type tyt [item type]
   min r4t [item min value]
   max r4t [item max value]
   precision r4t [item precision]
   enumList ""ta [enum count] 
   default [type][encoding] [default value for this item]
   calculation ""t [calculation field value]
...
\n
...
\n
\n
\n
</pre>

  <p>
   <strong>[model type]</strong> will be one of...
  </p>
  <ul>
   <li>block - For a block model.</li>
   <li>seam - For a seam model.</li>
   <li>surface - For a surface model.</li>
  </ul>

  <p>
   <strong>[subblock type]</strong> will be one of...
  </p>
  <ul>
   <li>
    <p>fixed - For a regular division of the block in the east, north, and z directions of the block.</p>
    <pre>
Using just a cross section.
+--+--+--+--+
|  |  |  |  | <--- Each sub-block of the parent block is of uniform size.
+--+--+--+--+
|  |  |  |  |
+--+--+--+--+
|  |  |  |  |
+--+--+--+--+
</pre>
   </li>
   <li>
    <p>semi - For a regular division of a block in the east and north directions but an infinitely variable z value for block height.</p>
    <pre>
+--+--+--+--+
|  +--+  |  |
|  |  +--+  |
|  +--+  |  | Infinitely variable in the level direction.
+--+  |  |  |
+--+--+--+--+
Uniform divisions in the row and column directions.
</pre>
   </li>
   <li>
    <p>octree - For an oct-tree subvision of a block.</p>
    <pre>
+-----+-----+
|     |     |
+--+--+-----+  Recursive bisecting the blocks until a limit.
+--+--+     |
+--+--+-----+
</pre>
   </li>
   <li>
    <p>free - For a free subdivision of a block where each subblock is individually defined as being some subvolume of the parent.</p>
    <pre>
+-----------+
|    +----+ |
|    |    | |
|    +----+ | Bad diagram but essentially possible with this option.  This is a catchall case for
+--+        | those types of subblocking I have not addressed.
|  |        |
+--+--------+
</pre>
   </li>
  </ul>

  <p>
   Depending on what is set for [subblock type] there will be one of 3 [subblockOption] values.
  </p>
  <ul>
   <li>fixed subblocking requires a Pn to define the number of divisions in the east, north and z directions.</li>
   <li>semiFixed subblocking requires a pn to define the number of divisions in the east and north directions.</li>
   <li>octree subblocking requires a n1 to define the max number of oct-tree divisions that can occur for a block.</li>
   <li>free subblocking does not require an option.</li>
  </ul>

  <pre>
       \   /
        \ /
         +  Column 1
        / \
 Row 1 /   \   /
      /     \ /
     /Lev 0  +
\   / Row 0 /|
 \ /  Col 0/ |
  +       / <----- colVec (Length is block size. Direction is direction of increasing column index.)
  |\     /   |/
  | \ <----------- rowVec (Length is block size. Direction is direction of increasing row index.)
\ |  \ /    /|
 \|   o <--------- origin (3D point indicating the outter most corner of the first block.)
  +   |   /
  |\  | <--------- levVec (Length can be block size or unit, depends see below. Direction is direction of increasing level index.)
  | \ | /
     \|/
      +
      | Level 1
      |
</pre>

  <p>
   <strong>origin</strong> - The extreme most point of the first column, first row, and first level
   block of the model.
  </p>
  <p>
   <strong>colVec, rowVec, levVec</strong> - The direction vectors of increasing block index for the
   column, row, and level directions.  The length of this vector is the size of the block in the
   column, row and level directions.  levVec does not need to be sized if the level height is variable.
   It should at least be unit length.  All vectors need not be perpendicular to each other but usually
   this is the case in most software.  I believe there is one software where colVec and rowVec are not
   90 degrees to the levVec.  Essentially creating sloped levels.
  </p>
  <p><strong>blockCount</strong> - The number of column, row, and level blocks.</p>
  <p>
   <strong>isLevVariable</strong> - Flag to indicate the level heights are not uniform.  This does not
   need to be present if the levels are a fixed height.
  </p>
  <p>
   <strong>levList</strong> - A list of level heights starting from first level.  Only required if
   isLevVariable is true.
  </p>
  <p>
   <strong>itemList</strong> - A key value block for the list of items stored in each block.  Can be
   using the array notation for this block if item count is known.
  </p>

  <p><strong>item</strong> - A key value block describing the item.</p>
  <p><strong>id</strong> - A short unique string uniquely identifying the item.</p>
  <p><strong>nameLong</strong> - A 'nice' name for the item.</p>
  <p><strong>nameShort</strong> - A 'compact' name for the item.</p>
  <p><strong>type</strong> - What sort of value the item stores.  One of "", r4, r8, n1, n2, n4, n8, i1, i2, i4, i8, en ("en" for enumeration value), +x ("+x" for calculated field)</p>
  <p><strong>min, max</strong> - limits for an item if a number value.</p>
  <p><strong>precision</strong> - The accuracy of the number if type is r4 or r8.</p>
  <p><strong>enumList</strong> - Required only for "en" type.  This lists the enumeration values available in a string list.</p>
  <p><strong>default</strong> - default value for this item if block is skipped.</p>
  <p>
   <strong>calculation</strong> - a formula that is used to calculate the contents of this value.
   Use $[item id] in the formula to refer to another item value in the current block.  Full discussion
   about the formula composition will be discussed elsewhere.
  </p>
  <pre>
Calculation example:
($ore% * $cu) - $i_am_making_something_up
</pre>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formatMineModel", "Model Block:");</script>

  <p>
   This is where the model data is placed.  The format is slightly different in that it is a key value list but without value headers and potentially
   optional values depending on the key.
  </p>

  <pre>
model vst\n
...
\n
</pre>

  <p>
   The model data will be enclosed in a value stream chunk.  This stream can be in t, e, or z encodings.  The contents are broken down in key, or key and value
   pairs.
  </p>

  <pre>
Key (1 byte) Value
------------ -----
B            n2 value follows immeadiately.  Jump to current level index + N.  Reset current row and current column to 0
b            No value.  Jump to next level.
R            n2 value follows immeadiately.  Jump to current row index + N.  Reset currrent column to 0
r            No value.  Jump to next row.
C            n2 value follows immeadiately.  Jump to current column index + N.
c            No value.  Jump to next column.
s            Defining subblock.  See subblocking information below to deal with the various subblock types.
V            For the current block or subblock, provide all values for the items defined in the infoModel section in the order they appear in the infoModel (not including calculated items),
             each value separated by a \n in text mode.  In Binary mode values are using as many bytes as necessary as defined by the items. 
             Increment the column or subblock column (if applicable).  
             (If applicable) If this is the last column or subblock column, column restarts at the first column, increment the row.
             (If applicable) If this is the last row or subblock row, row restarts at the first row, increment the level.
             (If applicable) If this is the last subblock level, move to the next parent block following these rules.
             If this is the last block and last subblock block, there should not be anything else in the value stream.  
v            No value.  Copy the last blocks values to the current block.  Increment to the next block.
.            No value.  Indicates end of the subblock data or value stream.
</pre>

  <p>
   The above may not make that much sense yet so here is an example of a 5x5 block model where we have 3 r4 values per block.
  </p>

  <pre>
File                   What is happening
--------------------   -----------------
model vst\n            Start of the model data value stream.  Current block is 0 (first) level, 0 (first) row, 0 (column)
B2                     Add 2 to the level index.  Current block jumps to 2, 0, 0.  All blocks on levels 0 and 1 have default values.
R3                     Add 2 to the row index. Curent block jumps to 2, 2, 0.  All blocks on level 2, rows 0 and 1 have default values.
C2                     Add 2 to the column index.  Current block jumps to 2, 2, 2.  Block 2, 2, 0, and Block 2, 2, 1 have default values.
v1.2\n2.3\n3.14\n      Block 2, 2, 2 has values 1.2, 2.3, 3.14.  Current block after this line is 2, 2, 2.
c                      Block 2, 2, 3 get default value.  Current block after this line is 2, 2, 4.
c                      Block 2, 2, 4 get default value.  Current block after this line is 2, 3, 0.  We jumped to the next row
s                      Block 2, 3, 0 is subblocked.  Depending on the subblocking used we start at 0, 0, 0 subblock and used the same B, b, R, r, C, c for 
                       navigating the subblock blocks until we reach the subblock block or a '.' key is reacched.  See below for subblock filling.
S                      Similar to s but parent block has values as well as having subblocks with values.  First v encountered is for the parent block.
                       c to jump to the first subblock block.
...
.                      Current block can be anything, this indicates that the rest of the model blocks not yet reached are set to default values.
</pre>

  <p>
   Note that there are no \n after every key value pairs.  This is to keep the text representation as compact as possible.  In binary the above will look like...
  </p>

  <pre>
[n1:5]["model"],["vst "],["B"],[n2:2],["R"],[n2:2],["C"],[n2:2],["v"],[r4:1.2],[r4:2.3],[r4:3.14],["c"],["c"],["s"]...,["."]
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatMineModelFixed", "SubBlock: Fixed");</script>

  <p>
   In the fixed case of subblocking, as soon as an 's' key is hit, that block is divided into the
   subblocks as defined in the infoModel section. Use B, b, R, r, C, c, and . in the same way as
   for the parent blocks.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatMineModelSemi", "SubBlock: Semi");</script>

  <p>
   In the semi fixed case of subblocking, as soon as an 's' key is hit, that block is divided into
   the subblocks as defined in the infoModel section.  One difference...
  </p>

  <p>
   In this scheme of subblocking, there is an infinite variability in the z direction for each subblock.
   This is defined by an 'H' key for the first level of blocks of the subblocks.  The number of level
   subblocks will depend on how many times H is used for the same column.
  </p>

  <pre>
Key   Value
---   -----
H     r4 value immediately follows.  The r4 value is a percent of the block height.  This record
      needs to preceed a v record. 
h     No value.  The rest of the subblock cylinder is used.
</pre>

  <p>
   If H or h follows an H or h then the previous block will be holding default values, and the current
   block will be incremented to the next subblock.  The following H or h will determin the height of
   the new current block.
  </p>
  <p>
   If a subblock cell has already defined the entire height of the block then these will be skipped
   over when jumping to the next subblock.  This means that some subblock cells could have a different
   number of levels that others.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatMineModelTree", "SubBlock: Octree");</script>

  <p>
   In the octree case, an 's' key will split the block or subblock in to 8 uniform pieces.  If we
   are already at a subblock then that subblock will be split into small 8 uniform pieces.  This
   should not exceed the subblock option count defined in the model information block.
  </p>

  <p>
   The 's' key need to preceed the v record.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatMineModelFree", "SubBlock: Free");</script>

  <p>
   In the free block case, an 's' key will indicate the parent block is subblocked.  However after
   that you will need to define the blocks manually.
  </p>

  <pre>
Key   Value
---   -----
c     6 x r4 values follow.  First 3 r4 values are percents for the min point and the second 3 r4 
      values are percents for the max point of the subblock.
.     Indicates we are done with the subblocking and to process to the next parent block.
</pre>



  <script>UpdateToc();</script>

 </body>
</html>
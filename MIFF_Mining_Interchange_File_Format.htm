<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href="style_reset.css">
  <link rel="stylesheet" type="text/css" href="style.css">
  <title>M.I.F.F.: Mixed Information File Format</title>

  <!-- Script for generation a table of contents -->
  <script>
const indexLEVEL     = 0;
const indexTAG       = 1;
const indexTITLE     = 2;
const indexHAS_TYPE  = 3;
const indexHAS_CONST = 4;
const indexHAS_FUNC  = 5;
const indexCOUNT     = 6;

var tocIndex = 0;
var toc      = [];

// Display a header line and add to the table of contents (TOC)
function HeaderAdd(level, tag, title)
{
   var record = [];
   
   record[indexLEVEL]     = level;
   record[indexTAG]       = tag;
   record[indexTITLE]     = title;
   record[indexHAS_TYPE]  = false;
   record[indexHAS_CONST] = false;
   record[indexHAS_FUNC]  = false;

   toc.push(record);

   // Chrome complains about this document write.  I have looked for an alternative but everything
   // I have found is utter rubbish.  HeaderAdd is only called on doc load.  This call is not a
   // problem.
   document.write("<h" + level + "><a name=\"" + tag + "\">" + title + "</a></h" + level + ">\n\n");
}

function HeaderAddType()
{
   var record = toc[toc.length - 1];

   record[indexHAS_TYPE] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Type\">Type</a></h2>\n\n");
}

function HeaderAddConst()
{
   var record = toc[toc.length - 1];

   record[indexHAS_CONST] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Const\">Constant</a></h2>\n\n");
}

function HeaderAddFunc()
{
   var record = toc[toc.length - 1];

   record[indexHAS_FUNC] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Func\">Function</a></h2>\n\n");
}

// Update the TOC with all the header lines.
function UpdateToc()
{
   var value;
   var record;
   var index;

   value = "<table>\n";

   for (; tocIndex < toc.length; tocIndex++)
   {
      record     = toc[tocIndex];
    
      value += "<tr>\n<td>";
    
      // Indenting
      for (index = 1; index < record[0]; index++)
      {
         value += "&nbsp;&nbsp;&nbsp;&nbsp;";
      }

      value += "<a href=\"#" + record[1] + "\">" + record[2] + "</a></td>\n";
      
      value += "<td>";
      if (record[indexHAS_TYPE] == 1)
      {
         value += "<a href=\"#" + record[1] + "Type\">Type</a>\n";
      }
      value += "</td>\n";
      
      value += "<td>";
      if (record[indexHAS_CONST] == 1)
      {
         value += "<a href=\"#" + record[1] + "Const\">Constant</a>\n";
      }
      value += "</td>\n";

      value += "<td>";
      if (record[indexHAS_FUNC] == 1)
      {
         value += "<a href=\"#" + record[1] + "Func\">Function</a>\n";
      }
      value += "</td>\n";

      value += "</td>\n";
   }

   value += "</table>\n";

   document.getElementById("toc").innerHTML = value;
}
  </script>
 </head>
 <body>
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <h1 class="page">M.I.F.F.: Mixed Information File Format</h1>

  <table>
   <tr>
    <td><p>Author:</p></td>
    <td>Robbert de Groot</td>
   </tr>
   <tr>
    <td><p>Date:</p></td>
    <td>2019-05-15</td>
   </tr>
   <tr>
    <td><p>Copyright:</p></td>
    <td>2019, Robbert de Groot</td>
   </tr>
   <tr>
    <td><p>License:</p></td>
    <td>The library will be MIT License.</td>
   </tr>
   <tr>
    <td></td>
    <td>
     This document is licensed under Creative Commons Attribution-NoDerivs. <a href="https://creativecommons.org/licenses/by-nd/4.0/">
      (CC BY-ND)
     </a>
    </td>
   </tr>
  </table>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <h2>Table Of Contents:</h2>

  <p id="toc"></p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "miff", "M.I.F.F.");</script>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "about", "Discussion");</script>
  <p>
   What is the purpose of M.I.F.F.? (MIFF from now on.)  MIFF is intended to be a file format for
   exporting and importing data from one software package to another software package.
  </p>
  <p>
   Users of software packages are becoming increasingly annoyed at the lack of interoperability
   between software packages.  Currently each software package attempts to do its best at
   supporting competitor file formats but there is often a lot of loss of data or, as data formats
   in each package evolves, suffer from compatibility issues.  Often data needs to be dumped to
   formats that come 'close' but are not exact or down to very basic, raw ASCII files, like csv
   files, which are often lacking compared to the original data.  Users will need to massage this
   raw data in order to import it into their target software package.
  </p>
  <p>
   A lot of the client's time is lost with all this work.  The idea with an interchange format is
   to remove some of the pain of this data transfer task and put more of the pain on the software
   vendors of doing the hard part of reading in the data to their expectations.  The software users
   will not need to know some of the intricacies of the data or task.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "goals", "Goals");</script>

  <p>
   The main goal of this format is to be specifically an interchange format.  It is not intended
   to be a native format for any software package.  The focus is to make it easy for the developers
   from any software package to export their data to this interchange format and, without too much
   difficulty, to import other vendor's data.
  </p>
  <p>
   For the users of the software packages, the process of moving data from package to package will
   be much easier, less time consuming, and less problematic as they will only have to export and
   import to just one type of file instead of various file formats and more intimate knowledge of
   the data transfer process specific to their software packages.
  </p>

  <ul>
   <li>
    <strong>Simple</strong>.  The format should be simple for the developers to export their data.  Import may still
    be challenging because of the differences between software packages but the format to import
    the data should not impose too much pain for the developers either.  The simplicity should go a
    long way in getting the format adopted and implemented.
   </li>
   <li>
    <strong>Inclusive</strong>.  All data from all venders should be representable with the least amount of
    compromizes in the data being exported.
   </li>
   <li>
    <strong>Brief</strong>.  The format should not produce unnecessary waste.  The data in some cases will be quite
    large so it should not bloat the data too much.  Meaning, file sizes should not become overly
    large.  However, because of point 1 there will always be some bloat.
   </li>
   <li>
    <strong>Flexible</strong>.  The format needs to be able to accomodate change or vendor specific data.  A few
    software vendors started life in the 70's with time shared machines.  Over the years the amount
    of data and the types of data the clients want to maintain has changed and grown.  A format
    needs to try its best to keep up without importers and exporters to be completely remade.
   </li>
  </ul>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "disclosure", "Disclosure");</script>

  <p>
   As of this writing I, Robbert de Groot, am a Principal Software Developer with Hexagon
   (previously known as (pka) Hexagon Mining, pka MineSight, pka Mintec Inc.), the current owners
   of MinePlan 3D software (pka MineSight 3D; pka MEDSystem.); Leica Geosystems, the makers of
   survey equipment and related material; as well as other mine related hardware and software
   products.
  </p>
  <p>
   This format is currently not sanctioned by any software vendor or even by Hexagon.  This was
   something spurned by recent efforts being made by Global Mining Guidelines (GMG), with Open
   Mining Format (OMF), which seems to have the backing of some big players in the industry.  My
   issue with OMF for now is that they only have a Python library that implements the format
   available publically.  They may have a specification document somewhere but currently it is not
   available, or at least I cannot find it anywhere in the 'open'.  Plus this format seems to be
   strictly binary, which is not entirely a bad idea considering the data that needs to be passed
   around, but binary formats can be very fussy.  And inspecting their sample OMF file, it does not
   look like something that is easily reverse engineered.
  </p>
  <p>
   Having said that, I thought I would try my hand at defining a format what I think would be good
   as an interchange format.  I am trying to write MIFF independent of any software package.
   However there may be some unintended bias as I am most familiar with MinePlan 3D I have worked
   on.  I do intend to include other software package requirements as best as I understand them.
  </p>
  <p>
   If anyone is interested in educating me on some features they would like to see with respect
   to their software package of choice I would love to hear from you.  You can reach me at these
   two email addresses.
  </p>
  <p>
   robbert.degroot@hexagon.com<br />
   zekaric@gmail.com
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "formatBase", "MIFF Format: Base");</script>

  <p>
   There are two representations of the format.  A Text file and a Binary file representation.
   They will both contain exactly the same data and be exactly the same in feature set.  The Binary
   file may just have the advantage of being slightly more accurate, possibly slightly more compact
   and possibly slightly faster.
  </p>
  <p>
   At the low level, a MIFF format is just a collection of key value pairs.  Values can be a
   collection of further key value pairs.  Meaning nesting can be possible.
  </p>
  <p>
   The intent on reading these files is to make just one pass over them; twice at most, but for
   the most part, one pass over the contents should be enough to read in the data.  So there is
   not a focus on making the file random accessable or rewindable.  This format is not intended as
   a substitute for native formats for any software package.
  </p>
  <p>
   Common to both styles, any mutlibyte data that is encode or stored as a binary byte sequence
   will be in network (big endian) order.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "header", "File Header");</script>

  <p>
   There will always be a file header so that you can be sure the file you recieved is actually a
   MIFF file and not some other file.
  </p>

  <pre>
"MIFF   1TXT\n"

or 

"MIFF   1BIN\n"
</pre>

  <p>
   "MIFF" indicates the base file format type.
  </p>

  <p>
   "&nbsp;&nbsp;&nbsp;1" indicates the base file format version.  Currently at version 1.  This
   will only use whole numbers instead of the usual XX.XX.XX.XX versioning of software.
  </p>

  <p>
   "TXT\n" and "BIN\n" indicate the content organization.  TXT for text, and BIN for binary.  \n
   is a line feed character.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "text", "Text");</script>

  <p>
   The text format is a UTF8 text file.  UTF8 is the 1 byte UNICODE format for text.  The format
   only uses the ASCII characters only (first 128 UNICODE character codes) for the format.  UTF8
   mainly comes into play with the string data being stored.
  </p>
  <p>
   The format is somewhat human readable, or somewhat text editor friendly but it really is not
   meant to be human friendly.  What I mean is that you will be able to look at the format in a
   text editor (if the text editor is capable) and if you know this format to a certain degree, you
   will understand what you are seeing, but the format is not intended to be pretty.
  </p>
  <p>
   The format does not adhere to any line length limit.  So if you are using a text editor that
   does have line length limits you may end up corrupting the file or may not be seeing the whole
   file.
  </p>
  <p>
   All lines are terminated with a UNIX '\n'.  NOT an MSDOS \r\n or a MAC \n\r ending.  This is
   a strict rule.  If the file ahs \r\n or \n\r line endings then it is not a MIFF file.  Shame
   and shun the developer for not adhering to this format's rules.
  </p>
  <p>
   '\r' (Cursor Return) should not appear anywhere in the format unless writted explicitely as '\',
   'r'.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "textWhitespace", "Whitespace Characters");</script>
  <p>
   A whitespace character is any character that does not make a blemish on a piece of paper if
   printed out; this includes control characters like bell, NULL, form feed, etc.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "textSeparator", "Separator Characters");</script>
  <p>
   MIFF limits what white space characters can be used as separators of values.
  </p>

  <pre>
' '    '\t'
Space  Tab 
</pre>

  <p>
   If you see any other whitespace characters used as a separator in the MIFF file then the file is
   not MIFF.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "textPrintable", "Printable Characters");</script>
  <p>
   Just to be clear what a printable character is.  If you had a blank piece of paper with just one
   character on it, if the character makes a mark, it is printable.  If it does not make a mark, it
   is not printable (like spaces, control characters, etc.)
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "textKeyValue", "Key Value Format");</script>

  <pre>
[key] [value header] [value]\n
</pre>

  <p>
   There can be leading separators before the key but these will be ignored.
  </p>
  <p>
   There has to be at least one separator between key and value header.
  </p>
  <p>
   There has to be at least one separator between value header and the value.
  </p>
  <p>
   Any extra separators in the line will be ignored.
  </p>
  <p>
   To terminate the key value pair should be a single '\n' character.
  </p>

  <p>
   To be clear...
  </p>

  <pre>
Valid: spaces and tabs can be used to indent and separate parts.
\t\t[key]\t[value header]\t\t\t[value]\n

Invalid: Absolutely no \n anywhere before or within the key value line.  \n characters indicate a 
termination of a kv block.  Discussed later in this document.
\n\n\n[key]\n[value header]\n[value]\n
 \n[key] [value header] [value]\n
</pre>

  <p>
   There are cases where [value] will be on individual lines but this will be indicated below.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "textKey", "Key");</script>

  <p>
   Keys are always a single string of characters and are limited to printable character in the
   first 127 UNICODE code points.  Meaning no whitespace of any kind inside a key.
  </p>

  <pre>
Valid:
12345
;':][.,<>]'
a_b_c
$cost
</pre>

  <p>
   The key can be nonsense or just a number.  As long it does not include any whitespace.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "textValueHeader", "Value Header");</script>

  <p>
   There are quite a few different value types and organizations.  Each value is prepended with
   a header explaining the data you will be reading.
  </p>

  <p>
   Value header is as follows.
  </p>

  <pre>
[value header] => [type flag][array and encoding flag] [array count] [compressed size]

[type flag] is one of:
kv - key value block.
"" - string (UTF8) data.
bo - boolean value. 
i1 - integer of 1 byte
i2 -            2
i4 -            4
i8 -            8
n1 - natural of 1 byte
n2 -            2
n4 -            4
n8 -            8
r4 - real    of 4 bytes
r8 -            8
pr - 2d point using r4.
pR -                r8.
Pr - 3d point using r4.
PR -                r8.
pi - 2d point using i4.
pI -                i8.
Pi - 3d point using i4.
PI -                i8.
pn - 2d point using n4.
pN -                n8.
Pn - 3d point using n4.
PN -                n8.
mr - 3x3 matrix using r4.  
mR -                  r8.
Mr - 4x4 matrix using r4.
MR -                  r8.
c3 - rgb  color using n1.
c4 - rgba color using n1.
C3 - rgb  color using r4.
C4 - rgba color using r4.
g3 - graphic (image) using c3.
g4 -                       c4.
G3 - graphic         using C3.
G4 -                       C4.
gp - graphic as a PNG file.     
gj - graphic as a JPG file.     
gJ - graphic as a JPG2000 file. 
gl - graphic as a link to a file.
az - azimuth (strike) using r4, azimuth in degrees
ad - dip direction    using r4, dip direction in degrees
Ad - azimuth and dip  using r4, azimuth in degrees, dip in degrees
A% -                                                       percent
A/ -                                                       ratio 1:XXX
dd - dip only         using r4, dip in degrees
d% -                                   percent
d/ -                                   ratio 1:XXX
td - time: date only.
tt - time: time only.
t* - time: date and time.
bn - binary data.

[array and encoding flag] is one of:
t  - Single data point.    Readable text encoding.
T  - Array of data points.                                 
e  - Single data point.    Base64 encoded.                 
E  - Array of data points.                                 
z  - Single data point.    Zlib compressed, base64 encoded.
Z  - Array of data points.                                 

[array count] will be an unsigned integer value indicating how many values in the array.  Only present when T, E, and Z are used.

[compressed size] will be an unsigned integer value indicating the raw, in memory byte count of the compressed data.  Only present when z and Z are used.

e, E, z, and Z will generate a base64 encoded string.  This string lives on one line, there are no \n embedded in the encoding.

Examples: (adding \n to indicate the necessity of this line.)

image g3z 64 64 [base64 zip compressed byte stream]\n

count n1 128\n

string ""t This is a string.\nThis is really a multiline string!\n

pointList PRT 5 10.5 20 0 20.5 20 0 20.5 50 0 10.5 50 0 10.5 20 0\n
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "textValue", "Value: Value");</script>

  <p>
   <strong>t encoding</strong>
  </p>

  <pre>
Type                                                         Representation
----------------------------------------------------------   ------------------------------------------
kv                                                           See Key Value Block below.
""                                                           See String Encoding below.
bo                                                           't' for true, 'f' for false.
i1, i2, i4, i8, n1, n2, n4, n8, r4, r8, az, ad, dd, d%, d/   1 number. 
pr, pR, pi, pI, pn, pN, Ad, A%, A/                           2 numbers separated by at least one space. (east, north)
Pr, PR, Pi, PI, Pn, PN, c3, C3                               3 numbers separated by at least one space. (east, north, z)
mr, mR                                                       9 numbers separated by at least one space.  
                                                             Columns written out left to right before moving to the next row.  
                                                             Rows written out top to bottom.
Mr, MR                                                       16 numbers separated by at least one space.
                                                             Columns written out left to right before moving to the next row.  
                                                             Rows written out top to bottom.
c4, C4                                                       4 numbers separated by at least one space.
g3, g4, G3, G4, gp, gj, gJ, gl                               See Graphic Encoding below.
td                                                           "YYYY-MM-DD" format.
tt                                                           "HH:MM:SS" format, GMT timezone.
t*                                                           "YYYY-MM-DD HH:MM:SS" format.
bn                                                           See Binary Encoding below.
</pre>

  <p>
   For all the above.  If using 'T' encoding, the individual array elements are separated with at least one space.
  </p>

  <p>
   <strong>e and z encoding</strong>
  </p>
  <p>
   We are dumping the internal memory in binary form out to the Text MIFF in a binary encoded text
   representation.
  </p>

  <pre>
Type                             Representation
------------------------------   ------------------------------------------
bo                               1 for true, 0 for false.  1 bit in 1 byte.
i1, n1                           1 byte. 
i2, n2                           2 bytes. 
i4, n4, r4, az, ad, dd, d%, d/   4 bytes. 
i8, n8, r8                       8 bytes. 
pr, pi, pn, Ad, A%, A/           2 x 4 bytes. (east, north)
pR, pI, pN                       2 x 8 bytes.
Pr, Pi, Pn,                      3 x 4 bytes. (east, north, z)
PR, PI, PN                       3 x 8 bytes.
mr                               9 x 4 bytes.  
                                 Columns written out left to right before moving to the next row.  
                                 Rows written out top to bottom.
mR                               9 x 8 bytes.  
                                 Columns written out left to right before moving to the next row.  
                                 Rows written out top to bottom.
Mr                               16 x 4 bytes.
                                 Columns written out left to right before moving to the next row.  
                                 Rows written out top to bottom.
MR                               16 x 8 bytes.
                                 Columns written out left to right before moving to the next row.  
                                 Rows written out top to bottom.
c3                               3 x 1 byte.  (r, g, b)
C4                               3 x 4 bytes. 
c4                               3 x 1 byte.  (r, g, b, a)
C4                               4 x 4 bytes. 
td                               2 bytes, 1 byte, 1 byte. (year, month, day)
tt                               1 byte, 1 byte, 1 byte. (24 hour, minute, second)
t*                               2 bytes, 1 byte, 1 byte, 1 byte, 1 byte, 1 byte. (year, month, day, 24 hour, minute, second)
</pre>

  <p>
   Arrays of the above will just tacking on another bunch of bytes to as many iterations as found
   in the array.
  </p>
  <p>
   Array of booleans in binary or base64 encoding forma is special, for efficiency it should be a bitmap.  
  </p>
  <pre>
Byte 0                            Byte 1
+---+---+---+---+---+---+---+---+ +---  ...
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | | 8
+---+---+---+---+---+---+---+---+ +--- ...
 2^7 2^6 ...                 2^0   2^8 ...                   
</pre>
  <p>
   0, 1, 2, ... indicates the index into the array and how it relates to the bytes.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "textValueKeyValue", "Value: Key Value Block");</script>

  <p>
   Key value blocks are special.  They are needed to allow nesting of key values.  The last line of
   a block needs to be a comletely empty line with nothing on it but a \n to indicate that the
   block is terminated.
  </p>

  <pre>
docInfo kv\n
 title  ""t M.I.F.F.: Mining Interchange File Format\n
 author ""t Robbert de Groot\n
\n
</pre>

  <p>
   Trying to make it clear how it works.  Leading separators before the key are unnecessary and are
   only here for clarity.  Leading separators before a \n are allowed but are wasteful.
  </p>

  <pre>
level1 kv\n
 level2 kv\n
  level3 kv\n
   ...
  \n
  anotherLevel3 kv\n
  \n
 \n
 anotherLevel2 kv\n
 \n
\n
anotherLevel1 kv\n
...
\n
</pre>

  <p>
   Key value bocks can have an 'a' array specifier and a array count.  This is useful for an array
   of a complex type.
  </p>

  <pre>
itemList kva 2\n
item kv\n
name ""t item A\n
value i4t 0\n
\n
item kv\n
name ""t item B\n
value i4t 10\n
\n
\n
</pre>

  <p>
   e, E, z, and Z are never used with kv.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "textValueString", "Value: String Encoding");</script>

  <p>
   String values are sort of the odd one out with all the other data types.  The other data types
   have a known size based on their input while strings are variable in size.  So encoding them
   will be slightly different.
  </p>
  <p>
   All strings will have their cursor return and line feed characters replaced with \r and \n
   respectively when written to the file.  If your string already has a \r and \n inside then the
   slash will be escaped, \\r and \\n respectively, so that they do not get converted when reading
   them back in.
  </p>
  <p>
   Even though \n is strictly followed for the text format, I convert \r as well because text
   editors will attempt to honor \r or complain about inconsistent line endings and mess things up.
  </p>
  <p>
   If the string is base64 or Zlib compressed then this \r and \n encoding does not happen as it is
   not needed.
  </p>
  <p>
   Strings are placed on one line even if they define a multi-line string.  With the above
   replacement of cursor return and line feeds this can be done.
  </p>
  <p>
   Unlike other data types, strings using "t" encoding in the value header can not have leading
   separators in front of their value.
  </p>
  <p>
   For a single string, the value will immediately start one separator after the value header.
  </p>
  <p>
   For an array of strings, the first character of the the next line will be the start of the
   first string in the array.  The line after that will be the second string.  No lines will have
   any leading spaces.  Any space visible is part of the string.
  </p>

  <pre>
string ""t This is a single string value.\nBut multiline. Only \\r and \\n need escaping and not other \s in the string\n

stringList ""T 3\n
This is string 1, line 1.\\r\\nThis is line 2.\\r\\n\n
This is string 2.\n
This is string 3.\n
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "textValueGraphic", "Value: Graphic Encoding");</script>

  <p>
   <strong>g3, g4, G3, G4</strong>
  </p>
  <p>
   These graphic options will have a header of 2 unsigned integer values before the image data.  
   These values indicate width and height of the graphic.  These values are not included in the 
   Base64 or Zlib compression if compression is used.  However the image data will honor Base64 or 
   Zlib compression if used.
  </p>
  <p>
   Images are written out row by row, left to right, top to bottom.
  </p>
  <p>
   Array of graphics will place each graphic on a separate line similar to string encoding.
  </p>

  <pre>
image g3t 2 2 0 0 0 64 64 64 128 128 128 192 192 192\n

image g3T 2\n
2 2 0 0 0 64 64 64 128 128 128 192 192 192\n
2 2 64 64 64 128 128 128 192 192 192 255 255 255\n
</pre>

  <p>
   <strong>gp, gj, gJ</strong>
  </p>

  <p>
   For gp, gj, and gJ, the file that represents the image is copied verbatum into the value
   portion.  There is never any compression applied.  The data is always base64 encoded.  e, E, z,
   and Z are never used. 
  </p>

  <pre>
imageFile gpt [base64 encoding of a png file data]\n

imageFileList gpT 2\n
[base64 encoding of a png file 1 data]\n
[base64 encoding of a png file 2 data]\n
</pre>

  <p>
   <strong>gl</strong>
  </p>

  <p>
   For gl, there will be a path to an image.  This path should really be relative to the MIFF file
   so that finding this file is easy.  However this is up to the software writing the MIFF file.
   e, E, z, and Z are never used for this type.
  </p>

  <pre>
imageFileLink glt \path\to\image\file\image.png\n

imageFileLinkList glT 2\n
\path\to\image\file\image1.png\n
\path\to\image\file\image2.png\n
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "textValueBinary", "Value: Binary Encoding");</script>

  <p>
   The binary data will have a header of 1 unsigned integer value before the binary data.  This 
   value indicates the byte count of the binary data.  This byte count is not included when using 
   Base64 ro Zlib compression.  However the binary data will honor Base64 and Zlib compression if
   used.
  </p>

  <pre>
image bnt 10 0 1 2 3 4 5 7 8 9\n

image bnT 2\n
10 0 1 2 3 4 5 6 7 8 9\n
10 9 8 7 6 5 4 3 2 1 0\n
</pre>

  <p>
   Binary blobs are dangerous and should be used rarely if at all.  If someone uses them then they 
   should be on the hook to define what the contents of the blob mean.  If they do not, then they 
   are being bad citizens and should be shamed!
  </p>
  <p>
   However this is here as a catchall just in case.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "bin", "Binary");</script>

  <p>
   The Binary file will to match the Text file 1-1.  Everything within '[]' is a byte sequence of
   a known size.  Each byte seqence is separated here with a comma but is immediately following
   after previous byte sequence.
  </p>
  <p>
   A byte sequence is [[size]:[name]], where size is a number indicating the number of bytes this
   sequence takes up.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "binKeyValue", "Key Value Pair");</script>

  <pre>
[1:key string length],[key string length:key],[3:value header],[4;array count],[4:compress buffer size],[*:value]
</pre>

  <p>
   [key string length] is the first byte sequence and defines how long the key string is in bytes.
  </p>
  <p>
   [key] is the second byte sequence and defines the key of the key value pair.  The length of
   which was defined by [key string lenght] above.  This means keys can not exceed 255 bytes.
   No null terminator for the key.
  </p>
  <p>
   [value header] is the third byte sequence and is 3 bytes following the [array and encoding flag]
   as defined in the Text section above.
  </p>
  <p>
   t, T, e, and E are all the same in binary mode.  The data is stored raw and no encoding is
   actually done.  z and Z will apply Zlib compression to the binary data.
  </p>
  <p>
   [array count] and [compress buffer size] are only present when certain value header conditions
   are present.  Meaning [array count] byte sequence is only present when the value is an array of
   values; [compress buffer size] is only present when the value is being compressed with zlib
   compression routines.  If neither of these are present in the value header then these byte
   sequences are not present.
  </p>
  <p>
   Both [array count] and [compress buffer size] are 4 byte unsigned integers stored in network
   order.
  </p>
  <p>
   [value] field will vary wildly depending on the [value header], [array count], and [compress
   buffer size] values.  But it will be a known size given that information.
  </p>

  <pre>
[value] 
Type                                              Byte Count
---------------------------------------           ---------------------------
=                                                 See Key Value Block below.
""                                                See String Encoding below.
i1, n1                                              1 
i2, n2                                              2
c3, tt                                              3
c4, i4, n4, r4, az, ad, dd, d%, d/, td              4
t*                                                  7
i8, n8, r8, pr, pi, pn, Ad, A%, A/                  8
c4, Pr, Pi, Pn                                     12
pR, pI, pN                                         16
PR, PI, PN                                         24
C4                                                 32
mr                                                 36
Mr                                                 64
mR                                                 72
MR                                                128
g3, g4, G3, G4                                    See Graphic Encoding below.
bn                                                See Binary Encoding below.
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "binValueKeyValue", "Value: Key Value Block");</script>

  <p>
   This indicates the start of a block.  There technically is not value.  The next byte after the
   [value header] is the start of the first key in the block.
  </p>
  <p>
   A block is terminated when the [key string length] is equal to 0.
  </p>

  <pre>
[8],["itemList"],["=   "],
[> 0 key string length],...
[> 0 key string length],...
[> 0 key string length],...
[0]
</pre>

  <p>
   Hopefully the above explains it.  I have defined an "itemList" key which starts the key value
   block.  If the next key value has a key string length that is > 0 then it is part of the
   itemList key value block.  The last key string length is 0 which indicates that the block is
   done.  Anything that follows the block is a new key value thing.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "binValueString", "Value: String Encoding");</script>

  <p>
   String encoding is simpler than in the text case.
  </p>

  <pre>
[4:string length][string length:string]
</pre>

  <p>
   Each string is prefixed with a [string length], the byte count of the UTF8 string.  Then you
   just dump out the string in UTF8 format.
  </p>
  <p>
   Array of strings will have as many of these pairs as found in the array.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "binValueGraphic", "Value: Graphic Encoding");</script>

  <p>
   For g3, g4, G3, and G4 the format is...
  </p>

  <pre>
[4:width][4:height][width * height * size of [c3|c4|C3|C4]:graphic data]
</pre>

  <p>
   Raw graphic data size will be (unsigned integer) width * (unsigned integer) height * size of the
   color item.  It will be the compressed size in the file if compression is used but the raw size
   in memory.
  </p>

  <p>
   For gp, gj, and gJ the format is...
  </p>

  <pre>
[4:image file size][image file size:binary buffer of the image file]
</pre>

  <p>
   For gl the format is...
  </p>

  <pre>
[4:string length][string length:file path]
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "binValueBinary", "Value: Binary Encoding");</script>

  <p>
   Binary encoding is like string encoding.  We need a byte count before the buffer data.
  </p>

  <pre>
[4:byte count][byte count:buffer data]
</pre>

  <p>
   byte count will never be compressed when compression is used but buffer data will.
  </p>
  <p>
   Array of binaries will have as many of these pairs as found in the array.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "baseDesign", "Design Decisions:");</script>

  <p>
   <strong>Why not XML or JSON?</strong><br />
   I did not take XML as a format because it is too verbose.  JSON is very flexible but I also
   find it is still unnecessarily verbose.  Better than XML but still unacceptable in my opinion.
   Considering the data, I do not want a format that would cause too much data bloat.  There will
   always be some bloat happening but it should be mitigated in my opinion.
  </p>

  <p>
   <strong>Why network order for multibyte data types?</strong><br />
   In the past my company was multi-platform, SGI IRIX, SUN OS, SUN Solaris and Windows NT.  At
   that time the architecture on some of the other platforms was Big Endian and we stored the data
   in the native format of the machine.  However this lead to issues when users moved their data
   over to a Little Endian machine which Windows has always been.  The problems that we faced were
   trivial to solve but just very annoying and yet anothering thing to remember.  So standardizing
   on one option is easier than having to support two options.  I go with simplicity, only one
   option to rule them all!  It keeps things simpler.
  </p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "formatMine", "MIFF Format: Mining");</script>

  <p>
   The above section defines how the data is stored in the format.  But it does not address the
   meat of the mining data.  In actuality, the above is agnostic with regards to data to be stored.
   It could be used for game information of anything else for that matter.
  </p>
  <p>
   From now on we will concenttrate on actual Mining field related data.
  </p>

  <p>
   The various data that mining companies need to keep track of and transfer around.
  </p>

  <ul>
   <li>
    Geometry
    <ul>
     <li>
      3D
      <ul>
       <li>Points</li>
       <li>Polylines (open and closed)</li>
       <li>Surfaces:Generic (open and closed (solids))</li>
       <li>Surfaces:Grid</li>
       <li>Text</li>
       <li>Symbol</li>
      </ul>
     </li>
     <li>
      2D (Planar, Fence)
      <ul>
       <li>Points</li>
       <li>Polylines (open and closed)</li>
       <li>Text</li>
       <li>Symbol</li>
      </ul>
     </li>
    </ul>
   </li>
   <li>
    Drillhole
    <ul>
     <li>Drillhole survery information.</li>
     <li>Drillhole assay information.</li>
     <li>Drillhole composite information.</li>
     <li>Blast hole shot information.</li>
     <li>Chip assay information.</li>
     <li>Design vs surveyed information.</li>
    </ul>
   </li>
   <li>
    Model
    <ul>
     <li>
      Block model information.
      <ul>
       <li>Regular</li>
       <li>Sub-blocked</li>
       <li>Seam</li>
      </ul>
     </li>
     <li>
      Seam model information.
      <ul>
       <li>Regular</li>
       <li>Sub-blocked</li>
      </ul>
     </li>
     <li>
      Surface model information.
      <ul>
       <li>Regular</li>
       <li>Sub-blocked</li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>

  <p>
   MIFF will handle all these types of data.  However, how each is actually stored in MIFF can vary.
  </p>
  <p>
   File naming can help in MIFF file importing.  It is suggested to use the following file extensions...
  </p>
  <ul>
   <li>*.miff - Still valid but can be anything.  What is it?</li>
   <li>*.miffGeom - for Geometry data.</li>
   <li>*.miffDrill - for Drillhole data.</li>
   <li>*.miffModel - for Model data.</li>
  </ul>
  <p>
   This information is duplicated inside the file so reading in the file will confirm with the extension
   but it will help the user if the extension is properly set.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formatMineInfo", "Information Block");</script>

  <p>
   Common to all MIFF Mining Formats for any of the types above, there will be an information block
   providing general, data wide information.
  </p>
  <p>
   This information block will be the very first key value in the file right after the MIFF header.
  </p>

  <pre>
MIFF   1TXT\n
info kv\n
...
\n
</pre>

  <p>
   Inside the information block we have the following possible key values.  Not all are required.
  </p>

  <pre>
type ""t [file type]
company ""t [company name]
copyright ""t [copyright if any]
author ""t [client employee name]
dateCreated t* [date created]
dateModified t* [date modified]
comment ""t [comments]
...
</pre>

  <p>
   [file type] is one of...
  </p>
  <ul>
   <li>Drillhole</li>
   <li>Geometry</li>
   <li>Model</li>
  </ul>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "formatMineModel", "MIFF Format: Mining: Model");</script>

  <p>
   There are 3 basic model formats that are in use.
  </p>

  <ul>
   <li>Block Model</li>
   <li>Seam Model</li>
   <li>Surface Model</li>
  </ul>

  <p>
   Block Model is a regular collection of, usually, uniform blocks.  Each block will have values
   for what ever it is that is being tracked by the client.
  </p>
  <p>
   Seam Model is a bit fancier Block Model.  This format will be regular in the east and north
   directions of the model but there is not regular block size in the elevation direction.  In
   short you will have 'seams' and each block in the east and north for a seam will have an
   elevation top and bottom to indicate the seam's limits and that defines the volume, as well as
   any other values that are found within that seam block.
  </p>
  <p>
   The last one, Surface Model, is much more limited than the other two as it just holds a stack
   of surfaces instead of defining any volume.  Like the Seam Model, Surface Models are regular
   in the east and north directions of the model but not regular in the elevation.  In short you
   will have 'surfaces' and each block for a surface will have an elevation value as well as
   other values that are being tracked by the client at that surface block.
  </p>
  <p>
   Even though only Block Models are sub-blocked, MIFF does not limit you to only allowing
   sub-blocks for Block Models.  The logic could be applied to the other two if the software
   does do this.  As far as I know, all software providers only do this for Block Models and not
   for Seam Models or Surface Models.
  </p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formatMineModelInfo", "Information Block: Model");</script>

  <p>
   After the general information block the next block will be the Model Information block.
  </p>

  <pre>
InfoModel kv
 type ""t [model type]
 isSubblocked bot [true if subblocked]
 subblockType ""t [subblock type]
 subblockOption Pn [subblock fixed resolution]
 subblockOption pn [subblock row col resolution]
 subblockOption n4 [subblock octtree level count]
 origin PRt  [origin point]
 colVec PRt  [column vector, length if vector is the length of the block] 
 rowVec PRt  [row vector, length of the vector is the length of the block]
 benVec PRt  [bench vector, length of the vector id the length of the block] 
 blockCount Pnt [number of column, row, bench blocks]
 isBenVariable bot [true if variable bench heights]
 benchList r4at [number of benchs] [length] [length] ...
 itemList kv [item list count]
  item kv 
   id ""t [item id]
   nameLong ""t [item name]
   nameShort ""t [item name short]
   type ""t [item type]
   min r4t [item min value]
   max r4t [item max value]
   precision r4t [item precision]
\n
...
\n
\n
\n
</pre>






  <script>UpdateToc();</script>

 </body>
</html>
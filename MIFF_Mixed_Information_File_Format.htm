<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href="style_reset.css">
  <link rel="stylesheet" type="text/css" href="style.css">
  <title>M.I.F.F.: Mixed Information File Format</title>

  <!-- Script for generation a table of contents -->
  <script>
const indexLEVEL     = 0;
const indexTAG       = 1;
const indexTITLE     = 2;
const indexHAS_TYPE  = 3;
const indexHAS_CONST = 4;
const indexHAS_FUNC  = 5;
const indexCOUNT     = 6;

var tocIndex = 0;
var toc      = [];

// Display a header line and add to the table of contents (TOC)
function HeaderAdd(level, tag, title)
{
   var record = [];
   
   record[indexLEVEL]     = level;
   record[indexTAG]       = tag;
   record[indexTITLE]     = title;
   record[indexHAS_TYPE]  = false;
   record[indexHAS_CONST] = false;
   record[indexHAS_FUNC]  = false;

   toc.push(record);

   // Chrome complains about this document write.  I have looked for an alternative but everything
   // I have found is utter rubbish.  HeaderAdd is only called on doc load.  This call is not a
   // problem.
   document.write("<h" + level + "><a name=\"" + tag + "\">" + title + "</a></h" + level + ">\n\n");
}

function HeaderAddType()
{
   var record = toc[toc.length - 1];

   record[indexHAS_TYPE] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Type\">Type</a></h2>\n\n");
}

function HeaderAddConst()
{
   var record = toc[toc.length - 1];

   record[indexHAS_CONST] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Const\">Constant</a></h2>\n\n");
}

function HeaderAddFunc()
{
   var record = toc[toc.length - 1];

   record[indexHAS_FUNC] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Func\">Function</a></h2>\n\n");
}

// Update the TOC with all the header lines.
function UpdateToc()
{
   var value;
   var record;
   var index;

   value = "<table>\n";

   for (; tocIndex < toc.length; tocIndex++)
   {
      record     = toc[tocIndex];
    
      value += "<tr>\n<td>";
    
      // Indenting
      for (index = 1; index < record[0]; index++)
      {
         value += "&nbsp;&nbsp;&nbsp;&nbsp;";
      }

      value += "<a href=\"#" + record[1] + "\">" + record[2] + "</a></td>\n";
      
      value += "<td>";
      if (record[indexHAS_TYPE] == 1)
      {
         value += "<a href=\"#" + record[1] + "Type\">Type</a>\n";
      }
      value += "</td>\n";
      
      value += "<td>";
      if (record[indexHAS_CONST] == 1)
      {
         value += "<a href=\"#" + record[1] + "Const\">Constant</a>\n";
      }
      value += "</td>\n";

      value += "<td>";
      if (record[indexHAS_FUNC] == 1)
      {
         value += "<a href=\"#" + record[1] + "Func\">Function</a>\n";
      }
      value += "</td>\n";

      value += "</td>\n";
   }

   value += "</table>\n";

   document.getElementById("toc").innerHTML = value;
}
  </script>
 </head>
 <body>
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <h1 class="page">M.I.F.F.: Mixed Information File Format</h1>

  <table>
   <tr>
    <td><p>Author:</p></td>
    <td>Robbert de Groot</td>
   </tr>
   <tr>
    <td><p>Date:</p></td>
    <td>2019-05-15</td>
   </tr>
   <tr>
    <td><p>Copyright:</p></td>
    <td>2019, Robbert de Groot</td>
   </tr>
   <tr>
    <td><p>License:</p></td>
    <td>The library will be MIT License.</td>
   </tr>
   <tr>
    <td></td>
    <td>This document is licensed under Creative Commons Attribution-NoDerivs. 
	<a href="https://creativecommons.org/licenses/by-nd:4.0/">(CC BY-ND)</a></td>
   </tr>
  </table>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <h1>Table Of Contents:</h1>

  <p id="toc"></p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "miff", "M.I.F.F.");</script>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "about", "Discussion");</script>

  <p>What is the purpose of M.I.F.F. (MIFF)?  MIFF is intended to be a simple file format for 
  storing data.  Any data.</p>

  <p>It started life because of a need for a reduced data storage format for larger amounts of data.
  See Mining Interchange MIFF since that was the reason for this document.</p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "goals", "Goals");</script>

  <ul>
   <li><strong>Simple</strong>.  The format should be simple for the developers to export their 
   data.  And still fairly simple to re-import that data.</li>

   <li><strong>Brief</strong>.  The format should not produce unnecessary waste.  The data in some
   cases will be quite large so it should not bloat the data too much.  Meaning, file sizes should
   not become overly large.  However, because of point 1 there will always be some bloat.</li>

   <li><strong>Flexible</strong>.  The format needs to be able to accomodate change or specific 
   data.  A years go by, software will also change and requirements will change.  The format needs 
   to try its best to keep up without importers and exporters to be completely remade.</li>
  </ul>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "disclosure", "Disclosure");</script>

  <p>I, Robbert de Groot, have been a professional Software Developer since 1995.</p>

  <p>This format is currently not sanctioned by any software vendor.  This was a thought on 
  developing something in place of existing options.</p>

  <p>I can be reached at the following two email addresses.</p>

  <p>robbert.degroot@hexagon.com<br />zekaric@gmail.com</p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "formatBase", "MIFF Format: Base");</script>

  <p>There are two representations of the format.  A Text file and a Binary file representation.
  They will both contain exactly the same data and be exactly the same in feature set.  The Binary
  file may just have the advantage of being slightly more accurate, possibly slightly more compact
  and possibly slightly faster in reading and writing.</p>

  <p>At the low level, a MIFF format is just a collection of key value pairs.  Values can be a
  collection of further key value pairs.  Meaning nesting can be possible.</p>

  <p>The intent on reading these files is to make just one pass over them; twice at most, but for
  the most part, one pass over the contents should be enough to read in the data.  There is no
  focus on making the file random accessable or modifiable.  This format is not intended as a
  substitute for native formats for any software package.</p>

  <p>Common to both styles, any mutlibyte data that is encode or stored as a binary byte sequence
  will be in network (big endian) order.</p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formatBaseHeader", "File Header");</script>

  <p>There will always be a file header so that you can be sure the file you recieved is actually a
  MIFF file and not some other file.</p>

  <pre>"MIFF   1TXT [Sub-Format Name] [Sub-Format Version]\n"</pre>

  <p>or</p>

  <pre>"MIFF   1BIN " + [32 bytes:Sub-Format Name] + [4 bytes:Sub-Format Version]</pre>

  <p>"MIFF" indicates the base file format type.</p>

  <p>"&nbsp;&nbsp;&nbsp;1" indicates the base file format version.  Currently at version 1.  This
  will only use whole numbers instead of the usual XX.XX.XX.XX versioning of software.</p>

  <p>"TXT " and "BIN " indicate the content organization.  TXT for text, and BIN for binary.
  "\n" is a line feed character.  This is part of the string.</p>
  
  <p>[Sub-Format Name] will always be 32 bytes or less.  Could be UTF8 but usually just using the
  first 127 printable code points of the UNICODE standard.  This value defines the format of what is
  being stored in the file.</p>
  
  <p>[Sub-Format Version] will always be an unsigned 4 byte value.  Like the MIFF version in terms 
  of how versioning will happen.</p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formateBaseContent", "Content");</script>

  <p>Before going into the specifics of the text format and the binary format we will cover what a
  key value pair will look like at a high level.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseContentKeyValue", "Key Value Format");</script>

  <pre>[key] [value header] [value]\n</pre>

  <p><strong>[key]</strong> will be a string that will somewhat uniquely identify the value.</p>
  
  <p><strong>[value header]</strong> will be an code of characters that will dictate what the value
  will look like.</p>

  <p><strong>[value]</strong> will depend on the [value header] on what is contained here.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseContentKeyValueKey", "Key");</script>

  <p>Keys are always a single string of characters and are limited to printable character in the
  first 127 UNICODE code points.  Meaning no whitespace of any kind inside a key.</p>

  <pre>
12345
;':][.,<>]'
a_b_c
$cost
</pre>

  <p>The key can be nonsense or just a number.  As long it does not include any whitespace.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseContentKeyValueValueHeader", "Value Header");</script>

  <p>There are quite a few different value types and encodings.  Each value is prepended with a
  header explaining the data you will be reading.</p>

  <p>Value header is as follows.</p>

  <pre>
[type flag][array and encoding flag] [array count] [compressed size]
</pre>

  <p><strong>[type flag]</strong> is one of:</p>

  <table>
   <tr> <th>2 Letter Type Code</th> <th>Description</th></tr>
   <tr> <td>kv</td>                 <td>Key-Value block.</td></tr>
   <tr> <td>""</td>                 <td>String (UTF8) data.</td></tr>
   <tr> <td>az</td>                 <td>Azimuth (strike) using r4. Value in degrees</td></tr>
   <tr> <td>ad</td>                 <td>Dip direction using r4. Value in degrees</td></tr>
   <tr> <td>Ad</td>                 <td>Azimuth and Dip using r4. Azimuth in degrees. Dip in degrees</td></tr>
   <tr> <td>A%</td>                 <td>Azimuth and Dip using r4. Azimuth in degrees. Dip in percent</td></tr>
   <tr> <td>A:</td>                 <td>Azimuth and Dip using r4. Azimuth in degrees. Dip in ratio 1:XXX</td></tr>
   <tr> <td>bn</td>                 <td>Binary data.</td></tr>
   <tr> <td>bo</td>                 <td>Boolean value.</td></tr>
   <tr> <td>c3</td>                 <td>Color (RGB) using n1.</td></tr>
   <tr> <td>c4</td>                 <td>Color (RGBA) using n1.</td></tr>
   <tr> <td>C3</td>                 <td>Color (RGB) using r4.</td></tr>
   <tr> <td>C4</td>                 <td>Color (RGBA) using r4.</td></tr>
   <tr> <td>co</td>                 <td>Count same as n4.</td></tr>
   <tr> <td>Co</td>                 <td>Count same as n8.</td></tr>
   <tr> <td>dd</td>                 <td>Dip using r4. Value in degrees</td></tr>
   <tr> <td>d%</td>                 <td>Dip using r4. Value in percent</td></tr>
   <tr> <td>d:</td>                 <td>Dip using r4. Value in ratio 1:XXX</td></tr>
   <tr> <td>Fi</td>                 <td>3D face point index.</td></tr>
   <tr> <td>FL</td>                 <td>A list of face point index list.</td></tr>
   <tr> <td>Fr</td>                 <td>Face using r4.  A face is 3 x Pr</td></tr>
   <tr> <td>FR</td>                 <td>Face using r8.  A face is 3 x PR</td></tr>
   <tr> <td>g3</td>                 <td>Graphic using c3.</td></tr>
   <tr> <td>g4</td>                 <td>Graphic using c4.</td></tr>
   <tr> <td>gf</td>                 <td>Graphic as an inline included file.</td></tr>
   <tr> <td>gl</td>                 <td>Graphic as a link to a file.</td></tr>
   <tr> <td>G3</td>                 <td>Graphic using C3.</td></tr>
   <tr> <td>G4</td>                 <td>Graphic using C4.</td></tr>
   <tr> <td>i1</td>                 <td>Integer of 1 byte.</td></tr>
   <tr> <td>i2</td>                 <td>Integer of 2 bytes.</td></tr>
   <tr> <td>i4</td>                 <td>Integer of 4 bytes.</td></tr>
   <tr> <td>i8</td>                 <td>Integer of 8 bytes.</td></tr>
   <tr> <td>id</td>                 <td>Id value, same as n4.  Potentially not unique, user controlled value.</td></tr>
   <tr> <td>Id</td>                 <td>GUID value.  Must be unique in a given MIFF file.</td></tr>
   <tr> <td>ix</td>                 <td>Index same as n4.</td></tr>
   <tr> <td>Ix</td>                 <td>Index same as n8.</td></tr>
   <tr> <td>mr</td>                 <td>3x3 matrix using r4.</td></tr>
   <tr> <td>mR</td>                 <td>3x3 matrix using r8.</td></tr>
   <tr> <td>Mr</td>                 <td>4x4 matrix using r4.</td></tr>
   <tr> <td>MR</td>                 <td>4x4 matrix using r8.</td></tr>
   <tr> <td>n1</td>                 <td>Natural of 1 byte.</td></tr>
   <tr> <td>n2</td>                 <td>Natural of 2 bytes.</td></tr>
   <tr> <td>n4</td>                 <td>Natural of 4 bytes.</td></tr>
   <tr> <td>n8</td>                 <td>Natural of 8 bytes.</td></tr>
   <tr> <td>of</td>                 <td>Offset same as n4.</td></tr>
   <tr> <td>Of</td>                 <td>Offset same as n8.</td></tr>
   <tr> <td>pi</td>                 <td>2d value using i4.</td></tr>
   <tr> <td>pI</td>                 <td>2d value using i8.</td></tr>
   <tr> <td>pl</td>                 <td>A list of 2D value lists using r4.</td></tr>
   <tr> <td>pL</td>                 <td>A list of 2D value lists using r8.</td></tr>
   <tr> <td>pn</td>                 <td>2d value using n4.</td></tr>
   <tr> <td>pN</td>                 <td>2d value using n8.</td></tr>
   <tr> <td>pr</td>                 <td>2d value using r4.</td></tr>
   <tr> <td>pR</td>                 <td>2d value using r8.</td></tr>
   <tr> <td>Pi</td>                 <td>3d value using i4.</td></tr>
   <tr> <td>PI</td>                 <td>3d value using i8.</td></tr>
   <tr> <td>Pl</td>                 <td>A list of 3D value lists using r4.</td></tr>
   <tr> <td>PL</td>                 <td>A list of 3D value lists using r8.</td></tr>
   <tr> <td>Pn</td>                 <td>3d value using n4.</td></tr>
   <tr> <td>PN</td>                 <td>3d value using n8.</td></tr>
   <tr> <td>Pr</td>                 <td>3d value using r4.</td></tr>
   <tr> <td>PR</td>                 <td>3d value using r8.</td></tr>
   <tr> <td>r4</td>                 <td>Real of 4 bytes.</td></tr>
   <tr> <td>r8</td>                 <td>Real of 8 bytes.</td></tr>
   <tr> <td>sz</td>                 <td>Size same as n4.</td></tr>
   <tr> <td>Sz</td>                 <td>Size same as n8.</td></tr>
   <tr> <td>td</td>                 <td>Time, date only.</td></tr>
   <tr> <td>tt</td>                 <td>Time, time only.</td></tr>
   <tr> <td>t*</td>                 <td>Time, date and time.</td></tr>
   <tr> <td>ty</td>                 <td>Type value.  One of these 2 lettter type codes</td></tr>
   <tr> <td>vs</td>                 <td>Value stream.  The contents deviates from the rest of the format.  Representations will explained where they are used.</td></tr>
  </table>

  <p><strong>[array and encoding flag]</strong> is one of:</p>

  <table>
   <tr> <th>Encoding Code</th> <th>Description</th></tr>
   <tr> <td>[empty]</td>       <td>Single value, UTF8 readable encoding.</td></tr>
   <tr> <td>A</td>             <td>Array of values, UTF8 readable encoding.</td></tr>
   <tr> <td>e</td>             <td>Single value.  Binary representation of value is Base64 encoded.</td>
   <tr> <td>E</td>             <td>Array of values.  Binary representation of the array of values is Base64 encoded.</td>
   <tr> <td>z</td>             <td>Single value.  Binary representation of value if Zlib compressed then base64 encoded.</td>
   <tr> <td>Z</td>             <td>Array of values.  Binary representation of value if Zlib compressed then base64 encoded.</td>
  </table>

  <p><strong>[array count]</strong> will only present when E, A, and Z are used.  This will be an 
  unsigned integer value indicating how many items are in the array.</p>

  <p><strong>[compressed size]</strong> will only present when z and Z are used.  This will be an 
  unsigned integer value indicating the raw, in memory byte count of the compressed data buffer.</p>

  <p>e and E are only used in the Text represention of a MIFF file.  Binary representation only has
  one way to store data.</p>
  
  <p>A is used to indicate an array of values.  If used the array is either too small to really need
  compression or too random that compression will not really reduce the byte count.</p>

  <p>e, E, z, and Z will generate a base64 encoded string in the Text format.  This string lives on 
  one line, there are no '\n' embedded in the encoding.</p>

  <p>Why co, Co, sz, Sz, ix, Ix, of, and Of when n4 and n8 would suffice?  The extra semantic 
  information about what we are storing may be useful and it separates these values with a hard 
  coded representation.  Potentially in the future, the representation may change to accommodate 
  larger values.  In which case older MIFF files need not have to change.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseContentKeyValueValue", "Value");</script>

  <p>The value header generally indicates what will be stored in the value of the key value pair.
  It then becomes an issue on how it is represented in the two types of files.  See their respective
  sections for the details.</p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formateBaseText", "Text Format");</script>

  <p>The text format is a UTF8 text file.  UTF8 is the 1 byte UNICODE format for text.  The base 
  format only uses the ASCII characters (first 128 UNICODE character codes).  UTF8 mainly comes into
  play with the string data being stored.</p>

  <p>The format is only somewhat human readable, and only somewhat text editor friendly, but it 
  really is not meant to be "human friendly."  What I mean is that you will be able to look at the
  format in a text editor (if the text editor is capable of handling really large files with really
  long lines) and if you know this format to a certain degree, you will be able to debug it.  To
  a certain degree you should be able to debug the binary version as well since it will not be too
  different than the text version.</p>

  <p>The format does not adhere to any line length limit.  So if you are using a text editor that
  does have line length limits you may end up corrupting the file or may not be seeing the whole
  file.</p>

  <p>All lines are terminated with a UNIX '\n'.  NOT an MSDOS \r\n or a MAC \n\r ending.  This is a
  strict rule.  If the file has \r\n or \n\r line endings then it is not a MIFF file.  No 
  exceptions.</p>

  <p>'\r' (Cursor Return) should not appear anywhere in the format unless writted explicitely as 
  '\', 'r'.  Meaning that it has been 'escaped' and that will only be in string values.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseTextWhitespace", "Whitespace Characters");</script>

  <p>A whitespace character is any character that does not make a blemish on a piece of paper if
  printed out; this includes control characters like bell, NULL, form feed, etc.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseTextSeparator", "Separator Characters");</script>

  <p>MIFF limits what white space characters can be used as separators.</p>

  <p>' ' (space), '\t' (Tab)</p>

  <p>If you see any other whitespace characters used as a separator in the MIFF file then the file
  is not MIFF.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseTextPrintable", "Printable Characters");</script>

  <p>Just to be clear what a printable character is.  If you had a blank piece of paper with just
  one character on it, if the character makes a mark, it is printable.  If it does not make a mark,
  it is not printable (like spaces, control characters, etc.)</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseTextKeyValue", "Key Value Format");</script>

  <p>The text file key value format looks like this.</p>

  <pre>[key] [value header] [value]\n</pre>

  <p>There can be leading separators before the [key] but these will be ignored.</p>

  <p>There has to be at least one separator between [key] and [value header].</p>

  <p>There has to be at least one separator between [value header] and the [value].</p>

  <p>Any extra separators in the line will be ignored.</p>

  <p>To terminate the key value pair use a single '\n' character.</p>

  <p>To be clear...</p>

  <p><strong>Valid:</strong> spaces and tabs can be used to indent and separate the parts.</p>

  <pre>\t\t[key]\t[value header]\t\t\t[value]\n</pre>

  <p><strong>Invalid:</strong>Absolutely no "\n" anywhere before or within the key value line*.  
  '\n' characters indicate a termination of a kv block so any extra '\n' characters will cause 
  problems.</p>

  <pre>
\n\n\n[key]\n[value header]\n[value]\n
 \n[key] [value header] [value]\n
</pre>

  <p>* There are cases where the [value] will be broken up by '\n' characters but this will be 
  indicated below.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseTextKeyValueKey", "Key");</script>
  
  <p>See MIFF Formate: Base / Content / Key Value Format / Key section for key information.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseTextKeyValueValueHeader", "Value Header");</script>

  <p>As defined above the value header is as follows</p>

  <pre>
[type flag][array and encoding flag] [array count] [compressed size]
</pre>

  <p>[type flag] and [array and encoding flag] is a string of 2 or 3 characters.</p>

  <p>If just the 2 letter [type flag] then the value is in readable UTF8 encoding.</p>
  <p>If combined with 'A' [array and encoding flag] then the value is an array of the given type.</p>
  <p>If combined with 'e' or 'E' then the value is treated as binary, reordered to be Big Endian and
  encoded into a string using base64.</p>
  <p>If combined with 'z' or 'Z' then the value is treated as binary, reordered to be Big Endian,
  compressed using zlib, and encoded into a string using base64.</p>

  <p>[array count] will be an unsigned integer value in readable UTF8 indicating how many values in
  the array.  Only present when A, E, and Z are used.</p>

  <p>[compressed size] will be an unsigned integer value in readable UTF8 indicating the raw, in 
  memory byte count of the compressed data.  Only present when z and Z are used.</p>

  <p>Examples: (adding \n to indicate the necessity of this line.)</p>

  <pre>
image g3z 64 64 [base64 zip compressed byte stream]\n

count n1 128\n

string ""t This is a string.\nThis is really a multiline string!\n

pointList PR 5 10.5 20 0 20.5 20 0 20.5 50 0 10.5 50 0 10.5 20 0\n
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseTextKeyValueValue", "Value");</script>

  <p>Some of the types are a bit more complex so they will have a specific representation in the 
  text file.</p>
  
  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseTextValue", "Value Specifics");</script>
  
  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseTextValueKeyValue", "Key-Value Block");</script>

  <p>Key-Value blocks are special.  They are needed to allow nesting of key values.  The last line
  of a block needs to be a comletely empty line with nothing on it but a \n to indicate that the
  block is terminated.</p>

  <pre>
docInfo kv\n
 title  "" M.I.F.F.: Mixed Information File Format\n
 author "" Robbert de Groot\n
\n
</pre>

  <p>To be clear on how it works.  Leading separators before the key are unnecessary and are only 
  here for clarity.  Leading separators before a \n are allowed but are wasteful.</p>

  <pre>
level1 kv\n
 level2 kv\n
  level3 kv\n
   ...
  \n
  anotherLevel3 kv\n
  \n
 \n
 anotherLevel2 kv\n
 \n
\n
anotherLevel1 kv\n
...
\n
</pre>

  <p>Key value bocks can have an 'A' array specifier and a array count.  This is useful for an array
  of a complex type.</p>

  <pre>
itemList kvA 2\n
 item kv\n
  name ""t item A\n
  value i4t 0\n
 \n
 item kv\n
  name ""t item B\n
  value i4t 10\n
 \n
\n
</pre>

  <p>e, E, z, and Z are never used with kv in text mode.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseTextValueString", "\"\"");</script>

  <p>String values are sort of the odd one out with all the other data types.  The other data types
  have a known size based on their input while strings are variable in size.  So encoding them will
  be slightly different.</p>
  
  <p>No encoding flag, all strings will have their cursor return and line feed characters replaced 
  with \r and \n respectively when written to the file.  If your string already has a \r and \n 
  inside then the slash will be escaped, \\r and \\n respectively, so that they do not get converted
  when reading them back in.  Other slash character pairs will not need escaping.</p>
  
  <p>Even though \n is strictly followed for the text format, we convert \r as well because text
  editors will attempt to honor \r or complain about inconsistent line endings and mess things up.</p>
  
  <p>Strings are placed on one line even if they define a multi-line string.  With the above 
  replacement of cursor return and line feeds this can be done.</p>
  
  <p>Unlike other data types, there can only be 1 separator between the value header and the start
  of the first string.  If there exists more than one separator then the extra separators are part
  of the string.</p>
  
  <p>'A' array flag, the individual strings will reside on their own line.  Meaning, as soon as a
  string is finished '\n' will immediately follow.  There will be as many lines as there are array
  elements.</p>

  <p>For an array of strings, the first character of the the next line will be the start of the 
  first string in the array.  The line after that will be the second string.  No lines will have any
  leading spaces.  Any space visible is part of the string.</p>

  <p>'e' encoding, the string is converted to base64 directly without any \r and \n modifications.</p>
  
  <p>'z' encoding, the string is compressed first before converting to base64.</p>
  
  <p>'E' and 'Z' encoding, unlike 'A', the string array is treated as one big buffer separated by
  NULL values and then compressed and converted to base64.</p>

  <pre>
string "" This is a single string value.\nBut multiline. Only \\r and \\n need escaping and not other \s in the string\n

stringList ""A 3\n
This is string 1, line 1.\\r\\nThis is line 2.\\r\\n\n
This is string 2.\n
This is string 3.\n

stringList ""e 7342jlafnpi23uq9==

stringList ""Z afkj8u234123234dfjaee...
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseTextValueBasic", "a*, A*, c*, C*, d*, i*, m*, M*, n*, p*, P*, r*");</script>

  <p>Types az, ad, Ad, A%, A:, c3, c4, C3, C4, dd, d%, d:, i1, i2, i4, i8, mr, mR, Mr, MR, n1, n2, 
  n4, n8, pi, pI, pn, pN, pr, pR, Pi, PI, Pn, PN, Pr, PR, r4, r8 are all very simple in 
  representation.  With no encoding flag...</p>

  <table>
   <tr> <th>Type Code</th>                          <th>Representation (No encoding flag)</th></tr>
   <tr> <td>az, ad, co, Co, dd, d%, d:, i1, i2, i4, i8, id, ix, Ix, n1, n2, n4, n8, of, Of, r4, r8, sz, Sz</td> <td>1 UTF8 readable number</td> </tr>
   <tr> <td>pr, pR, pi, pI, pn, pN, Ad, A%, A:</td> <td>2 UTF8 readable numbers separated by at least one separator.</td> </tr>
   <tr> <td>Pr, PR, Pi, PI, Pn, PN, c3, C3    </td> <td>3 UTF8 readable numbers separated by at least one separator.</td> </tr>
   <tr> <td>mr, mR                            </td> <td>9 UTF8 readable numbers separated by at least one separator.  Columns written out left to right before moving to the next row.  Rows written out top to bottom.</td> </tr>
   <tr> <td>Mr, MR                            </td> <td>16 UTF8 readable numbers separated by at least one separator.  Columns written out left to right before moving to the next row.  Rows written out top to bottom.</td> </tr>
   <tr> <td>c4, C4                            </td> <td>4 UTF8 readable numbers separated by at least one separator.</td> </tr>
  </table>

  <p>If using 'A' array flag the above is repeated as many times as there are array elements.  Each
  array element will be separated by at least one separator.</p>

  <table>
   <tr> <th>Type Code</th>                                                  <th>Representation (e encoding flag)</th></tr>
   <tr> <td>az, ad, co, Co, dd, d%, d:, i1, i2, i4, i8, id, ix, Ix, n1, n2, n4, n8, of, Of, r4, r8, sz, Sz</td> <td>Values are converted to Big Endian, then encoded into a string using base64.</td> </tr>
   <tr> <td>pr, pR, pi, pI, pn, pN, Ad, A%, A:                        </td> <td>Values are converted to Big Endian, then encoded into a string using base64.  No separation of the 2 numbers.</td> </tr>
   <tr> <td>Pr, PR, Pi, PI, Pn, PN, c3, C3                            </td> <td>Values are converted to Big Endian, then encoded into a string using base64.  No separation of the 3 numbers.</td> </tr>
   <tr> <td>mr, mR                                                    </td> <td>Values are converted to Big Endian, then encoded into a string using base64.  No separation of the 9 numbers.  Columns written out left to right before moving to the next row.  Rows written out top to bottom.</td> </tr>
   <tr> <td>Mr, MR                                                    </td> <td>Values are converted to Big Endian, then encoded into a string using base64.  No separation of the 16 numbers.  Columns written out left to right before moving to the next row.  Rows written out top to bottom.</td> </tr>
   <tr> <td>c4, C4                                                    </td> <td>Values are converted to Big Endian, then encoded into a string using base64.  No separation of the 4 numbers.</td> </tr>
  </table>
  
  <p>A: and d:, the ratio for the dip portion is 1 : [value].  [value] is what is stored.  It is an r4 value.</p>
  
  <p>C3 and C4, the values are r4 and range between 0.0 and 1.0.</p>
  
  <p>If using 'E' array flag the values are encoded into base64 all together and not separated by 
  any spaces.</p>
  
  <p>If using 'z' or 'Z' encoding flag, take the 'e' or 'E' data buffer, compress it using zlib and
  then write out the base64 string representation of the compressed buffer.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseTextValueBinary", "bi");</script>

  <p>The binary data will have a header of 1 unsigned integer value before the binary data.  This
  value indicates the byte count of the binary data.  This byte count is not included when using
  Base64 ro Zlib compression.  However the binary data will honor Base64 and Zlib compression if
  used.</p>

  <pre>
image bn 10 0 1 2 3 4 5 7 8 9\n

image bnA 2\n
10 0 1 2 3 4 5 6 7 8 9\n
10 9 8 7 6 5 4 3 2 1 0\n
</pre>

  <p>Binary blobs are dangerous and should be used rarely if at all.  If someone uses them then they
  should be on the hook to define what the contents of the blob mean.  If they do not, then they are
  being bad citizens and should be shamed!</p>
  
  <p>However this is here as a catchall just in case.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseTextValueBool", "bo");</script>

  <p>Boolean data is a little different than the basic types above.</p>
  
  <p>No encoding flag, the value will be 't' for true, or 'f' for false.</p>
  
  <p>'A' encoding flag, the value will be a string of 't' or 'f' letters with no separator in between
  to save some space.</p>
  
  <p>'E' encoding flag will mean the flags are encoded in to a bit map where...</p>

  <pre>
Byte 0                            Byte 1
+---+---+---+---+---+---+---+---+ +---  ...
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | | 8
+---+---+---+---+---+---+---+---+ +--- ...
 2^7 2^6 ...                 2^0   2^8 ...                   
</pre>
  <p>
   0, 1, 2, ... indicates the index into the array and how it relates to the bytes.  So each bit 
   will either be 1 (true) or 0 (false).  This byte stream then gets converted to base64.
  </p>
  
  <p>'Z' will take the above bitmap and compress it first before encoding it with base64.</p>
  
  <p>'e' and 'z' encoding flags are never used with this type.</p>
  
  <pre>
IsFaceVisible bo t\n
IsOptimized bo f\n
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseTextValueGraphic", "g*, G*");</script>

  <p><strong>g3, g4, G3, G4</strong></p>

  <pre>[g3|g4|G3|G4] [pixel count with] [pixel count height] [pixel buffer]</pre>
  
  <p>g3, g4, G3, G4 graphic options will have a header of 2 unsigned integer values before the image
  data.  These values indicate width and height of the graphic.  These values are not included in 
  the Base64 or Zlib compression if compression is used.  However the image data will honor Base64 
  or Zlib compression if used.</p>
  
  <p>Images are written out row by row, left to right, top to bottom.</p>
  
  <p>Array of graphics will place each graphic on a separate line similar to string encoding.</p>

  <pre>
image g3 2 2 0 0 0 64 64 64 128 128 128 192 192 192\n

image g3A 2\n
2 2 0 0 0 64 64 64 128 128 128 192 192 192\n
2 2 64 64 64 128 128 128 192 192 192 255 255 255\n
</pre>

  <p><strong>gf</strong></p>
  
  <pre>gf [three letter file format] [file size] [file data]</pre>

  <p>gf graphic option will have a 3 letter image identifier for the file type, an unsigned integer 
  for the file size, and then the file that represents the image, copied verbatum into the value 
  portion.  There is never any compression applied.  The data is always base64 encoded.  e, E, z, 
  and Z are never used.</p>

  <pre>
imageFile gf png 1024 [base64 encoding of a png file data]\n

imageFileList gpA 2\n
jpg 2048 [base64 encoding of a jpg file 1 data]\n
tif 4096 [base64 encoding of a tiff file 2 data]\n
</pre>

  <p><strong>gl</strong></p>
  
  <pre>gl [string of path to file]</pre>

  <p>gl graphic option simple contains a link to an image file.  This path should be relative to the
  MIFF file if not right next to the MIFF file.  However this is up to the software writing the MIFF
  file.  z, and Z are never used for this type.</p>

  <pre>
imageFileLink gl \path\to\image\file\image.png\n

imageFileLinkList glA 2\n
\path\to\image\file\image1.png\n
\path\to\image\file\image2.png\n
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseTextValueTime", "ty");</script>

  <p>ty stores a 2 letter type format.  Used for describing what something external to the base 
  format will store as a value.</p>
  
  <pre>ty [2 letter type value]</pre>
  
  <pre>
type ty PR
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseTextValueTime", "t*");</script>

  <p>td, tt, t* store time values.</p>
  
  <pre>
td [date]
tt [time]
t* [date] [time]
</pre>
  
  <p>[date] values are only stored one way in readable UTF8, "YYYY-MM-DD" where YYYY, MM, DD are 
  unsigned integers.  MM and DD are 0 padded.</p>
  
  <p>[time] values are only stored one way in readable UTF8, "HH:MM:SS" where HH, MM, SS are 
  unsigned integers.  HH is 24 hour Greenwich Time zone, no daylights correction.</p>
  
  <p>Binary representation if encoded as base64 will be n2 for year and n1 for all other values and
  ordered in the same year, month, day, hour, minute, second.</p>

  <pre>
date t* 2019-01-31 20:30:40\n
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseTextValueValueStream", "vs");</script>
  
  <p>A Value Stream is a departure of the base format.  It is meant to be used to compress the data
  storage more with a simpler key value structure which will be dictated by the format that uses 
  MIFF as a base format.</p>
  
  <p>Keys will typically be 1 byte.  Values will be a known sized based on the key or other 
  information of the format.</p>
  
  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formatBaseBinary", "Binary");</script>

  <p>The Binary file will to match the Text file 1-1.  Everything within '[]' is a byte sequence of
  a known size.  Each byte seqence is separated here with a comma but is immediately following after
  previous byte sequence.</p>
  
  <p>A byte sequence is [[size]:[name]], where size is a number indicating the number of bytes this
  sequence takes up.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseBinaryKeyValue", "Key Value Format");</script>

  <pre>
[1:key string length],[key string length:key],[3:value header],[4;array count],[4:compress buffer size],[*:value]
</pre>

  <script>HeaderAdd(4, "formatBaseBinaryKeyValueKey", "Key");</script>
  
  <p>[key string length] is the first byte sequence and defines how long the key string is in bytes.
  </p>
  
  <p>[key] is the second byte sequence and defines the key of the key value pair.  The length of
  which was defined by [key string lenght] above.  This means keys can not exceed 255 bytes.  No 
  null terminator is used for the key.</p>
  
  <script>HeaderAdd(4, "formatBaseBinaryKeyValueValueHeader", "Value Header");</script>
  
  <p>[value header] is the third byte sequence and is 3 bytes.  2 bytes for the value type 2 letter 
  identifier and 1 bytes for the array and encoding letter.  See MIFF Format: Base / Content / Value
  Header section for an explanation.</p>
  
  <p>e, and E are never used in binary mode.  The data is stored raw and no encoding is actually 
  done.</p>
  
  <p>' ' is used for an uncompressed single value.</p>
  
  <p>'A' is used for an uncompressed array of values.</p>
  
  <p>z and Z will apply Zlib compression to the binary data.</p>
  
  <p>[array count] and [compress buffer size] are only present when certain value header conditions
  are present.  Meaning [array count] byte sequence is only present when storing an array of values;
  [compress buffer size] is only present when the value is compressed with zlib compression 
  routines.  If neither of these are present in the value header then these byte sequences are not 
  present.</p>
  
  <p>Both [array count] and [compress buffer size] are 4 byte unsigned integers stored in network
  order.</p>
  
  <script>HeaderAdd(4, "formatBaseBinaryKeyValueValue", "Value");</script>
  
  <p>[value] field will vary wildly depending on the [value header], [array count], and [compress
  buffer size] values.  But it will be a known size given that information.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatBaseBinaryValue", "Value Specifics");</script>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseBinaryValueKeyValue", "Key-Value Block");</script>

  <p>This indicates the start of a Key-Value block.  There technically is no value.  The next byte 
  after the [value header] is the start of the first key in the block.</p>
  
  <p>A block is terminated when the [key string length] is equal to 0.</p>

  <pre>
[8],["itemList"],["kv "],
[> 0 key string length],...
[> 0 key string length],...
[> 0 key string length],...
[0]
</pre>

  <p>Hopefully the above explains it.  I have defined an "itemList" key which starts the key value
  block.  If the next key value has a key string length that is > 0 then it is part of the itemList
  key value block.  The last key string length is 0 which indicates that the block is done.  
  Anything that follows the block is a new key value thing.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseBinaryValueString", "\"\"");</script>

  <p>String encoding is simpler than in the text case.</p>

  <pre>[4:string length][string length:string]</pre>

  <p>Each string is prefixed with a [string length], the byte count of the UTF8 string.  Then you
  just dump out the string in UTF8 format.</p>
  
  <p>Array of strings will have as many of these pairs as found in the array.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseBinaryValueString", "a*, A*, c*, C*, d*, i*, m*, M*, n*, p*, P*, r*");</script>
  
  <p>Simple value encoding.  Based on what is being stored the byte streams only look slighly 
  different.</p>
  
  <table>
   <tr><th>Type</th><th>Byte Count</th></tr>
   <tr><td>i1, n1                                    </td><td>  1</td></tr> 
   <tr><td>i2, n2                                    </td><td>  2</td></tr>
   <tr><td>c3                                        </td><td>  3 (3 x 1 Byte)</td></tr>
   <tr><td>az, ad, dd, d%, d:, i4, ix, n4, r4, of, sz</td><td>  4</td></tr>
   <tr><td>c4                                        </td><td>  4 (4 x 1 Byte)</td></tr>
   <tr><td>i8, Ix, n8, r8                            </td><td>  8</td></tr>
   <tr><td>Ad, A%, A:, pr, pi, pn                    </td><td>  8 (2 x 4 Byte)</td></tr>
   <tr><td>c4, Pr, Pi, Pn                            </td><td> 12 (3 x 4 Byte)</td></tr>
   <tr><td>pR, pI, pN                                </td><td> 16 (2 x 8 Byte)</td></tr>
   <tr><td>PR, PI, PN                                </td><td> 24 (3 x 8 Byte)</td></tr>
   <tr><td>C4                                        </td><td> 32 (4 x 8 Byte)</td></tr>
   <tr><td>mr                                        </td><td> 36 (9 x 4 Byte)</td></tr>
   <tr><td>Mr                                        </td><td> 64 (9 x 8 Byte)</td></tr>
   <tr><td>mR                                        </td><td> 72 (16 x 4 Byte)</td></tr>
   <tr><td>MR                                        </td><td>128 (16 x 8 Byte)</td></tr>
  </table
  
  <p>The values are simply encoded as such.</p>
  
  <pre>[bytes count:value]</pre>
  
  <p>Again, multi-byte values are store in big endian (network order).</p>
  
  <p>Arrays of these values are simply repeating the above as many times necessary for the array.</p>
  
  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseBinaryValueBinary", "bi");</script>

  <p>
   Binary encoding is like string encoding.  We need a byte count before the buffer data.
  </p>

  <pre>
[4:byte count][byte count:buffer data]
</pre>

  <p>
   byte count will never be compressed when compression is used but buffer data will.
  </p>
  <p>
   Array of binaries will have as many of these pairs as found in the array.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseBinaryValueBool", "bo");</script>

  <p>Boolean data is a little different than the basic types above.</p>
 
  <p><strong>Single Value</strong></p>
  
  <pre>[1:Byte]</pre>
  
  <p>The value will be 't' for true, or 'f' for false.</p>
  
  <p><strong>Array of Values</strong></p>
  
  <pre>[(Array Count) / 8:Bytes]</pre>
  
  <p>'A' encoding flag will mean the flags are encoded in to a bit map where...</p>

  <pre>
Byte 0                            Byte 1
+---+---+---+---+---+---+---+---+ +---  ...
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | | 8
+---+---+---+---+---+---+---+---+ +--- ...
 2^7 2^6 ...                 2^0   2^8 ...                   
</pre>

  <p>0, 1, 2, ... indicates the index into the array and how it relates to the bytes.  So each bit 
  will either be 1 (true) or 0 (false).  This byte stream then gets converted to base64.</p>
  
  <p>'Z' will take the above bitmap and compress it first before encoding it with base64.</p>
  
  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseBinaryValueGraphic", "g*, G*");</script>

  <p><strong>g3, g4, G3, G4</strong></p>

  <pre>
[4:width][4:height][width * height * size of [c3|c4|C3|C4]:graphic data]
</pre>

  <p>Raw graphic data size will be (unsigned integer) width * (unsigned integer) height * size of 
  the color item.  It will be the compressed size in the file if compression is used but the raw
  size in memory.</p>

  <p><strong>gf</strong></p>

  <pre>[4:image file size][image file size:binary buffer of the image file]</pre>

  <p><strong>gf</strong></p>

  <pre>[4:string length][string length:file path]</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseBinaryValueType", "ty");</script>
  
  <pre>[2:1 letter Type Identifier]</pre>
  
  <p>The two letter identifier as defined in MIFF Format: Base / Content / Key Value Format / Value 
  Header Section</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseBinaryValueTime", "t*");</script>

  <p>td, tt, t* store time values.</p>
  
  <pre>
td = [n2:Year Value][n1:Month Value][n1:Day Value]
tt = [n1:Hour Value][n1:Minute Value][n1:Second Value]
t* = [n2:Year Value][n1:Month Value][n1:Day Value][n1:Hour Value][n1:Minute Value][n1:Second Value]
</pre>
  
  <p>Year value is the present year as is.  Month value is the month value starting at 1 being 
  January.  Similarly Day starts at 1.</p>
  
  <p>Hour value is 24 hour Greenwich Time zone, no daylights correction starting at 0.  Minute and
  Second are both starting at 0.</p>
  
  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatBaseBinaryValueValueStream", "vs");</script>
  
  <p>A Value Stream is a departure of the base format.  It is meant to be used to compress the data
  storage more with a simpler key value structure which will be dictated by the format that uses 
  MIFF as a base format.</p>
  
  <p>Keys will typically be 1 byte.  Values will be a known sized based on the key or other 
  information of the format.</p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "formatBaseDesign", "Design Decisions:");</script>

  <p><strong>Why not XML or JSON?</strong><br />
  I did not take XML as a format because it is too verbose.  JSON is very flexible but I also find
  it is still unnecessarily verbose.  Better than XML but still unacceptable in my opinion.  
  Considering the data, I do not want a format that would cause too much data bloat.  There will
  always be some bloat happening but it should be mitigated in my opinion.</p>

  <p><strong>Why network order for multibyte data types?</strong><br />
  In the past my company was multi-platform, SGI IRIX, SUN OS, SUN Solaris and Windows NT.  At that
  time the architecture on some of the other platforms was Big Endian and we stored the data in the
  native format of the machine.  However this lead to issues when users moved their data over to a
  Little Endian machine which Windows has always been.  The problems that we faced were trivial to
  solve but just very annoying and yet anothering thing to remember.  So standardizing on one option
  is easier than having to support two options.  I go with simplicity, only one option to rule them 
  all!  It keeps things simpler.</p>
  

  <script>UpdateToc();</script>

 </body>
</html>
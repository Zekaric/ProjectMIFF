H	M.I.F.F.: Mixed Information File Format

	|b ||. |Author:            | .|| b| Robbert de Groot
	|b ||. |Date:              | .|| b| 2019-05-15
	|b ||. |Copyright:         | .|| b| 2019, Robbert de Groot
	|b ||. |License (Library): | .|| b| MIT License.
	|b ||. |License (Document):| .|| b| Creative Commons Attribution-NoDerivs.|link |https://creativecommons.org/licenses/by-nd:4.0| link |(CC BY-ND)| link|

HH	Table Of Contents:

toc


h	|chapter| - M.I.F.F.


hh	|chapter| - Discussion

	What is the purpose of M.I.F.F. (MIFF)?  MIFF is intended to be a simple file format for storing data.  Any data.  And large amounts of data without being too fat.


hh	|chapter| - Goals

:[
-	|b |Simple  | b|  The format should be simple for the developers to export their data and still be fairly simple to re-import that data.
-	|b |Brief   | b|  The format should not produce unnecessary waste.  The data in some cases will be quite large so it should not bloat the data too much.  Meaning, file sizes should not become overly large.  However, because of point 1 there will always be some bloat.
-	|b |Flexible| b|  The format needs to be able to accomodate change or specific data.  As years go by, software will also change and requirements will change.  The format needs to try its best to keep up without importers and exporters to be completely remade.
-	|b |Accurate| b|  The format needs to be able to maintain accuracy of the data.  Namely floating point values.  The in memory value when exported should be reimported without any change.
]

hh	|chapter| - Design Decisions:

	|b |Why not XML or JSON?| b|
	I find XML is too verbose.  JSON is much better than XML and is a reasonable alternative to XML.  Both are very flexible but that can be a double edged sword.  I feel there should be something better.  I do not claim MIFF is better, it is just different.
	|b |Why Big Endian for multibyte data types?| b|
	In the past my company was multi-platform, SGI IRIX, SUN OS, SUN Solaris and Windows (NT/2000/XP/etc.)  At that time the architecture on some of the other platforms was Big Endian and we stored the data in the native format of the machine.  However this lead to issues when users moved their data over to a machine with a different Endian.  The problems that we faced were trivial to solve but were very annoying and yet anothering thing to remember.  So standardizing on one option is easier than having to support two options.  I go with simplicity, only one option to rule them all!  It keeps things simpler even if it does mean a potential performance hit for a platform.  This format is not meant to be good in performance; its main goal is to be good in getting data moved from one place to another.


hh	|chapter| - Disclosure

	I, Robbert de Groot, have been a professional Software Developer since 1995.
	This format is currently not sanctioned by any software vendor.  This was an attempt on developing something in place of existing or developing options which I find lacking or distasteful in some fashion.
	I can be reached at the following email address.
	zekaric@gmail.com


h	|chapter| - Format: Base

	There are two representations of the format.  A Text file representation and a Binary file representation.  They will both contain exactly the same data and be exactly the same in feature set.  The Binary file may have the advantage of possibly being slightly more compact and slightly faster in reading and writing.
	A MIFF format is essentially a collection of key value pairs.  Values are typed.  Nesting and user types are allowed.
	The intent with this format is to make only one read pass over the file.  There is no focus on making the file randomly accessable or modifiable.  This format is not intended as a substitute for native formats for any software package.  This is meant to be a transfer file format to move data from one program to another.
	Common to both Text and Binary formats, any Byte data that is encode or stored as a binary byte sequence will be in big endian order.  In a text file the data is stored in Base64 like encoding.


hh	|chapter| - File Header

	There will always be a file header so that you can be sure the file you recieved is actually a MIFF file and not some other file.

.	MIFF \t 1 \t TXT \t [Sub-Format Name string] \t [Sub-Format Version string] \n

//		or
//	
//	.	MIFF \t 1 \t BIN \t [Sub-Format Name string] \t [Sub-Format Version string] \n

	 \t means a tab character.  \n means a new line character.  The spaces above around the \t and \n are only present to make the line easier to read but in an actual MIFF file there are no spaces there.

:[
-	|b |Line 1| b| - Format of the file.  MIFF.
-	|b |Line 2| b| - Version of the file.  Version 1.
-	|b |Line 3| b| - Representation of the file.  TXT for text, or BIN for binary. 
-	|b |Line 4| b| - Sub-Format name.  A MIFF file is potentially a container for an sub format of the file.
-	|b |Line 5| b| - Sub-Format version identifier.
]

	If the representation is Binary then right after the \n of the fifth line, the binary format will begin.
	If a sub-format name exists it is not limited to any characters.  A MIFF header is in UTF8 format always.  The only limit to the format name is that it can not be longer than 255 bytes in length and it cannot contain tabs (\t) or new lines (\n).  If there are leading and trailing spaces, then that is part of the format name as silly as that may sound.  Spaces internal to the format name are also allowed and are significant.  I say 255 bytes instead of characters because in UTF8 one character/codepoint can span multiple bytes.  So this name can not exceed this byte size.
	Binary files will be explored at a later date.


hh	|chapter| - Content

	Before going into the specifics of the format we will cover some things at a high level.

//	hhh	|chapter| - Binary Syte Sequences
//	
//		Everything within "[]" is a byte sequence of a known size.  Each byte seqence is separated but in reality it is immediately following the previous byte sequence.  Nothing extra is added between sequences.
//		A byte sequence is "[" [Byte count] ":" [Name of this Byte sequence] "]", where Byte count is a number indicating the number of bytes this sequence uses.

hhh	|chapter| - Numbers

	|b |Natural numbers| b| (unsigned integers for programmers) are whole numbers ranging from 0 to some positive max value.
	|b |Integer numbers| b| are numbers are positive and negative whole numbers.
	|b |Real numbers   | b| (floating point numbers for programmers) are positive and negative numbers that may not be whole.  I.E. PI, 3.14159, is a Real number.

hhh	|chapter| - Record Composition

	A record basically defines a key - value pair.  However the composition of that record is composed of a few parts.
	
	|b |[key]             | b| will be a string that will somewhat uniquely identify the value.  
	|b |[type code]       | b| will be a code (BIN) or sequence of characters (TXT) that will dictate what the value will look like as well as a compression setting and array size setting.
	|b |[array size]      | b| will be a number or special character to indicate the number of values of a particular type is associated with the key.
	|b |[compression flag]| b| will be a setting on how the value is compressed, if at all.
	|b |[value]           | b| will depend on the the other parts so it can vary in appearance.

hhhh	|chapter| - Key

	Keys are always a single string of any character in UTF8 encoding as long as none are \t and \n.  Whitespace, leading, trailing, and internal to the key string are significant and cannot be trimmed or thinned out.  Keys are limited to being 255 bytes long.  In UTF8 that may not mean 255 letters/characters as some characters may end up requiring more than 1 byte.  I would suggest to limit the whitespace to just " " and nothing else.  Everything else should be a printable character.  We do not need another "Whitespace Language" monster.

.[
12345
;':][.,<>]'
a_b_c
$cost
été
This is also a valid key with internal spaces
]


hhhh	|chapter| - Type Code

t[
//	thx	Binary Type Code
thx	Text Type Code
th*	Description

t-
//	tcx	0
//	tcx	.
//	tc	No value, presence or absence of a key is enough information.

t-
tcx	|line||b |Block Types| b||line|

t-
//	tcx	1
tcx	{
tc	Key-Value block begins.

t-
//	tcx	2
tcx	}
tc	Key-Value block ends.

t-
tcx	|line||b |Basic Types| b||line|

t-
//	tcx	3
tcx	type
tc	Type value.  One of these type codes or a user type code.

t-
//	tcx	4
tcx	define
tc	A series of key-type pairs.  You can define up to 4031 new types maximum.

t-
//	tcx	5
tcx	"
tc	String (UTF8) data, can be of any length.

t-
//	tcx	6
tcx	->
tc	A specific string value that represents a relative path (relative to the MIFF file location and no backsies "..", local directory or deeper directory.)

t-
//	tcx	7
tcx	b
tc	Boolean value.

t-
//	tcx	10   11   12   13   14   15    16    17    18     19   
tcx	i1 i2 i3 i4 i8 i16 i32 i64 i128 i256
tc	An integer number.  Min and Max value will depend on how much the Bytes can encode.  Yes I know there are no native types for some of these, like i3, but I include these byte counts because they may be useful in certain cases.

t-
//	tcx	20   21   22   23   24   25    26    27    28     29
tcx	n1 n2 n3 n4 n8 n16 n32 n64 n128 n256
tc	A natural number.  Ranges from 0 to max value.  Max value will depend on how much the Bytes can encode.  Yes I know there are no native types for a lot of these, like n3, but I include these byte counts because they may be useful in certain cases.

t-
//	tcx	31   33   34   35    36    37    38     39
tcx	r2 r4 r8 
//	r16 r32 r64 r128 r256
tc	A real value.  
//	I do realize there are no standards for r16 - r256 but these are just placeholders for the future if they ever become standard.

t-
tcx	|line||b |Embedded Types| b||line|

t-
//	tcx	40  41   42    43
tcx	* ** *** ****
tc	Binary data of n4, n8, n16, n32 byte counts in size.

t-
//	tcx	50    51     52      53  
tcx	[*] [**] [***] [****]
tc	An embedded file of n4, n8, n16, n32 byte counts in size.

t-
tcx	|line||b |User Tyes| b||line|

t-
//	tcx	64 and higher
tcx	[user type name]
tc	Depends on what the user type defines.  A define must exist first.

]


hhhh	|chapter| - Array Size

t[
//	thx	Encoding Code (Binary (aaa))
thx	Encoding Code (Text)
th*	Description

t-
//	tc	000
tc	1
tc	A single value follows.  In binary, no array size byte sequence follows.

t-
//	tc	001, 010, 011, 100, 101, 110
tc	[number of items]
tc	An array of values follows.  In binary, 001 means a 1 byte natural follows; 010 means a 2 bytes natural follows; 011 means a 3 byte natural follows; 100 means a 4 byte natural follows; 101 means an 8 byte natural follows; 110 means a 16 byte natural follows.

t-
//	tc	111
tc	*
tc	An array of values.  This is only ever used when defining a user type.  See User types.
]


hhhh	|chapter| - Compression Flag

t[
//	thx	Encoding Code (Binary (cc))
thx	Encoding Code (Text)
th*	Description

t-
//	tc	00
tc	-
tc	Values are inlined raw with no compression.

t-
//	tc	01
tc	.
tc	Values are compressed with zlib as one big chunk.

t-
//	tc	01
tc	:
tc	Values are broken down into smaller chunks and then each chunk compressed with zlib.

]


hhhh	|chapter| - Value

	See the types respective sections for details.


hh	|chapter| - Text Format

	The text format is a UTF8 text file.
	The format is only somewhat human readable, and only somewhat text editor friendly.  It was not designed to be "human friendly" but rather "debug friendly."  What I mean is that you will be able to look at the format in a text editor, if that text editor is capable of handling really large files with really long lines; and if you know this format, you will be able to debug it.  To a certain degree you should be able to debug the binary version as well since it will not be too different than the text version.
	The format does not adhere to any line length limit.  So if you are using a text editor that does have line length limits you may end up corrupting the file or you may not be seeing the whole file.
	All lines are terminated with a single '\n'.  NOT an MSDOS/Windows \r\n or a MAC \n\r or just a \r.  This is a strict rule.  If the file has \r\n, \n\r, or \r line endings then it is not a MIFF file.  No exceptions.


hhh	|chapter| - Whitespace Characters

	A whitespace character is any character that does not make a blemish on a piece of paper if printed out; this includes control characters like bell, NULL, form feed, etc.


hhh	|chapter| - Separator Characters

	MIFF only uses tab (\t) as a separater character.  And only one \t between fields.  Whitespace is not considered a separater character and will be part of a key or value if it is present.


hhh	|chapter| - Printable Characters

	Just to be clear what a printable character is.  If you had a blank piece of paper with just one character on it, if the character causes ink to be placed on the paper, it is printable.  If it does not make a mark, it is not printable (like spaces, control characters, etc.)

hhh	|chapter| - Base64

	A few items are stored in Base64.  This is to add a little compression to the items in question but mainly it is to ensure binary exactness of the data when writing the values out and reading the values back in.  Unlike normal Base64 which will break the buffer into lines of a certain length, Base64 values in a MIFF are one long continuous stream of characters.  No \n or line breaks of any kind will be present.

hhh	|chapter| - Real Number Representation

	All real numbers are stored as a Base64 string.  No exceptions.  This is to ensure that when read back into memory from file, the number is exactly as it was when it was stored in the file.  The real value in the MIFF file will be in Big Endian order.

hhh	|chapter| - Record Composition

.	[type code] \t [key] \t [array size] \t [compression flag] ...

	Any space found in the key that is not a \t will be part of the key.  They will be significant.  Do not strip or reduce them.
	There has to be one \t separator between each part.
	How the record terminates or appears after the [compression flag] can vary due to the configuration.
	
	To be clear...
	
	|b |Invalid:| b| Absolutely no "\n" anywhere before or within the key value line*.  Absolutely no blank lines.  Absolutely no extra \t anywhere in the format.

.[
\t[type code] [key]\n[array size] [compression flag]\t[value]\n
]

	* There are cases where the [value] will be broken up by '\n' characters but this will be indicated where that will happen.  In general most key value lines live on a single line.
	Values will be discussed lower in section 3.


//	hh	|chapter| - Binary
//	
//		The Binary file will to match the Text file 1-1.  
//		
//	hhh	|chapter| - Key Value Format
//	
//	.[
//	[n1           :key size]
//	[n1 * key size:key]
//	[*            :value header]
//	[*            :value]
//	]
//	
//	hhhh	|chapter| - Key
//	
//		[key size] defines how long the key is in bytes.  Keys are 1 to 255 Bytes and the Bytes define a UTF8 string.
//		[key] defines the key of the key value pair.  The length of which was defined by [key size] above.  No null terminator is included in the key.
//	
//	
//	hhhh	|chapter| - Value Header
//	
//		Value header will typically look like this.
//	
//	.[
//	[n2:2 bit - compression flag, 3 bit - array flag, 11 bit - type code]
//	[0,n1,n2,n3,n4,n8,n16:array size]
//	]
//		The first 2 bytes holds the type code and array and compression flags.  The 5 high bits of this value are holding the array and compression flags.  The remaining 11 bits are for the type code.  See section on Type Codes, array size Flag and Compression Flag earlier in this document for what the type code and flags should equal to.
//		[array size] byte sequence is only present when storing an array of values.
//	
//	
//	hhhh	|chapter| - Value
//	
//		[*:value] field will vary wildly depending on the [value header].  But it will be a known size given all that information.




h	|chapter| - Fromat: Value Specifics


//	hh	|chapter| - Key only
//	
//		Just a key and no value.  Just like the header lines of the file.
//		
//	.[
//	Binary                                                     Text
//	
//	[n1           :key size]                                   [key]\n
//	[n1 * key size:key]                                        [key]\t.\n
//	[n2           :value header - 00|000|0]
//	]
//		
//		In text, either line will do.  The first line saves 2 bytes.


hh	|chapter| - Key-Value Block Begin and End.

	Key-Value blocks are special.  They are needed to allow nesting of key values.  
	In a text file, the last line of a Key-Value Block needs to be a comletely empty line with nothing on it but a \n to indicate that the block is terminated.
	In a binary file you will have a key size of 0 to indicate the end of a Key-Value block.

.[
{ \t [key] \n
...
} \n

{ \t [key] \t [array size] \n
...
} \n
]

//	.[
//	Binary                                                     Text
//	
//	[n1           :key size]                                   [key]\t{\n
//	[n1 * key size:key]                                        ...
//	[n2           :value header   - 00|000|1]                  \t}\n
//	...                                                        
//	[n1           :0]                   
//	[n2           :value header   - 00|000|2]
//	
//	[n1           :key size]                                   [key]\t{\t[array size]\n
//	[n1 * key size:key]                                        ...
//	[n2           :value header   - 00|???|1]                  
//	[???          :array size]
//	...
//	]
//	
	Key value bocks can have an array size.  What that will mean is that there are [array size] key value pairs following.  The next key value pair after the last key value will not belong to this block.
	A block is terminated when a value type of "}" is reached or array size key values have been read.  The key for this line, if present, will be ignored.  So it should really be empty to save space.  Every begin requires an end, there must not be extras of each in the file.
	Compression flags are never used with this value type.

.[
{ docInfo\n
...
}\n

{ level1\n
{ level2\n
{ level3\n
...
}\n
{ anotherLevel3\n
...
}\n
}\n
{ anotherLevel2\n
...
}\n
}\n
{ anotherLevel1\n
...
}\n

{ itemList 2\n
{ item\n
...
}\n
{ item\n
...
}\n
}\n
]

//	.[
//	Binary                                                     Text
//	
//	[n1     :7]                                                docInfo\t{\n
//	[n1 * 7 :docInfo]                                          ...
//	[n2     :00|000|1]                                         \t}\n
//	...                                                        
//	[n1     :0]                   
//	[n2     :00|000|2]
//	
//	[n1     :6]                                                level1\t{\n
//	[n1 * 6 :level1]                                           level2\t{\n
//	[n2     :00|000|1]                                          level3\t{\n
//	[n1     :6]                                                ...
//	[n1 * 6 :level2]                                           \t}\n
//	[n2     :00|000|1]                                          anotherLevel3\t{\n
//	[n1     :6]                                                ...
//	[n1 * 6 :level3]                                           \t}\n
//	[n2     :00|000|1]                                          \t}\n
//	...                                                        anotherLevel2\t{\n
//	[n1     :0]                                                ...
//	[n2     :00|000|2]                                         \t}\n
//	[n1     :13]                                               \t}\n
//	[n1 * 13:anotherlevel3]                                     anotherLevel1\t{\n
//	[n2     :00|000|1]                                         ...
//	...                                                        \t}\n
//	[n1     :0]                                                
//	[n2     :00|000|2]
//	[n1     :0]                                                
//	[n2     :00|000|2]
//	[n1     :6]                                                
//	[n1 * 6 :anotherlevel2]                                    
//	[n2     :00|000|1]                                            
//	...                                                        
//	[n1     :0]                                                
//	[n2     :00|000|2]
//	[n1     :0]                                                
//	[n2     :00|000|2]
//	[n1     :6]                                                
//	[n1 * 6 :anotherlevel1]                                    
//	[n2     :00|000|1]                                            
//	...                                                        
//	[n1     :0]                                                
//	[n2     :00|000|2]
//	
//	[n1     :8]                                                itemList\t{\t2\n
//	[n1 * 8 :itemList]                                         item\t{\n
//	[n2     :00|001|1]                                         ...
//	[n1     :2]                                                \t}\n
//	[n1     :4]                                                item\t{\n
//	[n1 * 4 :item]                                             ...
//	[n2     :00|000|1]                                         \t}\n
//	...     
//	[n1     :0]
//	[n2     :00|000|2]
//	[n1     :4]
//	[n1 * 4 :item]
//	[n2     :00|000|1]
//	...     
//	[n1     :0]
//	[n2     :00|000|2]
//	]


hh	|chapter| - Binary values

.[
* \t [key] \t 1 \t - \t [binary size] \t [Base64 binary data]\n

* \t [key] \t 1 \t . \t [binary size] \t [compressed size] \t [Base64 compressed data]\n

* \t [key] \t 1 \t : \t [binary size] \t [chunk byte count] \n
[compressed size] \t [Base64 compressed data] \n
[compressed size] \t [Base64 compressed data]\n
...

** \t [key] \t [array size] \t -\n
[binary size] \t [Base64 binary data] \n
[binary size] \t [Base64 binary data] \n
...

** \t [key] \t [array size] \t . \n
[binary size] \t [compressed size] \t [Base64 compressed data] \n
[binary size] \t [compressed size] \t [Base64 compressed data] \n

** \t [key] \t [array size] \t : \t [chunk byte count]\n
[binary size] \n
[compressed size] \t [Base64 compressed data] \n
[compressed size] \t [Base64 compressed data]\n
...
[binary size] \n
[compressed size] \t [Base64 compressed data]\n
...
]

//	.[
//	Binary                                                     Text
//	
//	[n1                  :key size]                            [key] \t "*" \t "1" \t "-" \t[binary size] \t [Base64 binary data]\n
//	[n1 * key size       :key]     
//	[n2                  :value header - 00|000|3]      
//	[n4                  :binary size]          
//	[n1 * binary size    :binary data]         
//	
//	[n1                  :key size]                            [key] \t "*" \t [array size] \t "-"\n
//	[n1 * key size       :key]                                 [binary size] \t [Base64 binary data] \n
//	[n2                  :value header - 00|???|3]             [binary size] \t [Base64 binary data] \n
//	[n4                  :array size]                         ...
//	[n4                  :binary size]          
//	[n1 * binary size    :binary data]         
//	[n4                  :binary size]          
//	[n1 * binary size    :binary data]         
//	...                        
//	
//	[n1                  :key size]                            [key] \t "*" \t "1" \t "." \t [binary size] \t [compressed size] \t [Base64 compressed data]\n
//	[n1 * key size       :key]     
//	[n2                  :value header - 01|00|3]       
//	[n4                  :binary size]          
//	[n4                  :compressed size]         
//	[n1 * compressed size:compressed data]
//	
//	[n1                  :key size]                            [key] \t "*" \t [array size] \t "." \n
//	[n1 * key size       :key]                                 [binary size] \t [compressed size] \t [Base64 compressed data] \n
//	[n2                  :value header - 01|???|3]             [binary size] \t [compressed size] \t [Base64 compressed data] \n
//	[???                 :array size]          
//	[n4                  :binary size]          
//	[n4                  :compressed size]        
//	[n1 * compressed size:compressed data]
//	[n4                  :binary size]          
//	[n4                  :compressed size]        
//	[n1 * compressed size:compressed data]
//	...
//	
//	[n1                  :key size]                            [key] \t "*" \t "1" \t ":" \t [binary size] \t [chunk byte count] \n
//	[n1 * key size       :key]                                 [compressed size] \t [Base64 compressed data] \n
//	[n2                  :value header - 10|000|3]             [compressed size] \t [Base64 compressed data]\n
//	[n4                  :binary size]                         ...
//	[n4                  :chunk byte count]
//	[n4                  :compressed size]         
//	[n1 * compressed size:compressed data]
//	...
//	[n4                  :compressed size]         
//	[n1 * compressed size:compressed data]
//	...
//	
//	[n1                  :key size]                            [key] \t "*" \t [array size] \t ":" \n
//	[n1 * key size       :key]                                 [binary size] \t [chunk byte count]\n
//	[n2                  :value header - 10|???|3]             [compressed size] \t [Base64 compressed data] \n
//	[???                 :array size]                         [compressed size] \t [Base64 compressed data]\n
//	[n4                  :binary size]                         ...
//	[n4                  :chunk byte count]                    [binary size] \t [chunk byte count]\n
//	[n4                  :compressed size]                     [compressed size] \t [Base64 compressed data]\n
//	[n1 * compressed size:compressed data]                     ...
//	...
//	[n4                  :compressed size]        
//	[n1 * compressed size:compressed data]
//	[n4                  :binary size]             
//	[n4                  :chunk byte count]              
//	[n4                  :compressed size]        
//	[n1 * compressed size:compressed data]
//	...
//	]


	The binary data will have a header of 1 natural number (n4) before the binary data.  This value indicates the byte count of the binary data.  This byte count is not included when using Base64 or Zlib compression.  However the binary data will honor Base64 and Zlib compression if used.
	The difference between *, **, ***, and **** is the ultimate size of the binary data.  The binary size will be measured with an n4, n8, n16, and n32 respectively.

.[
* binKey1 1 - 10 ...\n

* binKey2 2 \n
10 ...\n
10 ...\n

* binKey3 1 . 1024 432 ...\n

* binKey4 2 .\n
10240 5123 ...\n
10240 4603 ...\n

* binKey3 1 : 10000000 100000\n
432 ...\n
...
50 ...\n

* binKey4 2 : 100000\n
10000000\n
5123 ...\n
...   
50 ...\n
20000000\n
4603 ...\n
...
125 ...\n
]

//	.[
//	Binary                                                     Text
//	
//	[n1       :7]                                              binKey1 ...- 10 ...\n
//	[n1 * 7   :binKey1]     
//	[n2       :00|00|3]       
//	[n4       :10]          
//	[n1 * 10  :...]         
//	
//	[n1       :7]                                              binKey2 ...= 2\n
//	[n1 * 7   :binKey2]                                        10 ...\n
//	[n2       :00|01|3]                                        10 ...\n
//	[n4       :10]          
//	[n1 * 10  :...]         
//	[n4       :10]          
//	[n1 * 10  :...]         
//	
//	[n1       :7]                                              binKey3 ...z 1024 432 ...\n
//	[n1 * 7   :binKey3]     
//	[n2       :01|00|3]       
//	[n4       :1024]        
//	[n4       :432]         
//	[n1 * 432 :...]         
//	
//	[n1       :7]                                             binKey4 ...Z 2\n
//	[n1 * 7   :binKey4]                                       10240 5123 ...\n
//	[n2       :01|01|3]                                       10240 4603 ...\n
//	[n4       :10240]       
//	[n4       :5123]        
//	[n1 * 5123:...]         
//	[n4       :10240]       
//	[n4       :4603]        
//	[n1 * 4603:...]         
//	
//	[n1       :7]                                              binKey3 ...c 10000000 100000\n
//	[n1 * 7   :binKey3]                                        432 ...\n
//	[n2       :01|00|3]                                        ...
//	[n4       :10000000]                                       50 ...\n
//	[n4       :432]         
//	[n1 * 432 :...]         
//	...
//	[n4       :50]
//	[n1 * 50  :...]
//	
//	[n1       :7]                                             binKey4 ...C 2\n
//	[n1 * 7   :binKey4]                                       10000000 100000\n
//	[n2       :01|01|3]                                       5123 ...\n
//	[n4       :10000000]                                      ...   
//	[n4       :1000000]                                       50 ...\n
//	[n4       :5123]                                          20000000 500000\n
//	[n1 * 5123:...]                                           4603 ...\n
//	...                                                       ...
//	[n4       :50]                                            125 ...\n
//	[n1 * 50  :...]
//	[n4       :20000000]                                         
//	[n4       :500000]
//	[n4       :4603]                                          
//	[n1 * 4603:...]                                           
//	...
//	[n4       :125]
//	[n1 * 125 :...]
//	]

	Binary data is dangerous and should be used rarely if at all.  If someone uses them then they should be on the hook to define what the contents of the blob means.  If they do not, then they are being bad citizens and should be shamed!  SHAMED I SAY!
	However this is here as a catchall just in case.
	There is one special case where you need not give the size of the binary data and just stream it out till the new line.

.[
* unknown size * - ...\n

* unknown size compressed * : 1000000 \n
384628 ...\n
236879 ...\n
...
0 0\n
]

	The count becomes * to indicate there isn't a known limit.  
	The uncompressed options terminates on a \n.
	The only compressed option is to use the chunked compression.  The last chunk will have 0 bytes to indicate the termination.
	When reading this data the reader will read in chunks of the binary data at a time until the end of the stream.


hh	|chapter| - Embedded files

.[
[*] \t [key] \t 1 \t - \t [file type] \t [byte count] \t [Base64 file data]\n

[*] \t [key] \t 1 \t . \t [file type] \t [byte count] \t [compressed size] \t [Base64 compressed data]\n

[*] \t [key] \t 1 \t : \t [file type] \t [byte count] \t [chunk byte count]\n
[compressed size] \t [Base64 compressed data]\n
[compressed size] \t [Base64 compressed data]\n
...

[*] \t [key] \t [array size] \t -\n
[file type] \t [byte count] \t [Base64 file data]\n
[file type] \t [byte count] \t [Base64 file data]\n
...

[*] \t [key] \t [array size] \t .\n
[file type] \t [byte count] \t [compressed size] \t [Base64 compressed data]\n
[file type] \t [byte count] \t [compressed size] \t [Base64 compressed data]\n
...

[*] \t [key] \t [array size] \t : \t [chunk byte count]\n
[file type] \t [byte count]\n
[compressed size] \t [Base64 compressed data]\n
[compressed size] \t [Base64 compressed data]\n
...
[file type] \t [byte count]\n
[compressed size] \t [Base64 compressed data]\n
...
]

//	.[
//	Binary                                                     Text
//	
//	[n1                        :key size]                [key] file- [file type] [byte count] [Base64 file data]\n
//	[n1 * key size       :key]
//	[n2                        :00|00|4]
//	[n1                        :file type byte count]
//	[n1 * file type byte count :file type]
//	[n4                        :byte count]
//	[n1 * byte count           :file data]
//	
//	[n1                        :key size]                [key] file= [array size]\n
//	[n1 * key size       :key]                           [three letter file type] [byte count] [Base64 file data]\n
//	[n2                        :00|01|4]                       [file type] [byte count] [Base64 file data]\n
//	[n4                        :array size]                   ...
//	[n1                        :file type byte count]
//	[n1 * file type byte count :file type]
//	[n4                        :byte count]
//	[n1 * byte count           :file data]
//	[n3                        :three letter file type]
//	[n4                        :byte count]
//	[n1 * byte count           :file data]
//	...
//	
//	[n1                        :key size]                [key] filez [file type] [byte count] [compressed size] [Base64 compressed data]\n
//	[n1 * key size       :key]
//	[n2                        :01|00|4]
//	[n1                        :file type byte count]
//	[n1 * file type byte count :file type]
//	[n4                        :byte count]
//	[n4                        :compressed size]
//	[n1 * compressed size:compressed data]
//	
//	[n1                        :key size]                [key] fileZ [array size]\n
//	[n1 * key size       :key]                           [file type] [byte count] [compressed size] [Base64 compressed data]\n
//	[n2                        :01|01|4]                       [file type] [byte count] [compressed size] [Base64 compressed data]\n
//	[n4                        :array size]                   ...
//	[n1                        :file type byte count]
//	[n1 * file type byte count :file type]
//	[n4                        :byte count]
//	[n4                        :compressed size]
//	[n1 * compressed size:compressed data]
//	[n3                        :three letter file type]
//	[n4                        :byte count]
//	[n4                        :compressed size]
//	[n1 * compressed size:compressed data]
//	...
//	
//	[n1                        :key size]                [key] filec [file type] [byte count] [chunk byte count]\n
//	[n1 * key size       :key]                           [compressed size] [Base64 compressed data]\n
//	[n2                        :10|00|4]                       [compressed size] [Base64 compressed data]\n
//	[n1                        :file type byte count]          ...
//	[n1 * file type byte count :file type]
//	[n4                        :byte count]
//	[n4                        :chunk byte count]
//	[n4                        :compressed size]
//	[n1 * compressed size:compressed data]
//	...
//	[n4                        :compressed size]
//	[n1 * compressed size:compressed data]
//	
//	[n1                        :key size]                [key] fileC [array size]\n
//	[n1 * key size       :key]                           [file type] [byte count] [chunk byte count]\n
//	[n2                        :10|01|4]                       [compressed size] [Base64 compressed data]\n
//	[n4                        :array size]                   [compressed size] [Base64 compressed data]\n
//	[n1                        :file type byte count]          ...
//	[n1 * file type byte count :file type]                     [file type] [byte count] [chunk byte count]\n
//	[n4                        :byte count]                    [compressed size] [Base64 compressed data]\n
//	[n4                        :chunk byte count]              ...
//	[n4                        :compressed size]         
//	[n1 * compressed size:compressed data]
//	...
//	[n4                        :compressed size]
//	[n1 * compressed size:compressed data]
//	[n3                        :three letter file type]
//	[n4                        :byte count]
//	[n4                        :chunk byte count]
//	[n4                        :compressed size]
//	[n1 * compressed size:compressed data]
//	...
//	]
//	

	File option will have a file type identifier, usually the file extension or mime type string, lower case letters only; a natural number for the file size, and then the file that represents the image, copied verbatum into the value portion.

.[
[*] File1 1 - doc 1024 ...\n

[*] File2 1 - css 1024 564 ...\n

[*] File3 1 : css 1123456 123456\n
564 ...\n
...
56 ...\n

[*] FileList1 2 -\n
htm 2048 ...\n
doc 4096 ...\n

[*] FileList2 2 .\n
htm 2048 517 ...\n
doc 4096 4001 ...\n

[*] FileList2 2 : 100000\n
htm 2123456\n
517 ...\n
...
17 ...\n
doc 3123123\n
4001 ...\n
...
]

//	.[
//	Binary                                                     Text
//	
//	[n1       :5]                                              File1 file- doc 1024 ...\n
//	[n1 * 5   :File1]
//	[n2       :00|00|4]
//	[n1       :3]
//	[n1 * 3   :doc]
//	[n4       :1024]
//	[n1 * 1024:...]
//	
//	[n1       :9]                                              FileList1 fileZ 2\n
//	[n1 * 9   :FileList1]                                      htm  2048 517 ...\n
//	[n2       :00|01|4]                                        docx 4096 4001 ...\n
//	[n4       :2]
//	[n1       :3]
//	[n1 * 3   :htm]
//	[n4       :2048]
//	[n1 * 2048:...]
//	[n1       :4]
//	[n1 * 4   :docx]
//	[n4       :4096]
//	[n1 * 4096:...]
//	
//	[n1       :5]                                              File2 filez css 1024 564 ...\n
//	[n1 * 5   :File2]
//	[n2       :01|00|4]
//	[n1       :3]
//	[n1 * 3   :css]
//	[n4       :1024]
//	[n4       :564]
//	[n1 * 564 :...]
//	
//	[n1       :9]                                              FileList2 fileZ 2\n
//	[n1 * 9   :FileList2]                                      htm  2048 517 ...\n
//	[n2       :01|01|4]                                        docx 4096 4001 ...\n
//	[n4       :2]
//	[n1       :3]
//	[n1 * 3   :htm]
//	[n4       :2048]
//	[n4       :517]
//	[n1 * 517 :...]
//	[n1       :4]
//	[n1 * 4   :docx]
//	[n4       :4096]
//	[n4       :4001]
//	[n1 * 4001:...]
//	
//	[n1       :5]                                              File2 filec css 1123456 123456\n
//	[n1 * 5   :File2]                                          564 ...\n
//	[n2       :10|00|4]                                        ...
//	[n1       :3]                                              56 ...\n
//	[n1 * 3   :css]
//	[n4       :1123456]
//	[n4       :123456]
//	[n4       :564]
//	[n1 * 564 :...]
//	...
//	[n4       :56]
//	[n1 * 56  :...]
//	
//	[n1       :9]                                              FileList2 fileC 2\n
//	[n1 * 9   :FileList2]                                      htm  2123456 123456\n
//	[n2       :10|01|4]                                        517 ...\n
//	[n4       :2]                                              ...
//	[n1       :3]                                              17 ...\n
//	[n1 * 3   :htm]                                            docx 3123123 123123\n
//	[n4       :2123456]                                        4001 ...\n
//	[n4       :123456]                                         ...
//	[n4       :517]
//	[n1 * 517 :...]
//	...
//	[n4       :17]
//	[n1 * 17  :...]
//	[n1       :4]
//	[n1 * 4   :docx]
//	[n4       :3123123]
//	[n4       :123123]
//	[n4       :4001]
//	[n1 * 4001:...]
//	...
//	]
//	


hh	|chapter| - Type value

	type stores type format string.

.[
type \t [key] \t 1 \t - \t [text type code]\n

type \t [key] \t [array size] \t - \t [text type code]*\n

type \t [key] \t [array size] \t . \t [compressed size] \t [Base64 compressed binary type codes]

type \t [key] \t [array size] \t : \t [chunk byte count]\n
[compressed size] \t [Base64 compressed binary type codes]\n
...
]

//	.[
//	Binary                                                     Text 
//	
//	[n1                        :key size]                [key] type- [text type code]\n
//	[n1 * key size       :key]                 
//	[n2                        :value header - 00|00|5]          
//	[n2                        :binary type code]              
//	
//	[n1                        :key size]                [key] type= [array size] [text type code]*\n
//	[n1 * key size       :key]                 
//	[n2                        :value header - 00|01|5]          
//	[n4                        :array size]                   
//	[n2                        :binary type code]*
//	
//	[n1                        :key size]                type3 typeZ [array size] [compressed size] [Base64 compressed binary type codes]
//	[n1 * key size       :key]                 
//	[n2                        :value header - 01|01|5]          
//	[n4                        :array size]                   
//	[n4                        :compressed size]         
//	[n1 * compressed size:compressed binary type code]
//	
//	[n1                        :key size]                type3 typeC [array size] [chunk byte count]\n
//	[n1 * key size       :key]                           [compressed size] [Base64 compressed binary type codes]\n
//	[n2                        :value header - 01|01|5]        ...
//	[n4                        :array size]                   
//	[n4                        :chunk byte count]                   
//	[n4                        :compressed size]         
//	[n1 * compressed size:compressed binary type code]
//	...
//	]

	There is no chunked or compressed single value case.
	The text chunked and compressed type array is using the binary type codes and not the text type codes.

.[
type type1 1 - b\n

type type2 2 - b n4\n

type type3 100 . 31 ...\n

type type4 100000 : 1000\n
2342 ...\n
4546 ...\n
...
]

//	.[
//	Binary                                                     Text 
//	
//	[n1     :5]                                                type1 type- bool\n
//	[n1 * 5 :type1]                 
//	[n2     :00|00|5]                 
//	[n2     :10]                   
//	
//	[n1     :5]                                                type2 type= 2 bool .\n
//	[n1 * 5 :type2]                 
//	[n2     :00|01|5]                 
//	[n4     :2]                     
//	[n2     :10]                   
//	[n2     :8]                   
//	
//	[n1     :5]                                                type3 typeZ 100 31 ...
//	[n1 * 5 :type3]                 
//	[n2     :01|01|5]                 
//	[n4     :100]                   
//	[n4     :31]            
//	[n1 * 31:...]           
//	]



hh	|chapter| - String values

//		Binary case is simpler so we'll talk about that first.
//	
//	.[
//	[n1                        :key size]
//	[n1 * key size       :key]
//	[n2                        :value header - 00|00|6]
//	[n4                        :string byte count]
//	[n1 * string byte count    :string data]
//	
//	[n1                        :key size]
//	[n1 * key size       :key]
//	[n2                        :value header - 00|01|6]
//	[n4                        :array size]
//	[n4                        :string byte count]
//	[n1 * string byte count    :string data]
//	[n4                        :string byte count]
//	[n1 * string byte count    :string data]
//	...                        
//	
//	[n1                        :key size]
//	[n1 * key size       :key]
//	[n2                        :value header - 01|00|6]
//	[n4                        :string byte count]
//	[n4                        :compressed size]
//	[n1 * compressed size:compressed data]
//	
//	[n1                        :key size]
//	[n1 * key size       :key]
//	[n2                        :value header - 01|01|6]
//	[n4                        :array size]
//	[n4 * array size          :string byte count list]
//	[n4                        :compressed size]
//	[n1 * compressed size:compressed data]
//	
//	[n1                        :key size]
//	[n1 * key size       :key]
//	[n2                        :value header - 10|00|6]
//	[n4                        :string byte count]
//	[n4                        :chunk byte count]
//	[n4                        :compressed size]
//	[n1 * compressed size:compressed data]
//	[n4                        :compressed size]
//	[n1 * compressed size:compressed data]
//	...
//	
//	[n1                        :key size]
//	[n1 * key size       :key]
//	[n2                        :value header - 10|01|6]
//	[n4                        :array size]
//	[n4 * array size          :string byte count]
//	[n4                        :chunk byte count]
//	[n4                        :compressed size]
//	[n1 * compressed size:compressed data]
//	[n4                        :compressed size]
//	[n1 * compressed size:compressed data]
//	...
//	[n4 * array size          :string byte count]
//	[n4                        :chunk byte count]
//	[n4                        :compressed size]
//	[n1 * compressed size:compressed data]
//	[n4                        :compressed size]
//	[n1 * compressed size:compressed data]
//	...
//	]
//	
//		The case of a single value just requires a byte count before the actual string data.  The string data will be exactly the byte count size.  Since this is binary, string data is not modified in any way.
//		The case of an array value just requires a repeat of the byte count string data for as may in the array.
//		The case of a compressed single value adds a compressed size after the string byte count.  And a compressed byte array of the string follows.
//		The case of an array of compressed strings is similar to regular array but each string is individually compressed.  
//		Chunking just breaks up the long strings into chunks before compression.
//	
//	.[
//	[n1     :7]
//	[n1 * 7 :string1]
//	[n2     :00|00|6]
//	[n4     :55]
//	[n1 * 55:...]
//	
//	[n1     :7]
//	[n1 * 7 :string2]
//	[n2     :00|01|6]
//	[n4     :2]
//	[n4     :55]
//	[n1 * 55:...]
//	[n4     :55]
//	[n1 * 55:...]
//	
//	[n1     :7]
//	[n1 * 7 :string3]
//	[n2     :01|00|6]
//	[n4     :555]
//	[n4     :67]
//	[n1 * 67:...]
//	
//	[n1     :7]
//	[n1 * 7 :string4]
//	[n2     :01|01|6]
//	[n4     :2]
//	[n4 * 2 :75 65]
//	[n4     :85]
//	[n1 * 85:...]
//	]
//	
//		The text case is a little more involved.

.[
" \t [key] \t 1 \t - \t [string data]\n

" \t [key] \t 1 \t . \t [string byte count] \t [compressed size] \t [Base64 compressed data]\n

" \t [key] \t 1 \t : \t [string byte count] \t [chunk byte count]\n
[compressed size] \t [Base64 compressed data]\n
[compressed size] \t [Base64 compressed data]\n
...

" \t [key] \t [array size] \t -\n
[string data]\n
...

" \t [key] \t [array size] \t .\n
[string byte count] \t [compressed size] \t [Base64 compressed data]\n
[string byte count] \t [compressed size] \t [Base64 compressed data]\n
...

" \t [key] \t [array size] \t : \t [chunk byte count]\n1
[string byte count]\n
[compressed size] \t [Base64 compressed data]\n
[compressed size] \t [Base64 compressed data]\n
...
[string byte count]\n
[compressed size] \t [Base64 compressed data]\n
[compressed size] \t [Base64 compressed data]\n
...
]

	If no compression is used then the string starts right after the \t character till the end of the line but not including the new line character at the end of the line.
	Multi-line strings are placed on one line.  This is done by escaping new line and cursor return characters as well as some other characters.  See below.

.[
\a - bell           - 0x07
\b - backspace      - 0x08
\t - tab            - 0x09
\n - new line       - 0x0a
\v - vertical tab   - 0x0b
\f - form feed      - 0x0c
\r - cursor return  - 0x0d
\e - escape         - 0x1b
\\ - \
]

	Examples:

.[
" string1 1 - This is line1.\nThis is line 2.\n

" string2 1 . 1024 754 ...\n

" string3 1 : 1000000 1000\n
23424 ...\n
458947 ...\n
...

" stringList1 3 -\n
This is string 1, line 1.\r\nThis is string1, line 2.\r\n\n
This is string 2.\n
This is string 3.\n

" stringList2 3 .\n
535 323 ...\n
423 152 ...\n
754 341 ...\n

" stringList3 3 : 1000\n
100000\n
3252 ...\n
67543 ...\n
...\n
100000\n
562 ...\n
...
]

	If an array of strings is used, the individual strings will reside on their own line.  Each string is on it's own line.
	For an array of strings, the first character of the string will be at the first character of the line.  Any space at the beginning of the string is part of the string.
	
	For a compressed single string, the string is compressed first before converting to Base64.  No escape character or string modification is needed since it is treated like binary data.  A byte count of the string and a compressed size is required to follow.
	
	Like binary values there is a special case where we can have a stream of unknown lenght stored in the string.
	
.[
" stream1 * - ...\n

" stream2 * : 100000\n
62494 ...\n
4788 ...\n
...
0 \n
]


hh	|chapter| - Path Values

	A string defining a relative path (relative to the MIFF file location.)  Folders are separated by a "/" only.  No "." or ".." are allowed as part of the path.
	See String Values above for storage rules.  They are the same.



hh	|chapter| - Boolean values

.[
b \t [key] \t 1 \t - [boolean value]\n

b \t [key] \t [array size] \t [boolean value]*\n

b \t [key] \t [array size] \t [compressed size] \t [Base64 compressed data]\n

b \t [key] \t [array size] \t [chunk byte count]\n
[compressed size] \t [Base64 compressed data]\n
[compressed size] \t [Base64 compressed data]\n
...
]

//	.[
//	Binary                                                     Text
//	
//	[n1                        :key size]                [key] bool- [boolean value]\n
//	[n1 * key size       :key]                           
//	[n2                        :value header  - 00|00|10]         
//	[n1                        :boolean value - 'T'|'F']       
//	
//	[n1                        :key size]                [key] bool= [array size] [boolean value] * (array size)\n
//	[n1 * key size       :key]                           
//	[n2                        :value header  - 00|01|10]          
//	[n4                        :array size]                   
//	[n1 * (array size / 8)    :boolean value]                 
//	
//	[n1                        :key size]                [key] boolZ [array size] [compressed size] [Base64 compressed data]\n
//	[n1 * key size       :key]                           
//	[n2                        :value header  - 01|01|10]          
//	[n4                        :array size]                   
//	[n4                        :compressed size]         
//	[n1 * compressed size:compressed data]               
//	
//	[n1                        :key size]                [key] boolC [array size] [chunk byte count]\n
//	[n1 * key size       :key]                           [compressed size] [Base64 compressed data]\n
//	[n2                        :value header  - 10|01|10]       [compressed size] [Base64 compressed data]\n
//	[n4                        :array size]                   ...
//	[n4                        :chunk byte count]
//	[n4                        :compressed size]         
//	[n1 * compressed size:compressed data]               
//	[n4                        :compressed size]         
//	[n1 * compressed size:compressed data]               
//	...
//	]


	By default, the value will be 'T' for true, or 'F' for false.
	For array values in text files, the value will be a string of 'T' or 'F' letters with no separator in between to save some space.
	For array values in binary , the value will be made into a bitmap first.  See diagram below for bit assignment.
	For compressed array value, a bitmap is made and then compress.  See diagram below for bit assignment.

.[
Byte 0                            Byte 1
+---+---+---+---+---+---+---+---+ +---  ...
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | | 8
+---+---+---+---+---+---+---+---+ +--- ...
 2^7 2^6 ...                 2^0   2^8 ...
]

	0, 1, 2, ... Indicates the index into the array of booleans.  So each bit will either be 1 (true) or 0 (false).
	'z' encoding flag is never used with this type.

.[
b Bool1 1 - T\n

b Bool2 10 - TTTTTFFFFF\n

b Bool3 1024 . 25 ...\n

b Bool4 100000 : 1000\n
234 ...\n
2934 ...\n
...
]

//	.[
//	Binary                                                     Text
//	
//	[n1                        :5]                             Bool1 bool- T\n
//	[n1 * 5                    :Bool1]
//	[n2                        :00|00|10]
//	[n1                        :T]
//	                       
//	[n1                        :5]                             Bool2 bool= 10 TTTTTFFFFF\n
//	[n1 * 5                    :Bool2]
//	[n2                        :00|01|10]
//	[n4                        :array size]
//	[n1 * (array size / 8)    :boolean value]
//	
//	[n1                        :5]                             Bool3 boolZ 1024 25 ...\n
//	[n1 * 5                    :Bool3]
//	[n2                        :01|01|10]
//	[n4                        :array size]
//	[n4                        :compressed size]
//	[n1 * compressed size:compressed data]
//	]


hh	|chapter| - Simple values

	Simple value encoding.  Based on what is being stored the byte streams only look slighly different.

.[
[text type code] \t [key] \t 1 \t - \t [type value]\n

[text type code] \t [key] \t 1 \t . \t [compressed size] \t [compressed data]\n

[text type code] \t [key] \t 1 \t : \t [chunk byte count]\n
[compressed size] [compressed data]\n
[compressed size] [compressed data]\n
...

[text type code] \t [key] \t [array size] \t - \t [[type value] \t]*\n

[text type code] \t [key] \t [array size] \t . \t [compressed size] \t [compressed data]\n

[text type code] \t [key] \t [array size] \t : \t [chunk byte count]\n
[compressed size] [compressed data]\n
[compressed size] [compressed data]\n
...
]


//	.[
//	Binary                                                     Text
//	
//	[n1                        :key size]                [key] [text type code]- [type value]\n
//	[n1 * key size       :key]                           
//	[n2                        :value header - 00|00|[type code]]
//	[[byte count]              :type value]                    
//	
//	[n1                        :key size]                [key] [text type code]= [array size] [type value] * (array size)\n
//	[n1 * key size       :key]                           
//	[n2                        :value header - 00|01|[type code]]
//	[n4                        :array size]                   
//	[[byte count] * array size:type values]         
//	
//	[n1                        :key size]                [key] [text type code]z [compressed size] [compressed data]\n
//	[n1 * key size       :key]                           
//	[n2                        :value header - 01|00|[type code]]
//	[n4                        :compressed size]         
//	[n1 * compressed size:compressed data]               
//	
//	[n1                        :key size]                [key] [text type code]Z [array size] [compressed size] [compressed data]\n
//	[n1 * key size       :key]
//	[n2                        :value header - 01|01|[type code]]
//	[n4                        :array size]                   
//	[n4                        :compressed size]         
//	[n1 * compressed size:compressed data]               
//	
//	[n1                        :key size]                [key] [text type code]c [chunk byte count]\n
//	[n1 * key size       :key]                           [compressed size] [compressed data]\n
//	[n2                        :value header - 10|00|[type code]][compressed size] [compressed data]\n
//	[n4                        :compressed size]         ...
//	[n1 * compressed size:compressed data]               
//	
//	[n1                        :key size]                [key] [text type code]C [array size] [chunk byte count]\n
//	[n1 * key size       :key]                           [compressed size] [compressed data]\n
//	[n2                        :value header - 10|01|[type code]][compressed size] [compressed data]\n
//	[n4                        :array size]                   ...
//	[n4                        :compressed size]         
//	[n1 * compressed size:compressed data]               
//	]


	binary sizes for the simple types will be one of...

t[
thx	Type
th*	Byte Count

t-
tcx	i1, n1
tc	1

t-
tcx	i2, n2
tc	2

t-
tcx	i3, n3
tc	3

t-
tcx	i4, n4, r4
tc	4

t-
tcx	i8, n8, r8
tc	8

t-
tcx	i16, n16, r16
tc	16

t-
tcx	i32, n32, r32
tc	32

t-
tcx	i64, n64, r64
tc	64

t-
tcx	i128, n128, r128
tc	128

t-
tcx	i256, n256, r256
tc	256
]

//		The values are simply encoded as...
//	
//	.	[byte count:value]
//	
//		Again, multi-byte values are store in big endian.
//		Arrays of these values are simply repeating the above as many times necessary for the array.
//		Chunk and Compression flags on a single value are not usually used unless they have a large byte count.
	
	Text representation for a value will be...

t[
thx	Type Code
th*	Representation

t-
tcx	i*, n*
tc	1 value in regular digits.

t-
tcx	r*
tc	1 Base64 stream of the 1 value.
]

	If using an array flag the above is repeated as many times as there are array elements.  Each array element will be separated by one \t.

.[
i4 1Int 1 - 1024\n

n4 *Nat 8 - 1 2 4 8 16 32 64 128\n

r4 1Real 1 - [Base64 encoded value]\n
]

//	.[
//	Binary                                                     Text
//	
//	[n1      :4]                                               1Int i4- 1024\n
//	[n1 * 4  :1Int]
//	[n2      :00|00|14]
//	[i4      :1024]
//	
//	[n1      :4]                                               *Nat n4= 8 1 2 4 8 16 32 64 128\n
//	[n1 * 4  :*Nat]
//	[n2      :00|01|34]
//	[n4      :8]
//	[n4      :1]
//	[n4      :2]
//	[n4      :4]
//	[n4      :8]
//	[n4      :16]
//	[n4      :32]
//	[n4      :64]
//	[n4      :128]
//	
//	[n1      :5]                                               1Real r4- [Base64 encoded value]\n
//	[n1 * 5  :1Real]
//	[n1      :00|00|51]
//	[r4      :3.14159]
//	]
//	

//	hh	|chapter| - Key Type
//	
//		A simple key only record.  No value.  If the key exists or doesn't exist, that can be enough information for the format.
//	
//	.[
//	Binary                                                     Text
//	
//	[n1                     :key size]                   [key] -\n
//	[n1 * key size    :key]                              
//	[n2                     :value header - 00|00|8]           
//	]
//	
//		Only - is ever used with this type.  


hh	|chapter| - User Type

	A definition of a user type.  

.[
define \t [key] \t [member count] -\n
[type code] \t [key] \t [array size]\n
[type code] \t [key] \t [array size]\n
...
]

//	.[
//	Binary                                                     Text
//	
//	[n1                     :key size]                   [key] usertype- [comment]\n
//	[n1 * key size    :key]                              [key] [value header] [array size] [comment]\n
//	[n2                     :value header - 00|00|9]           [key] [value header] [array size] [comment]\n
//	[n2                     :user type code]                   ...
//	[n1                     :comment byte count]               \n
//	[n1 * comment byte count:comment]                          
//	[n1                     :key size]                       
//	[n1 * key size    :key]                                  
//	[n2                     :value header]
//	[n4                     :array size]*
//	[n1                     :comment byte count]               
//	[n1 * comment byte count:comment]                          
//	[n1                     :key size]
//	[n1 * key size    :key]
//	[n2                     :value header]
//	[n4                     :array size]*
//	[n1                     :comment byte count]               
//	[n1 * comment byte count:comment]                          
//	...                     
//	[n1                     :key size - 0]
//	
//	[n1                     :key size]                   [key] usertype= [array size] [comment]\n
//	[n1 * key size    :key]                              [key] [value header] [array size] [comment]\n
//	[n2                     :value header - 00|01|9]           [key] [value header] [array size] [comment]\n
//	[n2                     :user type code]                   ...
//	[n4                     :array size]                      
//	[n1                     :comment byte count]               
//	[n1 * comment byte count:comment]                          
//	[n1                     :key size]
//	[n1 * key size    :key]
//	[n2                     :value header]
//	[n4                     :array size]*
//	[n1                     :comment byte count]               
//	[n1 * comment byte count:comment]                          
//	[n1                     :key size]
//	[n1 * key size    :key]
//	[n2                     :value header]
//	[n4                     :array size]*
//	[n1                     :comment byte count]               
//	[n1 * comment byte count:comment]                          
//	...
//	]
//	

//	In the binary, the [user type code] is something the writer of the MIFF defines.  There is nothing special about this value except that it should be a value between 64 and 4095.  Also, no two user types can have the same user type code.  In the text file, the key for the user type is the user type code.
	Compression is never used with this type code.

.[
define TypeContact 6 -\n
"  NameGiven     1\n
"  NameFamily    1\n
n1 Age           1\n
"  EMail         1\n
n1 DataFlags     5\n
i4 Streamed data *\n

define Image 3 -\n
n4 Width  1\n
n4 Height 1\n
n1 Pixels *\n
]

//	.[
//	Binary                                                     Text
//	
//	[n1     :11]                                               TypeContact usertype-\n
//	[n1 * 11:TypeContact]                                      NameGiven ""-\n
//	[n2     :00|00|9]                                          NameFamily ""-\n
//	[n2     :64]                                               Age n1-\n
//	[n1     :0]                                                EMail ""-\n
//	-no comment-                                               DataFlags n1= 5\n
//	[n1     :9]                                                \n
//	[n1 * 9 :NameGiven]                                        
//	[n2     :00|00|6]                                            
//	[n1     :0]                                                
//	-no comment-
//	[n1     :10]                                               
//	[n1 * 10:NameFamily]
//	[n2     :00|00|6]
//	[n1     :0]
//	-no comment-
//	[n1     :3]
//	[n1 * 3 :Age]
//	[n2     :00|00|31]
//	[n1     :0]
//	-no comment-
//	[n1     :5]
//	[n1 * 5 :EMail]
//	[n2     :00|00|6]
//	[n1     :0]
//	-no comment-
//	[n1     :9]
//	[n1 * 9 :DataFlags]
//	[n2     :00|01|31]
//	[n4     :5]
//	[n1     :0]
//	-no comment-
//	[n1     :0]
//	
//	[n1     :11]                                               TypeContact usertype= 5
//	[n1 * 11:TypeContact]                                      NameGiven ""-\n
//	[n2     :00|01|9]                                          NameFamily ""-\n
//	[n2     :64]                                               Age n1-\n
//	[n4     :5]                                                EMail ""-\n
//	[n1     :0]                                                DataFlags n1= 5\n
//	-no comment-                                               
//	[n1     :9]                                                
//	[n1 * 9 :NameGiven]                                        
//	[n2     :00|00|6]
//	[n1     :0]
//	-no comment-
//	[n1     :10]
//	[n1 * 10:NameFamily]
//	[n2     :00|00|6]
//	[n1     :0]
//	-no comment-
//	[n1     :3]
//	[n1 * 3 :Age]
//	[n2     :00|00|31]
//	[n1     :0]
//	-no comment-
//	[n1     :5]
//	[n1 * 5 :EMail]
//	[n2     :00|00|6]
//	[n1     :0]
//	-no comment-
//	[n1     :9]
//	[n1 * 9 :DataFlags]
//	[n2     :00|01|31]
//	[n4     :5]
//	[n1     :0]
//	-no comment-
//	]


	As shown in the above, "Streamed data" or "Pixels" is an array of values but this array appears to be variable in length and we do not know its size when we defined the type.  The size will be provided when the data for the type is provided. 

//	.[
//	Binary                                                     Text
//	
//	[n1     :5]                                                Image usertype-\n
//	[n1 * 5 :Image]                                            Width  n4- Width in pixels for the image.\n
//	[n2     :00|00|9]                                          Height n4- Height in pixels for the image.\n
//	[n2     :65]                                               Pixels n1* Width * Height * n1 * 3 pixel values in RGB order.\n
//	[n1     :5]                                                \n
//	[n1 * 5 :Width]
//	[n2     :00|00|34]
//	[n1     :30]
//	[n1 * 30:Width in pixels for the image.]
//	[n1     :6]
//	[n1 * 6 :Height]
//	[n2     :00|00|34]
//	[n1     :31]
//	[n1 * 31:Height in pixels for the image.]
//	[n1     :6]
//	[n1 * 3 :Pixels]
//	[n2     :00|10|31]
//	[n1     :50]
//	[n1 * 50:Width * Height * n1 * 3 pixel values in RGB order.]
//	[n1     :0]
//	]
//	
//		In this situation Pixels is a byte array but the size of it is not known at definition.  Rules on its size may be dictated by who ever set the type.  Comments should be used to make it clear.

.[
define point 1 -\n
r4 value 3\n

...

define point 3 -\n
r8 east      1\n
r8 north     1\n
r8 elevation 1\n
]

	If you redefine a userType then the previous userType will be replaced with the new one.


hh	|chapter| - User Data

.[
[user type] \t [key] \t 1 \t - \t [user type data]\n

[user type] \t [key] \t 1 \t . \t [byte count] \t [compressed size] \t [Base64 compressed data]\n

[user type] \t [key] \t 1 \t : \t [byte count] \t [chunk byte count] \n
[compressed size] \t [Base64 compressed data]\n
...

[user type] \t [key] \t [array size] \t -\n
[user type data]\n
...

[user type] \t [key] \t [array size] \t . \t [compressed size] \t [Base64 compressed data]\n

[user type] \t [key] \t [array size] \t : \t [chunk byte count] \n
[compressed size] \t [Base64 compressed data]\n
...
]

//	.[
//	Binary                                                     Text
//	
//	[n1                        :key size]                [key] [user type]= [user type data]\n
//	[n1 * key size       :key]
//	[n2                        :00|00|user type code]
//	[n1                        :user type byte count]
//	[n1 * user type byte count :user type]
//	[*                         :user type data]
//	
//	[n1                        :key size]                [key] [user type]= [array size]\n
//	[n1 * key size       :key]                           [user type data]\n
//	[n2                        :00|01|user type code]          ...
//	[n1                        :user type byte count]
//	[n1 * user type byte count :user type]
//	[n4                        :array size]
//	[*                         :user type data]
//	...
//	
//	[n1                        :key size]                [key] [user type]z [byte count] [compressed size] [user type data]\n
//	[n1 * key size       :key]
//	[n2                        :01|00|user type code]
//	[n1                        :user type byte count]
//	[n1 * user type byte count :user type]
//	[n4                        :byte count]
//	[n4                        :compressed size]
//	[n1 * compressed size:compressed data]
//	
//	[n1                        :key size]                [key] [user type]Z [array size] [compressed size] [Base64 compressed data]\n
//	[n1 * key size       :key]
//	[n2                        :01|01|user type code]
//	[n1                        :user type byte count]
//	[n1 * user type byte count :user type]
//	[n4                        :array size]
//	[n4                        :byte count]
//	[n4                        :compressed size]
//	[n1 * compressed size:compressed data]
//	]
//	


	The value of a user type.  A "define" needs to be present before use.  The values that follow are in the order that the usertype defined them.  If an array of usertypes then each item is on their own line.
	In text the values may add new lines.  I.E. string values will have the \n as the indicator that the string ends.  Other values may simply add a separator like n4.
	If compression is used then the values are collated into a buffer first before compressing.  A byte count is required to know what the uncompressed buffer size was.

.[
TypeContact \t Contact1 \t 1 \t - \t Robbert \t de Groot \t 100 \t zekaric@gmail.com \t 1 \t 1 \t 2 \t 3 \t 5\n

TypeContact \t Contact2 \t 1 \t . \t 521 \t 95 \t ... \n

TypeContact \t Contact3 \t 1 \t : \t 100000 \n
52123 \t ... \n
23443 \t ... \n
...

TypeContact \t ContactList1 \t 2 \t - \n
Robbert \t de Groot \t 100 \t zekaric@gmail.com \t 1 \t 1 \t 2 \t 3 \t 5 \n
Sherlock \t Holms \t 32 \t 221b@bakerst.uk \t 10 \t 20 \t 30 \t 40 \t 50\n

TypeContact \t ContactList2 \t 2 \t . \t 5213 \t 954 \t ...\n

TypeContact \t ContactList3 \t 2 \t : \t 100000 \n
5213 \t ...\n
32784 \t ...\n
...
]

	\t used here to make it more obvious what a text line would look like.  Note, there is added space in front and after the \t here only to make it easier to read, in the real MIFF file this space does not exist.  I.E. the first example would look like...

	TypeContact|b |\t| b|Contact1|b |\t| b|1|b |\t| b|-|b |\t| b|Robbert|b |\t| b|de Groot|b |\t| b|100|b |\t| b|zekaric@gmail.com|b |\t| b|1|b |\t| b|1|b |\t| b|2|b |\t| b|3|b |\t| b|5|b |\n| b|

//	.[
//	Binary                                                     Text
//	
//	[n1      :14]                                              ContactList2 TypeContact-\n
//	[n1 * 14 :ContactList2]                                    `Robbert\n
//	[n2      :00|00|64]                                        `de Groot\n
//	[n4      :2]                                                100\n
//	[n4      :7]                                               `zekaric@gmail.com\n
//	[n1 * 7  :Robbert]                                          1 1 2 3 5\n
//	[n4      :8]
//	[n1 * 8  :de Groot]
//	[n1      :100]
//	[n4      :17]
//	[n1 * 17 :zekaric@gmail.com]
//	[n1      :1]
//	[n1      :1]
//	[n1      :2]
//	[n1      :3]
//	[n1      :5]
//	
//	[n1      :14]                                              ContactList2 TypeContact= 2\n
//	[n1 * 14 :ContactList2]                                    `Robbert\n
//	[n2      :01|01|64]                                        `de Groot\n
//	[n4      :2]                                               100\n
//	[n4      :7]                                               `zekaric@gmail.com\n
//	[n1 * 7  :Robbert]                                         1 1 2 3 5\n
//	[n4      :8]                                               `Sherlock\n
//	[n1 * 8  :de Groot]                                        `Holms\n
//	[n1      :100]                                             32\n
//	[n4      :17]                                              `221b@bakerst.uk\n
//	[n1 * 17 :zekaric@gmail.com]                               10 20 30 40 50\n
//	[n1      :1]
//	[n1      :1]
//	[n1      :2]
//	[n1      :3]
//	[n1      :5]
//	[n4      :8]
//	[n1 * 8  :Sherlock]
//	[n4      :5]
//	[n1 * 5  :Holms]
//	[n1      :32]
//	[n4      :15]
//	[n1 * 15 :221b@bakerst.uk]
//	[n1      :10]
//	[n1      :20]
//	[n1      :30]
//	[n1      :40]
//	[n1      :50]
//	
//	[n1      :14]                                              ContactList TypeContactz 521 95 ...\n
//	[n1 * 14 :ContactList1]
//	[n2      :01|00|64]
//	[n4      :521]
//	[n4      :95]
//	[n1 * 95 :...]
//	
//	[n1      :14]                                              ContactList2 TypeContactZ 2 5213 954 ...\n
//	[n1 * 14 :ContactList2]
//	[n2      :01|01|64]
//	[n4      :2]
//	[n4      :5213]
//	[n4      :954]
//	[n1 * 954:...]
//	]

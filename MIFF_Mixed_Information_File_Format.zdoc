~	M.I.F.F.: Mixed Information File Format

	[b=]Author:[=b] Robbert de Groot
	[b=]Date:[=b] 2019-05-15
	[b=]Copyright:[=b] 2019, Robbert de Groot
	[b=]License (Library):[=b] MIT License.
	[b=]License (Document):[=b] Creative Commons Attribution-NoDerivs.[link=]https://creativecommons.org/licenses/by-nd:4.0[=link=](CC BY-ND)[=link]

~~	Table Of Contents:

toc


*	[chapter] - M.I.F.F.


**	[chapter] - Discussion

	What is the purpose of M.I.F.F. (MIFF)?  MIFF is intended to be a simple file format for storing data.  Any data.
	It started life because of a need for a reduced data storage format for larger amounts of data.  See Mining Interchange MIFF since that was the reason for this document.


**	[chapter] - Goals

=[
-	[b=]Simple[=b].  The format should be simple for the developers to export their data.  And still fairly simple to re-import that data.
-	[b=]Brief[=b].  The format should not produce unnecessary waste.  The data in some cases will be quite large so it should not bloat the data too much.  Meaning, file sizes should not become overly large.  However, because of point 1 there will always be some bloat.
-	[b=]Flexible[=b].  The format needs to be able to accomodate change or specific data.  A years go by, software will also change and requirements will change.  The format needs to try its best to keep up without importers and exporters to be completely remade.
]=


**	[chapter] - Disclosure

	I, Robbert de Groot, have been a professional Software Developer since 1995.
	This format is currently not sanctioned by any software vendor.  This was a thought on developing something in place of existing options.
	I can be reached at the following two email addresses.
	robbert.degroot@hexagon.com<br />zekaric@gmail.com


*	[chapter] - MIFF Format: Base

	There are two representations of the format.  A Text file and a Binary file representation.  They will both contain exactly the same data and be exactly the same in feature set.  The Binary file may just have the advantage of being slightly more accurate, possibly slightly more compact and possibly slightly faster in reading and writing.
	At the low level, a MIFF format is just a collection of key value pairs.  Values can be a collection of further key value pairs.  Meaning nesting can be possible.
	The intent on reading these files is to make just one pass over them; twice at most, but for the most part, one pass over the contents should be enough to read in the data.  There is no focus on making the file random accessable or modifiable.  This format is not intended as a substitute for native formats for any software package.
	Common to both styles, any mutlibyte data that is encode or stored as a binary byte sequence will be in network (big endian) order.


**	[chapter] - File Header

	There will always be a file header so that you can be sure the file you recieved is actually a MIFF file and not some other file.

[	"MIFF   1TXT [Sub-Format Name] [Sub-Format Version]\n"

	or

[	"MIFF   1BIN " + [32 bytes:Sub-Format Name] + [4 bytes:Sub-Format Version]

	"MIFF" indicates the base file format type.

	"   1" indicates the base file format version.  Currently at version 1.  This will only use whole numbers instead of the usual XX.XX.XX.XX versioning of software.
	"TXT " and "BIN " indicate the content organization.  TXT for text, and BIN for binary.  "\n" is a line feed character.  This is part of the string.
	[Sub-Format Name] will always be 32 bytes or less.  Could be UTF8 but usually just using the first 127 printable code points of the UNICODE standard.  This value defines the format of what is being stored in the file.
	[Sub-Format Version] will always be an unsigned 4 byte value.  Like the MIFF version in terms of how versioning will happen.


**	[chapter] - Content

	Before going into the specifics of the text format and the binary format we will cover what a key value pair will look like at a high level.

***	[chapter] - Key Value Format

[	[key] [value header] [value]\n

	[b=][key][=b] will be a string that will somewhat uniquely identify the value.
	[b=][value header][=b] will be an code of characters that will dictate what the value will look like.
	[b=][value][=b] will depend on the [value header] on what is contained here.

****	[chapter] - Key

	Keys are always a single string of characters and are limited to printable character in the first 127 UNICODE code points.  Meaning no whitespace of any kind inside a key.

[[
12345
;':][.,<>]'
a_b_c
$cost
]]

	The key can be nonsense or just a number.  As long it does not include any whitespace.


****	[chapter] - Value Header

	There are quite a few different value types and encodings.  Each value is prepended with a header explaining the data you will be reading.
	Value header is as follows.

[	[type flag][array and encoding flag] [array count] [compressed size]

	[b=][type flag][=b] is one of:

t[
t-
thx	2 Letter Type Code
th*	Description

t-
tc	kv
tc	Key-Value block.

t-
tc	""
tc	String (UTF8) data.

t-
tc	az
tc	Azimuth (strike) using r4. Value in degrees

t-
tc	ad
tc	Dip direction using r4. Value in degrees

t-
tc	Ad
tc	Azimuth and Dip using r4. Azimuth in degrees. Dip in degrees

t-
tc	A%
tc	Azimuth and Dip using r4. Azimuth in degrees. Dip in percent

t-
tc	A:
tc	Azimuth and Dip using r4. Azimuth in degrees. Dip in ratio 1:XXX

t-
tc	bn
tc	Binary data.

t-
tc	bo
tc	Boolean value.

t-
tc	c3
tc	Color (RGB) using n1.

t-
tc	c4
tc	Color (RGBA) using n1.

t-
tc	C3
tc	Color (RGB) using r4.

t-
tc	C4
tc	Color (RGBA) using r4.

t-
tc	co
tc	Count same as n4.

t-
tc	Co
tc	Count same as n8.

t-
tc	dd
tc	Dip using r4. Value in degrees

t-
tc	d%
tc	Dip using r4. Value in percent

t-
tc	d:
tc	Dip using r4. Value in ratio 1:XXX

t-
tc	g3
tc	Graphic using c3.

t-
tc	g4
tc	Graphic using c4.

t-
tc	gf
tc	Graphic as an inline included file.

t-
tc	gl
tc	Graphic as a link to a file.

t-
tc	G3
tc	Graphic using C3.

t-
tc	G4
tc	Graphic using C4.

t-
tc	i1
tc	Integer of 1 byte.

t-
tc	i2
tc	Integer of 2 bytes.

t-
tc	i4
tc	Integer of 4 bytes.

t-
tc	i8
tc	Integer of 8 bytes.

t-
tc	id
tc	Id value, same as n4.  Potentially not unique, user controlled value.

t-
tc	Id
tc	GUID value.  Must be unique in a given MIFF file.

t-
tc	ix
tc	Index same as n4.

t-
tc	Ix
tc	Index same as n8.

t-
tc	mr
tc	3x3 matrix using r4.

t-
tc	mR
tc	3x3 matrix using r8.

t-
tc	Mr
tc	4x4 matrix using r4.

t-
tc	MR
tc	4x4 matrix using r8.

t-
tc	n1
tc	Natural of 1 byte.

t-
tc	n2
tc	Natural of 2 bytes.

t-
tc	n4
tc	Natural of 4 bytes.

t-
tc	n8
tc	Natural of 8 bytes.

t-
tc	of
tc	Offset same as n4.

t-
tc	Of
tc	Offset same as n8.

t-
tc	pr
tc	2d value using r4.

t-
tc	pR
tc	2d value using r8.

t-
tc	pi
tc	2d value using i4.

t-
tc	pI
tc	2d value using i8.

t-
tc	pn
tc	2d value using n4.

t-
tc	pN
tc	2d value using n8.

t-
tc	Pr
tc	3d value using r4.

t-
tc	PR
tc	3d value using r8.

t-
tc	Pi
tc	3d value using i4.

t-
tc	PI
tc	3d value using i8.

t-
tc	Pn
tc	3d value using n4.

t-
tc	PN
tc	3d value using n8.

t-
tc	r4
tc	Real of 4 bytes.

t-
tc	r8
tc	Real of 8 bytes.

t-
tc	sz
tc	Size same as n4.

t-
tc	Sz
tc	Size same as n8.

t-
tc	td
tc	Time, date only.

t-
tc	tt
tc	Time, time only.

t-
tc	t*
tc	Time, date and time.

t-
tc	ty
tc	Type value.  One of these 2 lettter type codes

t-
tc	vs
tc	Value stream.  The contents deviates from the rest of the format.  Representations will explained where they are used.

]t

	[b=][array and encoding flag][=b] is one of:

t[
t-
thx	Encoding Code
th*	Description

t-
tc	[empty]
tc	Single value, UTF8 readable encoding.

t-
tc	A
tc	Array of values, UTF8 readable encoding.

t-
tc	e
tc	Single value.  Binary representation of value is Base64 encoded.

t-
tc	E
tc	Array of values.  Binary representation of the array of values is Base64 encoded.

t-
tc	z
tc	Single value.  Binary representation of value if Zlib compressed then base64 encoded.

t-
tc	Z
tc	Array of values.  Binary representation of value if Zlib compressed then base64 encoded.

]t

	[b=][array count][=b] will only present when E, A, and Z are used.  This will be an unsigned integer value indicating how many items are in the array.
	[b=][compressed size][=b] will only present when z and Z are used.  This will be an unsigned integer value indicating the raw, in memory byte count of the compressed data buffer.
	e and E are only used in the Text represention of a MIFF file.  Binary representation only has one way to store data.
	A is used to indicate an array of values.  If used the array is either too small to really need compression or too random that compression will not really reduce the byte count.
	e, E, z, and Z will generate a base64 encoded string in the Text format.  This string lives on one line, there are no '\n' embedded in the encoding.
	Why co, Co, sz, Sz, ix, Ix, of, and Of when n4 and n8 would suffice?  The extra semantic information about what we are storing may be useful and it separates these values with a hard coded representation.  Potentially in the future, the representation may change to accommodate larger values.  In which case older MIFF files need not have to change.


****	[chapter] - Value

	The value header generally indicates what will be stored in the value of the key value pair.  It then becomes an issue on how it is represented in the two types of files.  See their respective sections for the details.


**	[chapter] - Text Format

	The text format is a UTF8 text file.  UTF8 is the 1 byte UNICODE format for text.  The base format only uses the ASCII characters (first 128 UNICODE character codes).  UTF8 mainly comes into play with the string data being stored.
	The format is only somewhat human readable, and only somewhat text editor friendly, but it really is not meant to be "human friendly."  What I mean is that you will be able to look at the format in a text editor (if the text editor is capable of handling really large files with really long lines) and if you know this format to a certain degree, you will be able to debug it.  To a certain degree you should be able to debug the binary version as well since it will not be too different than the text version.
	The format does not adhere to any line length limit.  So if you are using a text editor that does have line length limits you may end up corrupting the file or may not be seeing the whole file.
	All lines are terminated with a UNIX '\n'.  NOT an MSDOS \r\n or a MAC \n\r ending.  This is a strict rule.  If the file has \r\n or \n\r line endings then it is not a MIFF file.  No exceptions.
	'\r' (Cursor Return) should not appear anywhere in the format unless writted explicitely as '\', 'r'.  Meaning that it has been 'escaped' and that will only be in string values.


***	[chapter] - Whitespace Characters

	A whitespace character is any character that does not make a blemish on a piece of paper if printed out; this includes control characters like bell, NULL, form feed, etc.


***	[chapter] - Separator Characters

	MIFF limits what white space characters can be used as separators.
	' ' (space), '\t' (Tab)
	If you see any other whitespace characters used as a separator in the MIFF file then the file is not MIFF.


***	[chapter] - Printable Characters

	Just to be clear what a printable character is.  If you had a blank piece of paper with just one character on it, if the character makes a mark, it is printable.  If it does not make a mark, it is not printable (like spaces, control characters, etc.)


***	[chapter] - Key Value Format

	The text file key value format looks like this.

[	[key] [value header] [value]\n

	There can be leading separators before the [key] but these will be ignored.
	There has to be at least one separator between [key] and [value header].
	There has to be at least one separator between [value header] and the [value].
	Any extra separators in the line will be ignored.
	To terminate the key value pair use a single '\n' character.
	To be clear...
	[b=]Valid:[=b] spaces and tabs can be used to indent and separate the parts.

[	\t\t[key]\t[value header]\t\t\t[value]\n

	[b=]Invalid:[=b]Absolutely no "\n" anywhere before or within the key value line*.  '\n' characters indicate a termination of a kv block so any extra '\n' characters will cause problems.

[[
\n\n\n[key]\n[value header]\n[value]\n
 \n[key] [value header] [value]\n
]]

	* There are cases where the [value] will be broken up by '\n' characters but this will be indicated below.


****	[chapter] - Key

	See MIFF Formate: Base / Content / Key Value Format / Key section for key information.


****	[chapter] - Value Header

	As defined above the value header is as follows

[	[type flag][array and encoding flag] [array count] [compressed size]

	[type flag] and [array and encoding flag] is a string of 2 or 3 characters.
	If just the 2 letter [type flag] then the value is in readable UTF8 encoding.
	If combined with 'A' [array and encoding flag] then the value is an array of the given type.
	If combined with 'e' or 'E' then the value is treated as binary, reordered to be Big Endian and encoded into a string using base64.
	If combined with 'z' or 'Z' then the value is treated as binary, reordered to be Big Endian, compressed using zlib, and encoded into a string using base64.
	[array count] will be an unsigned integer value in readable UTF8 indicating how many values in the array.  Only present when A, E, and Z are used.
	[compressed size] will be an unsigned integer value in readable UTF8 indicating the raw, in memory byte count of the compressed data.  Only present when z and Z are used.
	Examples: (adding \n to indicate the necessity of this line.)

[[
image g3z 64 64 [base64 zip compressed byte stream]\n

count n1 128\n

string ""t This is a string.\nThis is really a multiline string!\n

pointList PR 5 10.5 20 0 20.5 20 0 20.5 50 0 10.5 50 0 10.5 20 0\n
]]


****	[chapter] - Value

	Some of the types are a bit more complex so they will have a specific representation in the text file.


***	[chapter] - Value Specifics


****	[chapter] - Key-Value Block

	Key-Value blocks are special.  They are needed to allow nesting of key values.  The last line of a block needs to be a comletely empty line with nothing on it but a \n to indicate that the block is terminated.

[[
docInfo kv\n
 title  "" M.I.F.F.: Mixed Information File Format\n
 author "" Robbert de Groot\n
\n
]]

	To be clear on how it works.  Leading separators before the key are unnecessary and are only here for clarity.  Leading separators before a \n are allowed but are wasteful.

[[
level1 kv\n
 level2 kv\n
  level3 kv\n
   ...
  \n
  anotherLevel3 kv\n
  \n
 \n
 anotherLevel2 kv\n
 \n
\n
anotherLevel1 kv\n
...
\n
]]

	Key value bocks can have an 'A' array specifier and a array count.  This is useful for an array of a complex type.

[[
itemList kvA 2\n
 item kv\n
  name ""t item A\n
  value i4t 0\n
 \n
 item kv\n
  name ""t item B\n
  value i4t 10\n
 \n
\n
]]

	e, E, z, and Z are never used with kv in text mode.


****	[chapter] - ""

	String values are sort of the odd one out with all the other data types.  The other data types have a known size based on their input while strings are variable in size.  So encoding them will be slightly different.
	No encoding flag, all strings will have their cursor return and line feed characters replaced with \r and \n respectively when written to the file.  If your string already has a \r and \n inside then the slash will be escaped, \\r and \\n respectively, so that they do not get converted when reading them back in.  Other slash character pairs will not need escaping.
	Even though \n is strictly followed for the text format, we convert \r as well because text editors will attempt to honor \r or complain about inconsistent line endings and mess things up.
	Strings are placed on one line even if they define a multi-line string.  With the above replacement of cursor return and line feeds this can be done.
	Unlike other data types, there can only be 1 separator between the value header and the start of the first string.  If there exists more than one separator then the extra separators are part of the string.
	'A' array flag, the individual strings will reside on their own line.  Meaning, as soon as a string is finished '\n' will immediately follow.  There will be as many lines as there are array elements.
	For an array of strings, the first character of the the next line will be the start of the first string in the array.  The line after that will be the second string.  No lines will have any leading spaces.  Any space visible is part of the string.
	'e' encoding, the string is converted to base64 directly without any \r and \n modifications.
	'z' encoding, the string is compressed first before converting to base64.
	'E' and 'Z' encoding, unlike 'A', the string array is treated as one big buffer separated by NULL values and then compressed and converted to base64.

[[
string "" This is a single string value.\nBut multiline. Only \\r and \\n need escaping and not other \s in the string\n

stringList ""A 3\n
This is string 1, line 1.\\r\\nThis is line 2.\\r\\n\n
This is string 2.\n
This is string 3.\n

stringList ""e 7342jlafnpi23uq9==

stringList ""Z afkj8u234123234dfjaee...
]]


****	[chapter] - a*, A*, c*, C*, d*, i*, m*, M*, n*, p*, P*, r*

	Types az, ad, Ad, A%, A:, c3, c4, C3, C4, dd, d%, d:, i1, i2, i4, i8, mr, mR, Mr, MR, n1, n2, n4, n8, pi, pI, pn, pN, pr, pR, Pi, PI, Pn, PN, Pr, PR, r4, r8 are all very simple in representation.  With no encoding flag...

t[
t-
thx	Type Code
th*	Representation (No encoding flag)

t-
tc	az, ad, co, Co, dd, d%, d:, i1, i2, i4, i8, id, ix, Ix, n1, n2, n4, n8, of, Of, r4, r8, sz, Sz
tc	1 UTF8 readable number

t-
tc	pr, pR, pi, pI, pn, pN, Ad, A%, A:
tc	2 UTF8 readable numbers separated by at least one separator.

t-
tc	Pr, PR, Pi, PI, Pn, PN, c3, C3    
tc	3 UTF8 readable numbers separated by at least one separator.

t-
tc	mr, mR                            
tc	9 UTF8 readable numbers separated by at least one separator.  Columns written out left to right before moving to the next row.  Rows written out top to bottom.

t-
tc	Mr, MR                            
tc	16 UTF8 readable numbers separated by at least one separator.  Columns written out left to right before moving to the next row.  Rows written out top to bottom.

t-
tc	c4, C4                            
tc	4 UTF8 readable numbers separated by at least one separator.

]t

	If using 'A' array flag the above is repeated as many times as there are array elements.  Each array element will be separated by at least one separator.

t[
t-
thx	Type Code
th*	Representation (e encoding flag)

t-
tc	az, ad, co, Co, dd, d%, d:, i1, i2, i4, i8, id, ix, Ix, n1, n2, n4, n8, of, Of, r4, r8, sz, Sz
tc	Values are converted to Big Endian, then encoded into a string using base64.

t-
tc	pr, pR, pi, pI, pn, pN, Ad, A%, A:                        
tc	Values are converted to Big Endian, then encoded into a string using base64.  No separation of the 2 numbers.

t-
tc	Pr, PR, Pi, PI, Pn, PN, c3, C3                            
tc	Values are converted to Big Endian, then encoded into a string using base64.  No separation of the 3 numbers.

t-
tc	mr, mR                                                    
tc	Values are converted to Big Endian, then encoded into a string using base64.  No separation of the 9 numbers.  Columns written out left to right before moving to the next row.  Rows written out top to bottom.

t-
tc	Mr, MR                                                    
tc	Values are converted to Big Endian, then encoded into a string using base64.  No separation of the 16 numbers.  Columns written out left to right before moving to the next row.  Rows written out top to bottom.

t-
tc	c4, C4                                                    
tc	Values are converted to Big Endian, then encoded into a string using base64.  No separation of the 4 numbers.

]t

	A: and d:, the ratio for the dip portion is 1 : [value].  [value] is what is stored.  It is an r4 value.
	C3 and C4, the values are r4 and range between 0.0 and 1.0.
	If using 'E' array flag the values are encoded into base64 all together and not separated by any spaces.
	If using 'z' or 'Z' encoding flag, take the 'e' or 'E' data buffer, compress it using zlib and then write out the base64 string representation of the compressed buffer.


****	[chapter] - bi

	The binary data will have a header of 1 unsigned integer value before the binary data.  This value indicates the byte count of the binary data.  This byte count is not included when using Base64 ro Zlib compression.  However the binary data will honor Base64 and Zlib compression if used.

[[
image bn 10 0 1 2 3 4 5 7 8 9\n

image bnA 2\n
10 0 1 2 3 4 5 6 7 8 9\n
10 9 8 7 6 5 4 3 2 1 0\n
]]

	Binary blobs are dangerous and should be used rarely if at all.  If someone uses them then they should be on the hook to define what the contents of the blob mean.  If they do not, then they are being bad citizens and should be shamed!
	However this is here as a catchall just in case.


****	[chapter] - bo

	Boolean data is a little different than the basic types above.
	No encoding flag, the value will be 't' for true, or 'f' for false.
	'A' encoding flag, the value will be a string of 't' or 'f' letters with no separator in between to save some space.
	'E' encoding flag will mean the flags are encoded in to a bit map where...

[[
Byte 0                            Byte 1
+---+---+---+---+---+---+---+---+ +---  ...
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | | 8
+---+---+---+---+---+---+---+---+ +--- ...
 2^7 2^6 ...                 2^0   2^8 ...                   
]]

	0, 1, 2, ... indicates the index into the array and how it relates to the bytes.  So each bit will either be 1 (true) or 0 (false).  This byte stream then gets converted to base64.
	'Z' will take the above bitmap and compress it first before encoding it with base64.
	'e' and 'z' encoding flags are never used with this type.

[[
IsFaceVisible bo t\n
IsOptimized bo f\n
]]


****	[chapter] - g*, G*

	[b=]g3, g4, G3, G4[=b]

[	[g3|g4|G3|G4] [pixel count with] [pixel count height] [pixel buffer]

	g3, g4, G3, G4 graphic options will have a header of 2 unsigned integer values before the image data.  These values indicate width and height of the graphic.  These values are not included in the Base64 or Zlib compression if compression is used.  However the image data will honor Base64 or Zlib compression if used.
	Images are written out row by row, left to right, top to bottom.
	Array of graphics will place each graphic on a separate line similar to string encoding.

[[
image g3 2 2 0 0 0 64 64 64 128 128 128 192 192 192\n

image g3A 2\n
2 2 0 0 0 64 64 64 128 128 128 192 192 192\n
2 2 64 64 64 128 128 128 192 192 192 255 255 255\n
]]

	[b=]gf[=b]

[	gf [three letter file format] [file size] [file data]

	gf graphic option will have a 3 letter image identifier for the file type, an unsigned integer for the file size, and then the file that represents the image, copied verbatum into the value portion.  There is never any compression applied.  The data is always base64 encoded.  e, E, z, and Z are never used.

[[
imageFile gf png 1024 [base64 encoding of a png file data]\n

imageFileList gpA 2\n
jpg 2048 [base64 encoding of a jpg file 1 data]\n
tif 4096 [base64 encoding of a tiff file 2 data]\n
]]

	[b=]gl[=b]

[	gl [string of path to file]

	gl graphic option simple contains a link to an image file.  This path should be relative to the MIFF file if not right next to the MIFF file.  However this is up to the software writing the MIFF file.  z, and Z are never used for this type.

[[
imageFileLink gl \path\to\image\file\image.png\n

imageFileLinkList glA 2\n
\path\to\image\file\image1.png\n
\path\to\image\file\image2.png\n
]]


****	[chapter] - ty

	ty stores a 2 letter type format.  Used for describing what something external to the base format will store as a value.

[	ty [2 letter type value]

[	type ty PR


****	[chapter] - t*

	td, tt, t* store time values.

[[
td [date]
tt [time]
t* [date] [time]
]]

	[date] values are only stored one way in readable UTF8, "YYYY-MM-DD" where YYYY, MM, DD are unsigned integers.  MM and DD are 0 padded.
	[time] values are only stored one way in readable UTF8, "HH:MM:SS" where HH, MM, SS are unsigned integers.  HH is 24 hour Greenwich Time zone, no daylights correction.
	Binary representation if encoded as base64 will be n2 for year and n1 for all other values and ordered in the same year, month, day, hour, minute, second.

[	date t* 2019-01-31 20:30:40\n


****	[chapter] - vs

	A Value Stream is a departure of the base format.  It is meant to be used to compress the data storage more with a simpler key value structure which will be dictated by the format that uses MIFF as a base format.
	Keys will typically be 1 byte.  Values will be a known sized based on the key or other information of the format.


**	[chapter] - Binary

	The Binary file will to match the Text file 1-1.  Everything within '[]' is a byte sequence of a known size.  Each byte seqence is separated here with a comma but is immediately following after previous byte sequence.
	A byte sequence is [[size]:[name]], where size is a number indicating the number of bytes this sequence takes up.


***	[chapter] - Key Value Format

[	[1:key string length],[key string length:key],[3:value header],[4;array count],[4:compress buffer size],[*:value]


****	[chapter] - Key

	[key string length] is the first byte sequence and defines how long the key string is in bytes.
	[key] is the second byte sequence and defines the key of the key value pair.  The length of which was defined by [key string lenght] above.  This means keys can not exceed 255 bytes.  No null terminator is used for the key.


****	[chapter] - Value Header

	[value header] is the third byte sequence and is 3 bytes.  2 bytes for the value type 2 letter identifier and 1 bytes for the array and encoding letter.  See MIFF Format: Base / Content / Value Header section for an explanation.
	e, and E are never used in binary mode.  The data is stored raw and no encoding is actually done.
	' ' is used for an uncompressed single value.
	'A' is used for an uncompressed array of values.
	z and Z will apply Zlib compression to the binary data.
	[array count] and [compress buffer size] are only present when certain value header conditions are present.  Meaning [array count] byte sequence is only present when storing an array of values; [compress buffer size] is only present when the value is compressed with zlib compression routines.  If neither of these are present in the value header then these byte sequences are not present.
	Both [array count] and [compress buffer size] are 4 byte unsigned integers stored in network order.


****	[chapter] - Value

	[value] field will vary wildly depending on the [value header], [array count], and [compress buffer size] values.  But it will be a known size given that information.


***	[chapter] - Value Specifics


****	[chapter] - Key-Value Block

	This indicates the start of a Key-Value block.  There technically is no value.  The next byte after the [value header] is the start of the first key in the block.
	A block is terminated when the [key string length] is equal to 0.

[[
[8],["itemList"],["kv "],
[> 0 key string length],...
[> 0 key string length],...
[> 0 key string length],...
[0]
]]

	Hopefully the above explains it.  I have defined an "itemList" key which starts the key value block.  If the next key value has a key string length that is > 0 then it is part of the itemList key value block.  The last key string length is 0 which indicates that the block is done.  Anything that follows the block is a new key value thing.


****	[chapter] - ""

	String encoding is simpler than in the text case.

[[[4:string length][string length:string]]]

	Each string is prefixed with a [string length], the byte count of the UTF8 string.  Then you just dump out the string in UTF8 format.
	Array of strings will have as many of these pairs as found in the array.


****	[chapter] - a*, A*, c*, C*, d*, i*, m*, M*, n*, p*, P*, r*

	Simple value encoding.  Based on what is being stored the byte streams only look slighly different.

t[
t-
thx	Type
th*	Byte Count

t-
tc	i1, n1                                    
tc	  1

t-
tc	i2, n2                                    
tc	  2

t-
tc	c3                                        
tc	  3 (3 x 1 Byte)

t-
tc	az, ad, dd, d%, d:, i4, ix, n4, r4, of, sz
tc	  4

t-
tc	c4                                        
tc	  4 (4 x 1 Byte)

t-
tc	i8, Ix, n8, r8                            
tc	  8

t-
tc	Ad, A%, A:, pr, pi, pn                    
tc	  8 (2 x 4 Byte)

t-
tc	c4, Pr, Pi, Pn                            
tc	 12 (3 x 4 Byte)

t-
tc	pR, pI, pN                                
tc	 16 (2 x 8 Byte)

t-
tc	PR, PI, PN                                
tc	 24 (3 x 8 Byte)

t-
tc	C4                                        
tc	 32 (4 x 8 Byte)

t-
tc	mr                                        
tc	 36 (9 x 4 Byte)

t-
tc	Mr                                        
tc	 64 (9 x 8 Byte)

t-
tc	mR                                        
tc	 72 (16 x 4 Byte)

t-
tc	MR                                        
tc	128 (16 x 8 Byte)

]t

	The values are simply encoded as such.

[	[bytes count:value]

	Again, multi-byte values are store in big endian (network order).
	Arrays of these values are simply repeating the above as many times necessary for the array.


****	[chapter] - bi

	Binary encoding is like string encoding.  We need a byte count before the buffer data.

[	[4:byte count][byte count:buffer data]

	byte count will never be compressed when compression is used but buffer data will.
	Array of binaries will have as many of these pairs as found in the array.

****	[chapter] - bo

	Boolean data is a little different than the basic types above.
	[b=]Single Value[=b]

[	[1:Byte]

	The value will be 't' for true, or 'f' for false.
	[b=]Array of Values[=b]

[	[(Array Count) / 8:Bytes]

	'A' encoding flag will mean the flags are encoded in to a bit map where...

[[
Byte 0                            Byte 1
+---+---+---+---+---+---+---+---+ +---  ...
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | | 8
+---+---+---+---+---+---+---+---+ +--- ...
 2^7 2^6 ...                 2^0   2^8 ...                   
]]

	0, 1, 2, ... indicates the index into the array and how it relates to the bytes.  So each bit will either be 1 (true) or 0 (false).  This byte stream then gets converted to base64.
	'Z' will take the above bitmap and compress it first before encoding it with base64.

****	[chapter] - g*, G*

	[b=]g3, g4, G3, G4[=b]

[	[4:width][4:height][width * height * size of [c3|c4|C3|C4]:graphic data]

	Raw graphic data size will be (unsigned integer) width * (unsigned integer) height * size of the color item.  It will be the compressed size in the file if compression is used but the raw size in memory.
	[b=]gf[=b]

[	[4:image file size][image file size:binary buffer of the image file]

	[b=]gf[=b]

[	[4:string length][string length:file path]


****	[chapter] - ty

[	[2:1 letter Type Identifier]

	The two letter identifier as defined in MIFF Format: Base / Content / Key Value Format / Value Header Section


****	[chapter] - t*

	td, tt, t* store time values.

[[
td = [n2:Year Value][n1:Month Value][n1:Day Value]
tt = [n1:Hour Value][n1:Minute Value][n1:Second Value]
t* = [n2:Year Value][n1:Month Value][n1:Day Value][n1:Hour Value][n1:Minute Value][n1:Second Value]
]]

	Year value is the present year as is.  Month value is the month value starting at 1 being January.  Similarly Day starts at 1.
	Hour value is 24 hour Greenwich Time zone, no daylights correction starting at 0.  Minute and Second are both starting at 0.


****	[chapter] - vs

	A Value Stream is a departure of the base format.  It is meant to be used to compress the data storage more with a simpler key value structure which will be dictated by the format that uses MIFF as a base format.
	Keys will typically be 1 byte.  Values will be a known sized based on the key or other information of the format.


*	[chapter] - Design Decisions:

	[b=]Why not XML or JSON?[=b]<br /> I did not take XML as a format because it is too verbose.  JSON is very flexible but I also find it is still unnecessarily verbose.  Better than XML but still unacceptable in my opinion.  Considering the data, I do not want a format that would cause too much data bloat.  There will always be some bloat happening but it should be mitigated in my opinion.
	[b=]Why network order for multibyte data types?[=b]<br /> In the past my company was multi-platform, SGI IRIX, SUN OS, SUN Solaris and Windows NT.  At that time the architecture on some of the other platforms was Big Endian and we stored the data in the native format of the machine.  However this lead to issues when users moved their data over to a Little Endian machine which Windows has always been.  The problems that we faced were trivial to solve but just very annoying and yet anothering thing to remember.  So standardizing on one option is easier than having to support two options.  I go with simplicity, only one option to rule them all!  It keeps things simpler.

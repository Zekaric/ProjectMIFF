<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href="style_reset.css">
  <link rel="stylesheet" type="text/css" href="style.css">
  <title>M.I. M.I.F.F.: Mining Interchange MIFF</title>

  <!-- Script for generation a table of contents -->
  <script>
const indexLEVEL     = 0;
const indexTAG       = 1;
const indexTITLE     = 2;
const indexHAS_TYPE  = 3;
const indexHAS_CONST = 4;
const indexHAS_FUNC  = 5;
const indexCOUNT     = 6;

var tocIndex = 0;
var toc      = [];

// Display a header line and add to the table of contents (TOC)
function HeaderAdd(level, tag, title)
{
   var record = [];
   
   record[indexLEVEL]     = level;
   record[indexTAG]       = tag;
   record[indexTITLE]     = title;
   record[indexHAS_TYPE]  = false;
   record[indexHAS_CONST] = false;
   record[indexHAS_FUNC]  = false;

   toc.push(record);

   // Chrome complains about this document write.  I have looked for an alternative but everything
   // I have found is utter rubbish.  HeaderAdd is only called on doc load.  This call is not a
   // problem.
   document.write("<h" + level + "><a name=\"" + tag + "\">" + title + "</a></h" + level + ">\n\n");
}

function HeaderAddType()
{
   var record = toc[toc.length - 1];

   record[indexHAS_TYPE] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Type\">Type</a></h2>\n\n");
}

function HeaderAddConst()
{
   var record = toc[toc.length - 1];

   record[indexHAS_CONST] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Const\">Constant</a></h2>\n\n");
}

function HeaderAddFunc()
{
   var record = toc[toc.length - 1];

   record[indexHAS_FUNC] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Func\">Function</a></h2>\n\n");
}

// Update the TOC with all the header lines.
function UpdateToc()
{
   var value;
   var record;
   var index;

   value = "<table>\n";

   for (; tocIndex < toc.length; tocIndex++)
   {
      record     = toc[tocIndex];
    
      value += "<tr>\n<td>";
    
      // Indenting
      for (index = 1; index < record[0]; index++)
      {
         value += "&nbsp;&nbsp;&nbsp;&nbsp;";
      }

      value += "<a href=\"#" + record[1] + "\">" + record[2] + "</a></td>\n";
      
      value += "<td>";
      if (record[indexHAS_TYPE] == 1)
      {
         value += "<a href=\"#" + record[1] + "Type\">Type</a>\n";
      }
      value += "</td>\n";
      
      value += "<td>";
      if (record[indexHAS_CONST] == 1)
      {
         value += "<a href=\"#" + record[1] + "Const\">Constant</a>\n";
      }
      value += "</td>\n";

      value += "<td>";
      if (record[indexHAS_FUNC] == 1)
      {
         value += "<a href=\"#" + record[1] + "Func\">Function</a>\n";
      }
      value += "</td>\n";

      value += "</td>\n";
   }

   value += "</table>\n";

   document.getElementById("toc").innerHTML = value;
}
  </script>
 </head>
 <body>
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <h1 class="page">M.I. M.I.F.F.: Mining Interchange MIFF</h1>

  <table>
   <tr>
    <td><p>Author:</p></td>
    <td>Robbert de Groot</td>
   </tr>
   <tr>
    <td><p>Date:</p></td>
    <td>2019-05-15</td>
   </tr>
   <tr>
    <td><p>Copyright:</p></td>
    <td>2019, Robbert de Groot</td>
   </tr>
   <tr>
    <td><p>License:</p></td>
    <td>The library will be MIT License.</td>
   </tr>
   <tr>
    <td></td>
    <td>This document is licensed under Creative Commons Attribution-NoDerivs. 
	<a href="https://creativecommons.org/licenses/by-nd:4.0/">(CC BY-ND)</a></td>
   </tr>
  </table>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <h1>Table Of Contents:</h1>

  <p id="toc"></p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "miff", "M.I. M.I.F.F.");</script>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "about", "Discussion");</script>

  <p>What is the purpose of M.I. M.I.F.F. (MI-MIFF)?  MI-MIFF is intended to be a file format for 
  exporting and importing data from one mining software package to another software package.</p>

  <p>Users of software packages are becoming increasingly annoyed at the lack of interoperability
  between software packages.  Currently each software package attempts to do its best at supporting
  competitor file formats but there is often a lot of loss of data or, as data formats in each
  package evolves, suffer from compatibility issues.  Often data needs to be dumped to formats that
  come 'close' but are not exact or down to very basic, raw ASCII files, like csv files, which are
  often lacking compared to the original data.  Users will need to massage this raw data in order
  to import it into their target software package.</p>

  <p>A lot of the client's time is lost with all this work.  The idea with an interchange format is
  to remove some of the pain of this data transfer task and put more of the pain on the software
  vendors of doing the hard part of reading in the data to their expectations.  The software users
  will not need to know some of the intricacies of the data or task.</p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "goals", "Goals");</script>

  <p>The main goal of this format is to be specifically an interchange format.  It is not intended
  to be a native format for any software package.  The focus is to make it easy for the developers
  from any software package to export their data to this interchange format and, without too much
  difficulty, to import other vendor's data.</p>

  <p>For the users of the software packages, the process of moving data from package to package will
  be much easier, less time consuming, and less problematic as they will only have to export and 
  import to just one type of file instead of various file formats and requiring more intimate 
  knowledge of the data transfer process specific to their software packages.</p>

  <ul>
   <li><strong>Simple</strong>.  The format should be simple for the developers to export their 
   data.  Import may still be challenging because of the differences between software packages but
   the format to import the data should not impose too much pain for the developers either.  The
   simplicity should go a long way in getting the format adopted and implemented.</li>

   <li><strong>Inclusive</strong>.  All data from all venders should be representable with the least
   amount of compromizes in the data being exported.</li>

   <li><strong>Brief</strong>.  The format should not produce unnecessary waste.  The data in some
   cases will be quite large so it should not bloat the data too much.  Meaning, file sizes should
   not become overly large.  However, because of point 1 there will always be some bloat.</li>

   <li><strong>Flexible</strong>.  The format needs to be able to accomodate change or vendor
   specific data.  A few software vendors started life in the 70's with time shared machines.  Over
   the years the amount of data and the types of data the clients want to maintain has changed and
   grown.  A format needs to try its best to keep up without importers and exporters to be
   completely remade.</li>
  </ul>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "disclosure", "Disclosure");</script>

  <p>As of this writing I, Robbert de Groot, am a Principal Software Developer with Hexagon
  (previously known as (pka) Hexagon Mining, pka MineSight, pka Mintec Inc.), the current owners of
  MinePlan 3D software (pka MineSight 3D; pka MEDSystem.); Leica Geosystems, the makers of survey
  equipment and related material; as well as other mine related hardware and software products.</p>

  <p>This format is currently not sanctioned by any software vendor, including Hexagon.  This was
  something I am doing as an experiment to satisfy my curiosity.  It was brought about by recent
  efforts being made by Global Mining Guidelines (GMG), with their Open Mining Format (OMF), which
  seems to have the backing of some big players in the industry.  My issue with OMF, for now, is
  that they only have a Python library that implements the format available publically.  They may
  have a specification document somewhere but currently it is not available, or at least I cannot
  find it anywhere in the 'open'.  Plus this format seems to be strictly binary, which is not
  entirely a bad idea considering the data that needs to be passed around, but binary formats can be
  very fussy.  And inspecting their sample OMF file, it does not look like something that is easily 
  reverse engineered.</p>

  <p>So, I thought I would try my hand at defining a format what I think would be good as an
  interchange format.  I am trying to write MIFF independent of any software package.  However there
  may be some unintended bias as I am most familiar with MinePlan 3D for which I have worked on 
  since 1995.  I do intend to keep this format as inclusive as possible to address other software 
  package requirements as best as I understand them.  I know I will make mistakes there because I 
  have only cursory knowledge of most of the competing software in the industry.</p>

  <p>If anyone is interested in educating me on some features they would like to see with respect to
  their software package of choice I would love to hear from you.  You can reach me at either of the
  following two email addresses.</p>

  <p>robbert.degroot@hexagon.com<br />zekaric@gmail.com</p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "formatMine", "MI-MIFF Format");</script>

  <p>See the MIFF_Mixed_Information_File_Format.htm file for the discussion of the base file format
  which is being used for the interchange file format.  This document will cover specifics related
  to using MIFF for mining as an interchange file format to move data.</p>

  <p>The data mining companies need to keep track of and transfer around.</p>

  <ul>
   <li>
    Geometry
    <ul>
     <li>
      3D
      <ul>
       <li>Points</li>
       <li>Polylines (open and closed)</li>
       <li>Surfaces:Generic (open and closed (solids))</li>
       <li>Surfaces:Grid</li>
       <li>Text</li>
       <li>Symbol</li>
      </ul>
     </li>
     <li>
      2D (Planar, Fence)
      <ul>
       <li>Points</li>
       <li>Polylines (open and closed)</li>
       <li>Text</li>
       <li>Symbol</li>
      </ul>
     </li>
    </ul>
   </li>
   <li>
    Drillhole
    <ul>
     <li>Drillhole survery information.</li>
     <li>Drillhole assay information.</li>
     <li>Drillhole composite information.</li>
     <li>Blast hole shot information.</li>
     <li>Chip assay information.</li>
     <li>Design vs surveyed information.</li>
    </ul>
   </li>
   <li>
    Model
    <ul>
     <li>
      Block model information.
      <ul>
       <li>Regular</li>
       <li>Sub-blocked</li>
       <li>Seam</li>
      </ul>
     </li>
     <li>
      Seam model information.
      <ul>
       <li>Regular</li>
       <li>Sub-blocked</li>
      </ul>
     </li>
     <li>
      Surface model information.
      <ul>
       <li>Regular</li>
       <li>Sub-blocked</li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>

  <p>MI-MIFF will handle all these types of data.  However, how each is actually stored in MIFF can
  vary.</p>
  
  <p>File naming can help in MIFF file importing.  It is suggested to use the following file 
  extensions...</p>
  
  <table>
   <tr><th>Extension</th><th>File Contents</th></tr>
   <tr><td>*.miff      </td><td>Still valid but can be anything.  What is it?</td></tr>
   <tr><td>*.miffDrill </td><td>for Drillhole data.</td></tr>
   <tr><td>*.miffGeom  </td><td>for Geometry data.</td></tr>
   <tr><td>*.miffModel </td><td>for Model data.</td></tr>
   <tr><td>*.miffMI    </td><td>for a very general Mine Interchange of anything above.</td></tr>
  </table>
  
  <p>This information is duplicated inside the file so reading in the file will confirm with the 
  extension but it will help the user if the extension is properly set and will make it easier on 
  the software on how to read in the file if these are properly set.</p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "formatMineHeader", "Header");</script>
  
  <p>MIFF has fields for a Sub-Format Name and Version.  For a MI-MIFF file this will be set to...</p>
  
  <table>
   <tr><td>Sub-Fromat Name</td><td>Mining Interchange</td></tr>
   <tr><td>Sub-Format Version</td><td>1</td></tr>
  </table>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "formatMineInfo", "Information Block");</script>

  <p>Common to all MI-MIFF files for any of the types above, there will be an information 
  block providing general, project wide information.</p>
  
  <p>This information block will be the very first key value in the file right after the MIFF 
  header.</p>

  <table>
   <tr><th>Key</th><th>Value&nbsp;Header</th><th>Value</th></tr>
   <tr><td>info</td><td>kv</td><td>See below.</td></tr>
  </table>

  <p>Inside the information block we have the following possible key values.  Not all are required.
  </p>

  <table>
   <tr><th>Key</th><th>Value&nbsp;Header</th><th>Value</th>
   <tr><td>type           </td><td>""</td><td>File type of the MI-MIFF.  One of...<br />
   Mixed - Combinatino of any of the types below.<br />
   Drillhole - Only holds drillhole data.<br />
   Geometry - Only holds geometry data.<br />
   Model - Only holds model data.</td></tr>
   <tr><td>company        </td><td>""</td><td>Name of company that the data belongs to.</td></tr>
   <tr><td>copyright      </td><td>""</td><td>Copyright information for the data.</td></tr>
   <tr><td>author         </td><td>""</td><td>The name of the author of this data.</td></tr>
   <tr><td>dateCreated    </td><td>t*</td><td>The date this data was created on.</td></tr>
   <tr><td>dateModified   </td><td>t*</td><td>The date this data was modified.</td></tr>
   <tr><td>comment        </td><td>""</td><td>Comments relevant to this file.</td></tr>
   <tr><td>software       </td><td>""</td><td>The software that prepared this file.</td></tr>
   <tr><td>softwareVersion</td><td>""</td><td>The software version that prepared this file.</td></tr>
   <tr><td>projectName    </td><td>""</td><td>The project name associated with the data.</td></tr>
   <tr><td>projectMin     </td><td>PR</td><td>The project minimum coordinate.  This need not be exact or present.</td></tr>
   <tr><td>projectMax     </td><td>PR</td><td>The project maximum coordinate.  This need not be exact or present.</td></tr>
   <tr><td>projectSystem  </td><td>""</td><td>The coordinate system used for the coordinated found in the file.</td></tr>
  </table>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "formatMineGeometry", "Geometry");</script>
  
  <p>The types of data that are common to store as geometry are...</p>
  
  <ul>
  <li>Point</li>
  <li>Point Cloud</li>
  <li>Symbol</li>
  <li>Text</li>
  <li>Polyline (simple open and closed polylines)</li>
  <li>Polyline (complex open and closed polylines)</li>
  <li>Surface (irregular surface, open and closed (solid))</li>
  <li>Surface (regular surface, open (and closed?))</li>
  <li>Grid (plane and fence definitions)</li>
  </ul>
  
  <p>Point data is just that, a single east, north, and elevation.  But also associated with that 
  point we may have other values that the user may want to record with that location in space.</p>
  
  <p>Point Cloud data is a little more involved than just point data.  Mainly a point cloud is still
  just points but the points are all related to each other in some manner so they should be treated
  as a unit instead of as individual parts.</p>
  
  <p>Symbol data is a little more involved than a simple point.  Not only does it have all the 
  information of a point but it also has orientation in space as well as all the other information
  that points have.  Sybols are also complex in that their display geometry can be a combination of
  points, polylines, and simple text.</p>
  
  <p>Text data is a little more involved than a point and more like a symbol in that it will have
  orientation in 3D space.</p>
  
  <p>Polyline data is an ordered list of point data where there is a connection between successive
  points in the list.  The simple polyline is a single connect line in space.  A simple polygon is
  when there is a duplicated end point that matches the start point.  A complex polyline is a line
  that is disjoint in space but the disjoint lines are all still treated as one polyline.  A complex
  polygon is one where you may have voids inside a polygon.  A slice of Swiss cheese if that makes a
  a more accurate image in your mind.  The collection of polygons should still be treated as one
  thing.</p>
  
  <p>Surface data defines some sort of 3D boundary from inside and outside, at a transition or 
  other.  The irregular case is where the surface is defined by a point list as well as a face
  connectivity list.  This means triangles need not be all the same size.  The regular case is 
  defining just a point list where it is structured in a grid where there is a known row and column
  count.</p>
  
  <p>Grid data is defining planes in space or vertical fence in space.  Mainly used for defining 2D
  data.</p>
  
  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formatMineGeomInfo", "Geometry Block");</script>

  <p>After the general information block the next block will be a Geometry Information block.  There
  can, and probably will, be multiple of these Geometry blocks in a single file.</p>

  <table>
   <tr><th>Key</th><th>Value&nbsp;Header</th><th>Value</th></tr>
   <tr><td>geom</td><td>kv</td><td>See below.</td></tr>
  </table>

  <p>Inside, you will find most of the following key values.</p>

  <table>
   <tr><th>Key</th><th>Value&nbsp;Header</th><th>Value</th>
   <tr><td>itemList</td><td>kv</td><td>A list of items for the element level.  Any element type can have 
   element level attributes.</td></tr>
   <tr><td>itemListPoint</td><td>kv</td><td>A list of items for the point level.  Usually only used
   on Points, PointCloud, and Polyline types.</td></tr>
   <tr><td>itemListEdge</td><td>kv</td><td>A list of items for the edge level.  Only for Polyline 
   types.</td></tr>
   <tr><td>point<br />
   pointCloud<br />
   text<br />
   symbol<br />
   polyline<br />
   polylineComplex<br />
   surface<br />
   surfaceGrid<br />
   grid</td><td>kv</td><td>It will be one of the keys to the left.  And see below as to the contents
   of this which depends on the key.  There can be more than one of these kv inside the geometry
   block</td></tr>
  </table>
  
  <p>For itemList* see the ItemList section below.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatMineGeomInfoDataPoint", "Point");</script>
  
  <p>This will allow the storage of point data where each point in the collection of points is its
  own entity and not necessarily related to any neighboring point.  For space all points are grouped
  together.</p>

  <table>
   <tr><th>Key</th><th>Value&nbsp;Header</th><th>Value</th></tr>
   <tr><td>data</td><td>vs</td><td>See below on the value stream.</td></tr>
  </table>
  
  <p>The contents of data is a simpler data stream.</p>
  
  <pre>[n4:point count] [PR, Point] [item values] ... [PR, Point] [item values] ...</pre>
  
  <p>The first part of the stream is the point count.  This will indicate how many points are 
  stored.  Each point will have the the point triplet as well as all the item values in the order
  they were defined.  This pattern is duplicated for as many times as dictated in point count.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatMineGeomInfoDataPointCloud", "Point Cloud");</script>
  
  <p>In a way it is almost exactly like the point above except there can be element level item 
  values that the group of points will share.  The group of points are considered one entity in the
  end.</p>

  <table>
   <tr><th>Key</th><th>Value&nbsp;Header</th><th>Value</th></tr>
   <tr><td>data</td><td>vs</td><td>See below on the value stream.</td></tr>
   <tr><td>itemList</td><td>vs</td><td>See below on the value stream.</td></tr>
  </table>
  
  <p>The contents of data is a simpler data stream.</p>
  
  <pre>[n4:point count] [[PR:location] [item values]]*</pre>
  
  <p>The first part of the stream is the point count.  This will indicate how many points are 
  stored.  Each point will have the the point triplet as well as all the item values in the order
  they were defined.  This pattern is duplicated for as many times as dictated in point count.</p>
  
  <p>itemList is the item values for the entire point cloud instead of each point in the cloud.  
  The values are in the order they are listed and their size are as they are defined by the item.</p>
  
  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatMineGeomInfoDataText", "Text");</script>
  
  <p>This will allow the storage of text data where each text element in the collection of text 
  elements is its own entity and not necessarily related to any neighboring point.  For space all
  text elements are grouped together.</p>

  <table>
   <tr><th>Key</th><th>Value&nbsp;Header</th><th>Value</th></tr>
   <tr><td>data</td><td>vs</td><td>See below on the value stream.</td></tr>
  </table>
  
  <p>The contents of data is a simpler data stream.</p>
  
  <pre>[n4:text count] [[FR:location triangle] [en:fixed,forward,upright] [bo:isBlockAlignmentFlipping, isAlignmentFlipping, isRelativeSized] ["":font] [r4:font size] [en:block alignment] [en:line alignment] ["":text] [item values]]*</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatMineGeomInfoDataSym", "Symbol");</script>
  
  <p>This will allow the storage of text data where each text element in the collection of text 
  elements is its own entity and not necessarily related to any neighboring point.  For space all
  text elements are grouped together.</p>

  <table>
   <tr><th>Key</th><th>Value&nbsp;Header</th><th>Value</th></tr>
   <tr><td>data</td><td>vs</td><td>See below on the value stream.</td></tr>
  </table>

  <p>The contents of data is a simpler data stream.</p>
  
  <pre>[n4:text count] [[FR:location triangle] [en:fixed,forward,upright] [bo:isFlipping, isRelativeSized] ["":symbol] [item values]]*</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatMineGeomInfoDataPoly", "Polyline");</script>
  
  <p>This will allow the storage of polyline data where each polyline in the collection of polylines 
  is its own entity and not necessarily related to any neighboring polyline.</p>

  <table>
   <tr><th>Key</th><th>Value&nbsp;Header</th><th>Value</th></tr>
   <tr><td>itemList</td><td>vs</td><td>See below on the value stream.</td></tr>
   <tr><td>data</td><td>vs</td><td>The list of point lists for each of the simple polylines.</td></tr>
  </table>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "formatMineModel", "Model");</script>

  <p>Some of the information found here is based off of the block model formats that are used at
  Hexagon, where I work, but also from information found freely on the internet.</p>

  <p><a href="https://www.deswik.com/wp-content/uploads/2019/01/Block-model-knowledge-for-mining-engineers-An-introduction-1.pdf">Block Model Knowledge For Mining Engineers - An Introduction</a></p>

  <p>There are 3 basic model formats that are in use as Hexagon.</p>

  <ul>
   <li>Block Model</li>
   <li>Seam Model</li>
   <li>Surface Model</li>
  </ul>

  <p>Block Model is a regular collection of, usually, uniform blocks.  Each block will have values
  for items that are being tracked by the client.</p>
  
  <p>Seam Model is a bit fancier Block Model.  This model is subdivided uniformly in the row and
  column directions of the model but instead of levels, seams are described.  Each block in a seam
  will have an elevation top and bottom to indicate the seam's limits, as well as any other values
  that are found within that seam block just like a normal block model.</p>
  
  <p>Surface Model is much more limited than the other two as it just holds a stack of surfaces
  instead of defining any volume.  This model is subdivided uniformly in the row and column
  directions of the model but instead of seams you will have a surface.  Each 'block', or really the
  contact point, for a surface will have an elevation value as well as other values that are being
  tracked by the client at that surface point.</p>
  
  <p>Even though only Block Models are sub-blocked, Mi-MIFF does not limit you to only allowing
  sub-blocks for Block Models.  The logic could be applied to the other two types of models.  As far
  as I know, no software vendors sub-block for Seam or Surface Models.</p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formatMineModelInfo", "Model Block");</script>

  <p>After the general information block the next block will be the model block.  Typically in a 
  single model file you would only have just the one model.  However there is nothing restricting
  the format to have more than one model block.</p>

  <table>
   <tr><th>Key</th><th>Value&nbsp;Header</th><th>Value</th></tr>
   <tr><td>model</td><td>kv</td><td>See below.</td></tr>
  </table>

  <p>Inside, you will find most of the following key values.</p>

  <table>
   <tr><th>Key</th><th>Value&nbsp;Header</th><th>Value</th>
   <tr><td>type          </td><td>""</td><td>The mode type.  One of...<br />
   Block - For a block model.<br />
   Seam - For a seam model.<br/>
   Surface - For a surface model.<br /></td></tr>
   <tr><td>isSubblocked  </td><td>bo</td><td>True if subblocked.</td></tr>
   <tr><td>subblockType  </td><td>""</td><td>The subblock type.  One of...<br />
   Fixed<br />
   Semi<br />
   Octree<br />
   Free<br />
   (See below for more details.)</td></tr>
   <tr><td>subblockOption</td><td>Pn</td><td>This subblock option is for Fixed subblocking and will define how many subdivisions are used per block.</td></tr>
   <tr><td>subblockOption</td><td>pn</td><td>This subblock option is for Semi subblocking and will define how many subdivisions are used for the row and col directions.</td></tr>
   <tr><td>subblockOption</td><td>n1</td><td>This subblock option is for Octree subblocking and will define how many levels of octree splits are allowed.</td></tr>
   <tr><td>origin        </td><td>PR</td><td>The top most, minimum point for the model.</td></tr>
   <tr><td>colVec        </td><td>PR</td><td>The column vector.  This defines the direction of increasing column index.  The length of this vector is the length of the block in this direction. </td></tr>
   <tr><td>rowVec        </td><td>PR</td><td>The row vector.  This defines the direction of increasing row index.  The length of the vector is the length of the block in this direction.</td></tr>
   <tr><td>levVec        </td><td>PR</td><td>The level vector.  This defines the direction of increasing level index.  The length of the vector is the length of the block in this direction.  However the length may be unit if the block model is using variable level heights.</td></tr>
   <tr><td>blockCount    </td><td>Pn</td><td>The number of column, row, and level blocks.</td></tr>
   <tr><td>isLevVariable </td><td>bo</td><td>True if variable level heights are used.  levList should follow.</td></tr>
   <tr><td>levList       </td><td>r4</td><td>Always an array of values.  The values will be the length of each level and must match the block level count.</td></tr>
   <tr><td>itemList      </td><td>kv</td><td>The items stored per block in the model.  This can be an array of Items.  See Item below for item information.</td></tr>
   <tr><td>data          </td><td>vs</td><td>See below for the contents</td></tr>
  </table> 
  
  <p>See ItemList section for itemList structure.</p>
   
  <p>For both block and subblock, indexing of a block in the model will look like the image below.</p>

  <pre>
       \   /
        \ /
         +  Column 1
        / \
 Row 1 /   \   /
      /     \ /
     /Lev 0  +
\   / Row 0 /|
 \ /  Col 0/ |
  +       / <----- colVec (Length is block size. Direction is direction of increasing column index.)
  |\     /   |/
  | \ <----------- rowVec (Length is block size. Direction is direction of increasing row index.)
\ |  \ /    /|
 \|   o <--------- origin (3D point indicating the outter most corner of the first block.)
  +   |   /
  |\  | <--------- levVec (Length can be block size or unit, depends see below. Direction is direction of increasing level index.)
  | \ | /
     \|/
      +
      | Level 1
      |
</pre>

  <p>The origin is the extreme most point of the first column, first row, and first level block of 
  the model.</p>
  
  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatMineModelInfoSubblock", "Subblock Type");</script>
  
  <p><strong>fixed</strong> For a regular division of the block in the east, north, and z directions
  of the block.</p>
  
  <pre>
Using just a cross section.
Level +--+--+--+--+
  |   |  |  |  |  | <--- Each sub-block of the parent block is of uniform size.
  |   +--+--+--+--+
  |   |  |  |  |  |
  |   +--+--+--+--+
  |   |  |  |  |  |
  V   +--+--+--+--+
      Row or Column --->
</pre>

  <p><strong>semi</strong> For a regular division of a block in the east and north directions but an
  infinitely variable z value for block height.</p>
  
  <pre>
+--+--+--+--+
|  +--+  |  |
|  |  +--+  |
|  +--+  |  | Infinitely variable in the level direction.
+--+  |  |  |
+--+--+--+--+
Uniform divisions in the row and column directions.
</pre>

  <p><strong>octree</strong> For an oct-tree subvision of a block.</p>
  
  <pre>
+-----+-----+
|     |     |
+--+--+-----+  Recursive bisecting the blocks until a limit.
+--+--+     |
+--+--+-----+
</pre>

  <p><strong>free</strong> For a free subdivision of a block where each subblock is individually
  defined as being some subvolume of the parent.</p>
  
  <pre>
+-----------+
|    +----+ |
|    |    | |
|    +----+ | Bad diagram but essentially possible with this option.  This is a catchall case for
+--+        | those types of subblocking I have not addressed.
|  |        |
+--+--------+
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatMineModelInfoData", "Data");</script>

  <p>This is where the model data is placed.  The format is slightly different in that it is a key 
  value list but without value headers and potentially optional values depending on the key.</p>

  <p>The model data is a value stream chunk.  This stream can be in text, e, or z encodings.  The 
  contents are broken down in key, or key and value pairs.</p>

  <table>
   <tr><th>Key&nbsp;(1&nbsp;Byte)</th><th>Value</th></tr>
   <tr><td>B           </td><td>n2 value follows immeadiately.  Jump to current level index + N.  Reset current row and current column to 0</td></tr>
   <tr><td>b           </td><td>No value.  Jump to next level.</td></tr>
   <tr><td>R           </td><td>n2 value follows immeadiately.  Jump to current row index + N.  Reset currrent column to 0</td></tr>
   <tr><td>r           </td><td>No value.  Jump to next row.</td></tr>
   <tr><td>C           </td><td>n2 value follows immeadiately.  Jump to current column index + N.</td></tr>
   <tr><td>c           </td><td>No value.  Jump to next column.</td></tr>
   <tr><td>s           </td><td>Defining subblock.  See subblocking information below to deal with the various subblock types.</td></tr>
   <tr><td>V           </td><td>For the current block or subblock, provide all values for the items 
   defined in the infoModel section in the order they appear in the infoModel (not including 
   calculated items), each value separated by a \n in text mode.  In Binary mode values are using as
   many bytes as necessary as defined by the items.<br />
   Increment the column or subblock column (if applicable).<br />
   (If applicable) If this is the last column or subblock column, column restarts at the first 
   column, increment the row.<br />
   (If applicable) If this is the last row or subblock row, row restarts at the first row, increment
   the level.<br />
   (If applicable) If this is the last subblock level, move to the next parent block following these
   rules.<br />
   If this is the last block and last subblock block, there should not be anything else in the value
   stream.</td></tr>
   <tr><td>v           </td><td>No value.  Copy the last blocks values to the current block.  Increment to the next block.</td></tr>
   <tr><td>.           </td><td>No value.  Indicates end of the subblock data or value stream.</td></tr>
  </table>

  <p>The above may not make that much sense yet so here is an example of a 5x5 block model where we
  have 3 r4 values per block.</p>

  <table>
   <tr><th>File&nbsp;Contents</th><th>What is happening</th></tr>
   <tr><td>model vs         </td><td>Start of the model data value stream.  Current block is 0 (first) level, 0 (first) row, 0 (column)</td></tr>
   <tr><td>B2               </td><td>Add 2 to the level index.  Current block jumps to 2, 0, 0.  All blocks on levels 0 and 1 have default values.</td></tr>
   <tr><td>R3               </td><td>Add 2 to the row index. Curent block jumps to 2, 2, 0.  All blocks on level 2, rows 0 and 1 have default values.</td></tr>
   <tr><td>C2               </td><td>Add 2 to the column index.  Current block jumps to 2, 2, 2.  Block 2, 2, 0, and Block 2, 2, 1 have default values.</td></tr>
   <tr><td>v1.2\n2.3\n3.14\n</td><td>Block 2, 2, 2 has values 1.2, 2.3, 3.14.  Current block after this line is 2, 2, 2.</td></tr>
   <tr><td>c                </td><td>Block 2, 2, 3 get default value.  Current block after this line is 2, 2, 4.</td></tr>
   <tr><td>c                </td><td>Block 2, 2, 4 get default value.  Current block after this line is 2, 3, 0.  We jumped to the next row</td></tr>
   <tr><td>s                </td><td>Block 2, 3, 0 is subblocked.  Depending on the subblocking used
   we start at 0, 0, 0 subblock and used the same B, b, R, r, C, c for navigating the subblock blocks
   until we reach the subblock block or a '.' key is reacched.  See below for subblock filling.</td></tr>
   <tr><td>S                </td><td>Similar to s but parent block has values as well as having 
   subblocks with values.  First v encountered is for the parent block. c to jump to the first 
   subblock block.</td></tr>
   <tr><td>...              </td><td>
   <tr><td>.                </td><td>Current block can be anything, this indicates that the rest of the model blocks not yet reached are set to default values.
  </table>

  <p>Note that there are no \n after every key value pairs.  This is to keep the text representation
  as compact as possible.  In binary the above will look like...</p>

  <pre>
[n1:5]["model"],["vst "],["B"],[n2:2],["R"],[n2:2],["C"],[n2:2],["v"],[r4:1.2],[r4:2.3],[r4:3.14],["c"],["c"],["s"]...,["."]
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatMineModelFixed", "SubBlock: Fixed");</script>

  <p>In the fixed case of subblocking, as soon as an 's' key is hit, that block is divided into the
  subblocks as defined in the infoModel section. Use B, b, R, r, C, c, and . in the same way as for
  the parent blocks.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatMineModelSemi", "SubBlock: Semi");</script>

  <p>In the semi fixed case of subblocking, as soon as an 's' key is hit, that block is divided into
  the subblocks as defined in the infoModel section.  One difference...</p>

  <p>In this scheme of subblocking, there is an infinite variability in the z direction for each 
  subblock.  This is defined by an 'H' key for the first level of blocks of the subblocks.  The 
  number of level subblocks will depend on how many times H is used for the same column.</p>

  <table>
   <tr><th>Key</th><th>Value</th></tr>
   <tr><td>H</td><td>r4 value immediately follows.  The r4 value is a percent of the block height.  This record needs to preceed a v record.</td></tr>
   <tr><td>h</td><td>No value.  The rest of the subblock cylinder is used.</td></tr>
  </table>

  <p>If H or h follows an H or h then the previous block will be holding default values, and the 
  current block will be incremented to the next subblock.  The following H or h will determin the
  height of the new current block.</p>
  
  <p>If a subblock cell has already defined the entire height of the block then these will be 
  skipped over when jumping to the next subblock.  This means that some subblock cells could have a
  different number of levels that others.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatMineModelTree", "SubBlock: Octree");</script>

  <p>In the octree case, an 's' key will split the block or subblock in to 8 uniform pieces.  If we
  are already at a subblock then that subblock will be split into small 8 uniform pieces.  This
  should not exceed the subblock option count defined in the model information block.</p>

  <p>The 's' key need to preceed the v record.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(4, "formatMineModelFree", "SubBlock: Free");</script>

  <p>In the free block case, an 's' key will indicate the parent block is subblocked.  However after
  that you will need to define the blocks manually.</p>

  <table>
   <tr><th>Key</th><th>Value</th></tr>
   <tr><td>c</td><td>6 x r4 values follow.  First 3 r4 values are percents for the min point and the second 3 r4 values are percents for the max point of the subblock.</td></tr>
   <tr><td>.</td><td>Indicates we are done with the subblocking and to process to the next parent block.</td></tr>
  </table>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(1, "formatMineItemList", "ItemList");</script>
  
  <p>All item lists are structured as a 'kv'.  An item list will list all the items that each data 
  point/slot/block/assay will have associated with it.  The Item list is just a simple list of items.
  Items defined how some value is recorded.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(2, "formatMineModelInfoItem", "Item");</script>
  
  <p>Each item is also a key-value block.</p>
   
  <table>
   <tr><th>Key</th><th>Value&nbsp;Header</th><th>Value</th>
   <tr><td>item</td><td>kv</td><td>See below.</td></tr>
  </table>
  
  <p>Inside, you will find most of the following key values.</p>
  
  <table>
   <tr><th>Key</th><th>Value&nbsp;Header</th><th>Value</th>
   <tr><td>id         </td><td>""</td><td>The short identifier for the item.</td></tr>
   <tr><td>nameLong   </td><td>""</td><td>The nice, longer name for the item.</td></tr>
   <tr><td>nameShort  </td><td>""</td><td>The shorter name for the item.</td></tr>
   <tr><td>type       </td><td>ty</td><td>The type of value associated with this item.  One of... "", i1, i2, i4, i8, n1, n2, n4, n8, r4, r8, en (enumerated field), +x (calculated field)</td></tr>
   <tr><td>min        </td><td>r4</td><td>The minimum value for this item, if available or applicable.</td></tr>
   <tr><td>max        </td><td>r4</td><td>The maximum value for this item, if available or applicable.</td></tr>
   <tr><td>precision  </td><td>r4</td><td>The precision value for this item, if available or applicable.  I.E. 0.001 if the value is accurate to that amount.</td></tr>
   <tr><td>enumList   </td><td>""</td><td>The list of enum values if type above is "en".  What is store in the block values is the index into this list.</td></tr>
   <tr><td>default    </td><td>[type]</td><td>Depending on "type" above the [type] here will match.  This defines a default value for blocks that are not specifically set.</td></tr>
   <tr><td>calculation</td><td>""</td><td>This item is a calculated field.  This specifies the formula used for this field.</td></tr>
  </table>



  <script>UpdateToc();</script>

 </body>
</html>
<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8" />
  <link rel="stylesheet" type="text/css" href="style_reset.css">
  <link rel="stylesheet" type="text/css" href="style.css">
  <title>M.I. M.I.F.F.: Mining Interchange MIFF</title>

  <!-- Script for generation a table of contents -->
  <script>
const indexLEVEL     = 0;
const indexTAG       = 1;
const indexTITLE     = 2;
const indexHAS_TYPE  = 3;
const indexHAS_CONST = 4;
const indexHAS_FUNC  = 5;
const indexCOUNT     = 6;

var tocIndex = 0;
var toc      = [];

// Display a header line and add to the table of contents (TOC)
function HeaderAdd(level, tag, title)
{
   var record = [];
   
   record[indexLEVEL]     = level;
   record[indexTAG]       = tag;
   record[indexTITLE]     = title;
   record[indexHAS_TYPE]  = false;
   record[indexHAS_CONST] = false;
   record[indexHAS_FUNC]  = false;

   toc.push(record);

   // Chrome complains about this document write.  I have looked for an alternative but everything
   // I have found is utter rubbish.  HeaderAdd is only called on doc load.  This call is not a
   // problem.
   document.write("<h" + level + "><a name=\"" + tag + "\">" + title + "</a></h" + level + ">\n\n");
}

function HeaderAddType()
{
   var record = toc[toc.length - 1];

   record[indexHAS_TYPE] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Type\">Type</a></h2>\n\n");
}

function HeaderAddConst()
{
   var record = toc[toc.length - 1];

   record[indexHAS_CONST] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Const\">Constant</a></h2>\n\n");
}

function HeaderAddFunc()
{
   var record = toc[toc.length - 1];

   record[indexHAS_FUNC] = true;

   document.write("<h2><a name=\"" + record[indexTAG] + "Func\">Function</a></h2>\n\n");
}

// Update the TOC with all the header lines.
function UpdateToc()
{
   var value;
   var record;
   var index;

   value = "<table>\n";

   for (; tocIndex < toc.length; tocIndex++)
   {
      record     = toc[tocIndex];
    
      value += "<tr>\n<td>";
    
      // Indenting
      for (index = 1; index < record[0]; index++)
      {
         value += "&nbsp;&nbsp;&nbsp;&nbsp;";
      }

      value += "<a href=\"#" + record[1] + "\">" + record[2] + "</a></td>\n";
      
      value += "<td>";
      if (record[indexHAS_TYPE] == 1)
      {
         value += "<a href=\"#" + record[1] + "Type\">Type</a>\n";
      }
      value += "</td>\n";
      
      value += "<td>";
      if (record[indexHAS_CONST] == 1)
      {
         value += "<a href=\"#" + record[1] + "Const\">Constant</a>\n";
      }
      value += "</td>\n";

      value += "<td>";
      if (record[indexHAS_FUNC] == 1)
      {
         value += "<a href=\"#" + record[1] + "Func\">Function</a>\n";
      }
      value += "</td>\n";

      value += "</td>\n";
   }

   value += "</table>\n";

   document.getElementById("toc").innerHTML = value;
}
  </script>
 </head>
 <body>
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <h1 class="page">M.I. M.I.F.F.: Mining Interchange MIFF</h1>

  <table>
   <tr>
    <td><p>Author:</p></td>
    <td>Robbert de Groot</td>
   </tr>
   <tr>
    <td><p>Date:</p></td>
    <td>2019-05-15</td>
   </tr>
   <tr>
    <td><p>Copyright:</p></td>
    <td>2019, Robbert de Groot</td>
   </tr>
   <tr>
    <td><p>License:</p></td>
    <td>The library will be MIT License.</td>
   </tr>
   <tr>
    <td></td>
    <td>This document is licensed under Creative Commons Attribution-NoDerivs. 
	<a href="https://creativecommons.org/licenses/by-nd:4.0/">(CC BY-ND)</a></td>
   </tr>
  </table>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <h1>Table Of Contents:</h1>

  <p id="toc"></p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "miff", "M.I. M.I.F.F.");</script>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "about", "Discussion");</script>

  <p>What is the purpose of M.I. M.I.F.F. (MI-MIFF)?  MI-MIFF is intended to be a file format for 
  exporting and importing data from one mining software package to another software package.</p>

  <p>Users of software packages are becoming increasingly annoyed at the lack of interoperability
  between software packages.  Currently each software package attempts to do its best at supporting
  competitor file formats but there is often a lot of loss of data or, as data formats in each
  package evolves, suffer from compatibility issues.  Often data needs to be dumped to formats that
  come 'close' but are not exact or down to very basic, raw ASCII files, like csv files, which are
  often lacking compared to the original data.  Users will need to massage this raw data in order
  to import it into their target software package.</p>

  <p>A lot of the client's time is lost with all this work.  The idea with an interchange format is
  to remove some of the pain of this data transfer task and put more of the pain on the software
  vendors of doing the hard part of reading in the data to their expectations.  The software users
  will not need to know some of the intricacies of the data or task.</p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "goals", "Goals");</script>

  <p>The main goal of this format is to be specifically an interchange format.  It is not intended
  to be a native format for any software package.  The focus is to make it easy for the developers
  from any software package to export their data to this interchange format and, without too much
  difficulty, to import other vendor's data.</p>

  <p>For the users of the software packages, the process of moving data from package to package will
  be much easier, less time consuming, and less problematic as they will only have to export and 
  import to just one type of file instead of various file formats and requiring more intimate 
  knowledge of the data transfer process specific to their software packages.</p>

  <ul>
   <li><strong>Simple</strong>.  The format should be simple for the developers to export their 
   data.  Import may still be challenging because of the differences between software packages but
   the format to import the data should not impose too much pain for the developers either.  The
   simplicity should go a long way in getting the format adopted and implemented.</li>

   <li><strong>Inclusive</strong>.  All data from all venders should be representable with the least
   amount of compromizes in the data being exported.</li>

   <li><strong>Brief</strong>.  The format should not produce unnecessary waste.  The data in some
   cases will be quite large so it should not bloat the data too much.  Meaning, file sizes should
   not become overly large.  However, because of point 1 there will always be some bloat.</li>

   <li><strong>Flexible</strong>.  The format needs to be able to accomodate change or vendor
   specific data.  A few software vendors started life in the 70's with time shared machines.  Over
   the years the amount of data and the types of data the clients want to maintain has changed and
   grown.  A format needs to try its best to keep up without importers and exporters to be
   completely remade.</li>
  </ul>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "disclosure", "Disclosure");</script>

  <p>As of this writing I, Robbert de Groot, am a Principal Software Developer with Hexagon
  (previously known as (pka) Hexagon Mining, pka MineSight, pka Mintec Inc.), the current owners of
  MinePlan 3D software (pka MineSight 3D; pka MEDSystem.); Leica Geosystems, the makers of survey
  equipment and related material; as well as other mine related hardware and software products.</p>

  <p>This format is currently not sanctioned by any software vendor, including Hexagon.  This was
  something I am doing as an experiment to satisfy my curiosity.  It was brought about by recent
  efforts being made by Global Mining Guidelines (GMG), with their Open Mining Format (OMF), which
  seems to have the backing of some big players in the industry.  My issue with OMF, for now, is
  that they only have a Python library that implements the format available publically.  They may
  have a specification document somewhere but currently it is not available, or at least I cannot
  find it anywhere in the 'open'.  Plus this format seems to be strictly binary, which is not
  entirely a bad idea considering the data that needs to be passed around, but binary formats can be
  very fussy.  And inspecting their sample OMF file, it does not look like something that is easily 
  reverse engineered.</p>

  <p>So, I thought I would try my hand at defining a format what I think would be good as an
  interchange format.  I am trying to write MIFF independent of any software package.  However there
  may be some unintended bias as I am most familiar with MinePlan 3D for which I have worked on 
  since 1995.  I do intend to keep this format as inclusive as possible to address other software 
  package requirements as best as I understand them.  I know I will make mistakes there because I 
  have only cursory knowledge of most of the competing software in the industry.</p>

  <p>If anyone is interested in educating me on some features they would like to see with respect to
  their software package of choice I would love to hear from you.  You can reach me at either of the
  following two email addresses.</p>

  <p>robbert.degroot@hexagon.com<br />zekaric@gmail.com</p>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "formatMine", "MI-MIFF Format");</script>

  <p>See the MIFF_Mixed_Information_File_Format.htm file for the discussion of the base file format
  which is being used for the interchange file format.  This document will cover specifics related
  to using MIFF for mining as an interchange file format to move data.</p>

  <p>The data mining companies need to keep track of and transfer around.</p>

  <ul>
   <li>
    Geometry
    <ul>
     <li>
      3D
      <ul>
       <li>Points</li>
       <li>Polylines (open and closed)</li>
       <li>Surfaces:Generic (open and closed (solids))</li>
       <li>Surfaces:Grid</li>
       <li>Text</li>
       <li>Symbol</li>
      </ul>
     </li>
     <li>
      2D (Planar, Fence)
      <ul>
       <li>Points</li>
       <li>Polylines (open and closed)</li>
       <li>Text</li>
       <li>Symbol</li>
      </ul>
     </li>
    </ul>
   </li>
   <li>
    Drillhole
    <ul>
     <li>Drillhole survery information.</li>
     <li>Drillhole assay information.</li>
     <li>Drillhole composite information.</li>
     <li>Blast hole shot information.</li>
     <li>Chip assay information.</li>
     <li>Design vs surveyed information.</li>
    </ul>
   </li>
   <li>
    Model
    <ul>
     <li>
      Block model information.
      <ul>
       <li>Regular</li>
       <li>Sub-blocked</li>
       <li>Seam</li>
      </ul>
     </li>
     <li>
      Seam model information.
      <ul>
       <li>Regular</li>
       <li>Sub-blocked</li>
      </ul>
     </li>
     <li>
      Surface model information.
      <ul>
       <li>Regular</li>
       <li>Sub-blocked</li>
      </ul>
     </li>
    </ul>
   </li>
  </ul>

  <p>MI-MIFF will handle all these types of data.  However, how each is actually stored in MIFF can
  vary.</p>
  
  <p>File naming can help in MIFF file importing.  It is suggested to use the following file 
  extensions...</p>
  
  <table>
   <tr><th>Extension</th><th>File Contents</th></tr>
   <tr><td>*.miff      </td><td>Still valid but can be anything.  What is it?</td></tr>
   <tr><td>*.miffDrill </td><td>for Drillhole data.</td></tr>
   <tr><td>*.miffGeom  </td><td>for Geometry data.</td></tr>
   <tr><td>*.miffModel </td><td>for Model data.</td></tr>
   <tr><td>*.miffMI    </td><td>for a very general Mine Interchange of anything above.</td></tr>
  </table>
  
  <p>This information is duplicated inside the file so reading in the file will confirm with the 
  extension but it will help the user if the extension is properly set and will make it easier on 
  the software on how to read in the file if these are properly set.</p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formatMineHeader", "Header");</script>
  
  <p>MIFF has fields for a Sub-Format Name and Version.  For a MI-MIFF file this will be set to...</p>
  
  <table>
   <tr><td>Sub-Fromat Name</td><td>Mining Interchange</td></tr>
   <tr><td>Sub-Format Version</td><td>1</td></tr>
  </table>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "formatMineInfo", "Information Block");</script>

  <p>Common to all MI-MIFF files for any of the types above, there will be an information 
  block providing general, project wide information.</p>
  
  <p>This information block will be the very first key value in the file right after the MIFF 
  header.</p>

  <pre>info kv</pre>

  <p>Inside the information block we have the following possible key values.  Not all are required.
  </p>

  <pre>
type              "" [file type]
company           "" [company name]
copyright         "" [copyright if any]
author            "" [client employee name]
dateCreated       t* [date created]
dateModified      t* [date modified]
comment           "" [comments]
software          "" [software preparing this file]
softwareVersion   "" [software version]
projectName       "" [name of project area]
projectMin        PR [minimum project area point]
projectMax        PR [maximum project area point]
projectSystem     "" [coordinate system the project is in]
...
</pre>

  <p>
   [file type] is one of...
  </p>
  <table>
   <tr><th>Value</th><th>Description</th></tr>
   <tr><td>Mixed</td><td>Combination of any of the types below.</td></tr>
   <tr><td>Drillhole</td><td>Only holds drillhole data.</td></tr>
   <tr><td>Geometry</td><td>Only holds geometry data.</td></tr>
   <tr><td>Model</td><td>Only holds model data.</td></tr>
   <tr><td>...</td></tr>
  </table>

  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <!--##########################################################################################-->
  <script>HeaderAdd(1, "formatMineModel", "MIFF Format: Mining: Model");</script>

  <p>Some of the information found here is based off of the block model formats that are used at
  Hexagon, where I work, but also from information found freely on the internet.</p>

  <p><a href="https://www.deswik.com/wp-content/uploads/2019/01/Block-model-knowledge-for-mining-engineers-An-introduction-1.pdf">Block Model Knowledge For Mining Engineers - An Introduction</a></p>

  <p>There are 3 basic model formats that are in use as Hexagon.</p>

  <ul>
   <li>Block Model</li>
   <li>Seam Model</li>
   <li>Surface Model</li>
  </ul>

  <p>Block Model is a regular collection of, usually, uniform blocks.  Each block will have values
  for items that are being tracked by the client.</p>
  
  <p>Seam Model is a bit fancier Block Model.  This model is subdivided uniformly in the row and
  column directions of the model but instead of levels, seams are described.  Each block in a seam
  will have an elevation top and bottom to indicate the seam's limits, as well as any other values
  that are found within that seam block just like a normal block model.</p>
  
  <p>Surface Model is much more limited than the other two as it just holds a stack of surfaces
  instead of defining any volume.  This model is subdivided uniformly in the row and column
  directions of the model but instead of seams you will have a surface.  Each 'block', or really the
  contact point, for a surface will have an elevation value as well as other values that are being
  tracked by the client at that surface point.</p>
  
  <p>Even though only Block Models are sub-blocked, Mi-MIFF does not limit you to only allowing
  sub-blocks for Block Models.  The logic could be applied to the other two types of models.  As far
  as I know, no software vendors sub-block for Seam or Surface Models.</p>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formatMineModelInfo", "Information Block: Model");</script>

  <p>After the general information block the next block will be the Model Information block.</p>

  <pre>
infoModel kv
 type             "" [model type]
 isSubblocked     bo [true if subblocked]
 subblockType     "" [subblock type]
 subblockOption   Pn [subblock fixed resolution]
 subblockOption   pn [subblock row col resolution]
 subblockOption   n1 [subblock octtree level count]
 origin           PR [origin point]
 colVec           PR [column vector, length if vector is the length of the block] 
 rowVec           PR [row vector, length of the vector is the length of the block]
 levVec           PR [level vector, length of the vector id the length of the block] 
 blockCount       Pn [number of column, row, level blocks]
 isLevVariable    bo [true if variable level heights]
 levList          r4a [number of levels] [length] [length] ...
 itemList         kv [item list count]
  item kv 
   id          "" [item id]
   nameLong    "" [item name]
   nameShort   "" [item name short]
   type        ty [item type]
   min         r4 [item min value]
   max         r4 [item max value]
   precision   r4 [item precision]
   enumList    ""A [enum count] 
   default     [type] [default value for this item]
   calculation "" [calculation field value]
   ...
   \n
  ...
  \n
 \n
\n
</pre>

  <p><strong>[model type]</strong> will be one of...</p>
  
  <table>
   <tr><th>Value</th><th>Description</th></tr>
   <tr><td>block     </td><td>For a block model.   </td></tr>
   <tr><td>seam      </td><td>For a seam model.    </td></tr>
   <tr><td>surface   </td><td>For a surface model. </td></tr>
  </table>

  <p><strong>[subblock type]</strong> will be one of...</p>
  
  <table>
   <tr><th>Value</th><th>Description</th></tr>
    <tr><td>fixed</td><td>For a regular division of the block in the east, north, and z directions
    of the block.<br />
    <pre>
Using just a cross section.
Level +--+--+--+--+
  |   |  |  |  |  | <--- Each sub-block of the parent block is of uniform size.
  |   +--+--+--+--+
  |   |  |  |  |  |
  |   +--+--+--+--+
  |   |  |  |  |  |
  V   +--+--+--+--+
      Row or Column --->
</pre></td></tr>

    <tr><td>semi</td><td>For a regular division of a block in the east and north directions but an
    infinitely variable z value for block height.<br />
    <pre>
+--+--+--+--+
|  +--+  |  |
|  |  +--+  |
|  +--+  |  | Infinitely variable in the level direction.
+--+  |  |  |
+--+--+--+--+
Uniform divisions in the row and column directions.
</pre></td></tr>

    <tr><td>octree</td><td>For an oct-tree subvision of a block.<br />
    <pre>
+-----+-----+
|     |     |
+--+--+-----+  Recursive bisecting the blocks until a limit.
+--+--+     |
+--+--+-----+
</pre></td></tr>

    <tr><td>free</td><td>For a free subdivision of a block where each subblock is individually
    defined as being some subvolume of the parent.<br />
    <pre>
+-----------+
|    +----+ |
|    |    | |
|    +----+ | Bad diagram but essentially possible with this option.  This is a catchall case for
+--+        | those types of subblocking I have not addressed.
|  |        |
+--+--------+
</pre></td></tr>
  </table>


  <p>Depending on what is set for [subblock type] there will be one of 3 [subblockOption] values.</p>
  
  <ul>
   <li>fixed subblocking requires a Pn to define the number of divisions in the east, north and z directions.</li>
   <li>semiFixed subblocking requires a pn to define the number of divisions in the east and north directions.</li>
   <li>octree subblocking requires a n1 to define the max number of oct-tree divisions that can occur for a block.</li>
   <li>free subblocking does not require an option.</li>
  </ul>

  <pre>
       \   /
        \ /
         +  Column 1
        / \
 Row 1 /   \   /
      /     \ /
     /Lev 0  +
\   / Row 0 /|
 \ /  Col 0/ |
  +       / <----- colVec (Length is block size. Direction is direction of increasing column index.)
  |\     /   |/
  | \ <----------- rowVec (Length is block size. Direction is direction of increasing row index.)
\ |  \ /    /|
 \|   o <--------- origin (3D point indicating the outter most corner of the first block.)
  +   |   /
  |\  | <--------- levVec (Length can be block size or unit, depends see below. Direction is direction of increasing level index.)
  | \ | /
     \|/
      +
      | Level 1
      |
</pre>

  <p><strong>origin</strong> - The extreme most point of the first column, first row, and first 
  level block of the model.</p>
  
  <p><strong>colVec, rowVec, levVec</strong> - The direction vectors of increasing block index for 
  the column, row, and level directions.  The length of this vector is the size of the block in the
  column, row and level directions.  levVec does not need to be sized if the level height is 
  variable.  It should at least be unit length.  All vectors need not be perpendicular to each other
  but usually this is the case in most software.  I believe there is one software where colVec and 
  rowVec are not 90 degrees to the levVec.  Essentially creating sloped levels.</p>
  
  <p><strong>blockCount</strong> - The number of column, row, and level blocks.</p>
  
  <p><strong>isLevVariable</strong> - Flag to indicate the level heights are not uniform.  This does
  not need to be present if the levels are a fixed height.</p>
  
  <p><strong>levList</strong> - A list of level heights starting from first level.  Only required if
  isLevVariable is true.</p>
  
  <p><strong>itemList</strong> - A key value block for the list of items stored in each block.  Can 
  be using the array notation for this block if item count is known.</p>

  <p><strong>item</strong> - A key value block describing the item.</p>
  
  <p><strong>id</strong> - A short unique string uniquely identifying the item.</p>
  
  <p><strong>nameLong</strong> - A 'nice' name for the item.</p>
  
  <p><strong>nameShort</strong> - A 'compact' name for the item.</p>
  
  <p><strong>type</strong> - What sort of value the item stores.  One of "", r4, r8, n1, n2, n4, n8,
  i1, i2, i4, i8, en ("en" for enumeration value), +x ("+x" for calculated field)</p>
  
  <p><strong>min, max</strong> - limits for an item if a number value.</p>
  
  <p><strong>precision</strong> - The accuracy of the number if type is r4 or r8.</p>
  
  <p><strong>enumList</strong> - Required only for "en" type.  This lists the enumeration values 
  available in a string list.</p>
  
  <p><strong>default</strong> - default value for this item if block is skipped.</p>
  
  <p><strong>calculation</strong> - a formula that is used to calculate the contents of this value.
  Use $[item id] in the formula to refer to another item value in the current block.  Full 
  discussion about the formula composition will be discussed elsewhere.</p>
  
  <pre>
Calculation example:
($ore% * $cu) - $i_am_making_something_up
</pre>

  <!--==========================================================================================-->
  <!--==========================================================================================-->
  <script>HeaderAdd(2, "formatMineModel", "Model Block:");</script>

  <p>This is where the model data is placed.  The format is slightly different in that it is a key 
  value list but without value headers and potentially optional values depending on the key.</p>

  <pre>model vs</pre>

  <p>The model data will be enclosed in a value stream chunk.  This stream can be in text, e, or z 
  encodings.  The contents are broken down in key, or key and value pairs.</p>

  <table>
   <tr><th>Key&nbsp;(1&nbsp;Byte)</th><th>Value</th></tr>
   <tr><td>B           </td><td>n2 value follows immeadiately.  Jump to current level index + N.  Reset current row and current column to 0</td></tr>
   <tr><td>b           </td><td>No value.  Jump to next level.</td></tr>
   <tr><td>R           </td><td>n2 value follows immeadiately.  Jump to current row index + N.  Reset currrent column to 0</td></tr>
   <tr><td>r           </td><td>No value.  Jump to next row.</td></tr>
   <tr><td>C           </td><td>n2 value follows immeadiately.  Jump to current column index + N.</td></tr>
   <tr><td>c           </td><td>No value.  Jump to next column.</td></tr>
   <tr><td>s           </td><td>Defining subblock.  See subblocking information below to deal with the various subblock types.</td></tr>
   <tr><td>V           </td><td>For the current block or subblock, provide all values for the items defined in the infoModel section in the order they appear in the infoModel (not including calculated items),</td></tr>
   <tr><td>            </td><td>each value separated by a \n in text mode.  In Binary mode values are using as many bytes as necessary as defined by the items. </td></tr>
   <tr><td>            </td><td>Increment the column or subblock column (if applicable).</td></tr>
   <tr><td>            </td><td>(If applicable) If this is the last column or subblock column, column restarts at the first column, increment the row.</td></tr>
   <tr><td>            </td><td>(If applicable) If this is the last row or subblock row, row restarts at the first row, increment the level.</td></tr>
   <tr><td>            </td><td>(If applicable) If this is the last subblock level, move to the next parent block following these rules.</td></tr>
   <tr><td>            </td><td>If this is the last block and last subblock block, there should not be anything else in the value stream.</td></tr>
   <tr><td>v           </td><td>No value.  Copy the last blocks values to the current block.  Increment to the next block.</td></tr>
   <tr><td>.           </td><td>No value.  Indicates end of the subblock data or value stream.</td></tr>
  </table>

  <p>The above may not make that much sense yet so here is an example of a 5x5 block model where we
  have 3 r4 values per block.</p>

  <pre>
File                   What is happening
--------------------   -----------------
model vs               Start of the model data value stream.  Current block is 0 (first) level, 0 (first) row, 0 (column)
B2                     Add 2 to the level index.  Current block jumps to 2, 0, 0.  All blocks on levels 0 and 1 have default values.
R3                     Add 2 to the row index. Curent block jumps to 2, 2, 0.  All blocks on level 2, rows 0 and 1 have default values.
C2                     Add 2 to the column index.  Current block jumps to 2, 2, 2.  Block 2, 2, 0, and Block 2, 2, 1 have default values.
v1.2\n2.3\n3.14\n      Block 2, 2, 2 has values 1.2, 2.3, 3.14.  Current block after this line is 2, 2, 2.
c                      Block 2, 2, 3 get default value.  Current block after this line is 2, 2, 4.
c                      Block 2, 2, 4 get default value.  Current block after this line is 2, 3, 0.  We jumped to the next row
s                      Block 2, 3, 0 is subblocked.  Depending on the subblocking used we start at 0, 0, 0 subblock and used the same B, b, R, r, C, c for 
                       navigating the subblock blocks until we reach the subblock block or a '.' key is reacched.  See below for subblock filling.
S                      Similar to s but parent block has values as well as having subblocks with values.  First v encountered is for the parent block.
                       c to jump to the first subblock block.
...
.                      Current block can be anything, this indicates that the rest of the model blocks not yet reached are set to default values.
</pre>

  <p>Note that there are no \n after every key value pairs.  This is to keep the text representation
  as compact as possible.  In binary the above will look like...</p>

  <pre>
[n1:5]["model"],["vst "],["B"],[n2:2],["R"],[n2:2],["C"],[n2:2],["v"],[r4:1.2],[r4:2.3],[r4:3.14],["c"],["c"],["s"]...,["."]
</pre>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatMineModelFixed", "SubBlock: Fixed");</script>

  <p>
   In the fixed case of subblocking, as soon as an 's' key is hit, that block is divided into the
   subblocks as defined in the infoModel section. Use B, b, R, r, C, c, and . in the same way as
   for the parent blocks.
  </p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatMineModelSemi", "SubBlock: Semi");</script>

  <p>
   In the semi fixed case of subblocking, as soon as an 's' key is hit, that block is divided into
   the subblocks as defined in the infoModel section.  One difference...
  </p>

  <p>
   In this scheme of subblocking, there is an infinite variability in the z direction for each subblock.
   This is defined by an 'H' key for the first level of blocks of the subblocks.  The number of level
   subblocks will depend on how many times H is used for the same column.
  </p>

  <table>
   <tr><th>Key</th><th>Value</th></tr>
   <tr><td>H</td><td>r4 value immediately follows.  The r4 value is a percent of the block height.  This record needs to preceed a v record.</td></tr>
   <tr><td>h</td><td>No value.  The rest of the subblock cylinder is used.</td></tr>
  </table>

  <p>If H or h follows an H or h then the previous block will be holding default values, and the 
  current block will be incremented to the next subblock.  The following H or h will determin the
  height of the new current block.</p>
  
  <p>If a subblock cell has already defined the entire height of the block then these will be 
  skipped over when jumping to the next subblock.  This means that some subblock cells could have a
  different number of levels that others.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatMineModelTree", "SubBlock: Octree");</script>

  <p>In the octree case, an 's' key will split the block or subblock in to 8 uniform pieces.  If we
  are already at a subblock then that subblock will be split into small 8 uniform pieces.  This
  should not exceed the subblock option count defined in the model information block.</p>

  <p>The 's' key need to preceed the v record.</p>

  <!---------------------------------------------------------------------------------------------->
  <script>HeaderAdd(3, "formatMineModelFree", "SubBlock: Free");</script>

  <p>In the free block case, an 's' key will indicate the parent block is subblocked.  However after
  that you will need to define the blocks manually.</p>

  <table>
   <tr><th>Key</th><th>Value</th></tr>
   <tr><td>c</td><td>6 x r4 values follow.  First 3 r4 values are percents for the min point and the second 3 r4 values are percents for the max point of the subblock.</td></tr>
   <tr><td>.</td><td>Indicates we are done with the subblocking and to process to the next parent block.</td></tr>
  </table>



  <script>UpdateToc();</script>

 </body>
</html>